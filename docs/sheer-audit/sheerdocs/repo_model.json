{
  "schema_version": "2.0",
  "repo": {
    "root": "/home/runner/work/pyfolds/pyfolds",
    "name": "pyfolds",
    "commit": null
  },
  "symbols": [
    {
      "id": "mod:src.pyfolds",
      "kind": "module",
      "name": "pyfolds",
      "qname": "src.pyfolds",
      "file": "src/pyfolds/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.__getattr__",
      "kind": "function",
      "name": "__getattr__",
      "qname": "src.pyfolds.__getattr__",
      "file": "src/pyfolds/__init__.py",
      "line": 149,
      "doc": "Provide deprecated v1 aliases while keeping v2 names canonical.",
      "params": [
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced",
      "kind": "module",
      "name": "advanced",
      "qname": "src.pyfolds.advanced",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "kind": "class",
      "name": "MPJRDNeuronAdvanced",
      "qname": "src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 47,
      "doc": "Neurônio MPJRD com TODOS os mecanismos avançados.\n\n✅ ORDEM CORRETA DE EXECUÇÃO:\n    1. Backpropagation: amplifica entrada baseado em spikes anteriores\n    2. Short-term dynamics: modula entrada (facilitação/depressão)\n    3. STDP: atualiza traços (não afeta forward atual)\n    4. Adaptation: atualiza estado adaptativo (sem sobrescrever spike final)\n    5. Refractory: bloqueia spikes (autoridade final de spike)\n    6. Base: forward base (WTA, homeostase, etc)\n\nPara inibição, use MPJRDLayerAdvanced em conjunto.",
      "params": [],
      "returns": null,
      "bases": [
        "BackpropMixin",
        "ShortTermDynamicsMixin",
        "STDPMixin",
        "AdaptationMixin",
        "RefractoryMixin",
        "MPJRDNeuronBase"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.advanced.MPJRDNeuronAdvanced.__init__",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 70,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced._init_advanced_mixins",
      "kind": "method",
      "name": "_init_advanced_mixins",
      "qname": "src.pyfolds.advanced.MPJRDNeuronAdvanced._init_advanced_mixins",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 74,
      "doc": "Inicializa mixins avançados com validações e logging de diagnóstico.",
      "params": [
        "self",
        "cfg",
        "is_wave"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.get_all_advanced_metrics",
      "kind": "method",
      "name": "get_all_advanced_metrics",
      "qname": "src.pyfolds.advanced.MPJRDNeuronAdvanced.get_all_advanced_metrics",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 132,
      "doc": "Retorna métricas de TODOS os mecanismos avançados.\n\nReturns:\n    dict: Dicionário com métricas de todos os mecanismos",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.reset_all_mechanisms",
      "kind": "method",
      "name": "reset_all_mechanisms",
      "qname": "src.pyfolds.advanced.MPJRDNeuronAdvanced.reset_all_mechanisms",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 160,
      "doc": "Reseta todos os mecanismos avançados.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "kind": "class",
      "name": "MPJRDWaveNeuronAdvanced",
      "qname": "src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 174,
      "doc": "Versão avançada do neurônio wave com mixins de mecanismos v2.x.",
      "params": [],
      "returns": null,
      "bases": [
        "BackpropMixin",
        "ShortTermDynamicsMixin",
        "STDPMixin",
        "AdaptationMixin",
        "RefractoryMixin",
        "MPJRDWaveNeuronBase"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.advanced.MPJRDWaveNeuronAdvanced.__init__",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 184,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.MPJRDLayerAdvanced",
      "kind": "class",
      "name": "MPJRDLayerAdvanced",
      "qname": "src.pyfolds.advanced.MPJRDLayerAdvanced",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 189,
      "doc": "Camada que injeta automaticamente `MPJRDNeuronAdvanced`.",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDLayer"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDLayerAdvanced.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.advanced.MPJRDLayerAdvanced.__init__",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 192,
      "doc": null,
      "params": [
        "self",
        "n_neurons",
        "cfg",
        "name",
        "enable_telemetry",
        "telemetry_profile",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.MPJRDWaveLayerAdvanced",
      "kind": "class",
      "name": "MPJRDWaveLayerAdvanced",
      "qname": "src.pyfolds.advanced.MPJRDWaveLayerAdvanced",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 212,
      "doc": "Camada avançada para neurônios wave + mecanismos v2.x.",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDLayer"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.MPJRDWaveLayerAdvanced.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.advanced.MPJRDWaveLayerAdvanced.__init__",
      "file": "src/pyfolds/advanced/__init__.py",
      "line": 215,
      "doc": null,
      "params": [
        "self",
        "n_neurons",
        "cfg",
        "name",
        "enable_telemetry",
        "telemetry_profile",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.adaptation",
      "kind": "module",
      "name": "adaptation",
      "qname": "src.pyfolds.advanced.adaptation",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "kind": "class",
      "name": "AdaptationMixin",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 9,
      "doc": "Mixin para adaptação de frequência de disparo (SFA).\n\n✅ SEMÂNTICA: POR AMOSTRA (batch independente)\n    - adaptation_current é [B] (um por amostra)\n    - Cada amostra tem sua própria corrente de adaptação\n\nBaseado em:\n    - Benda & Herz (2007) - A universal model for spike-frequency adaptation",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._init_adaptation",
      "kind": "method",
      "name": "_init_adaptation",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin._init_adaptation",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 21,
      "doc": "Inicializa parâmetros de adaptação a partir da config.\n\nArgs:\n    cfg: MPJRDConfig com parâmetros de adaptação",
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._ensure_adaptation_current",
      "kind": "method",
      "name": "_ensure_adaptation_current",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin._ensure_adaptation_current",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 36,
      "doc": "Garante que adaptation_current existe com tamanho correto.",
      "params": [
        "self",
        "batch_size",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._apply_sfa_before_threshold",
      "kind": "method",
      "name": "_apply_sfa_before_threshold",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin._apply_sfa_before_threshold",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 42,
      "doc": "Aplica SFA antes do threshold (u_eff = u - I_adapt).\n\nArgs:\n    u: Potencial somático [B]\n    dt: Passo de tempo (ms)\n\nReturns:\n    Potencial adaptado [B]",
      "params": [
        "self",
        "u",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._update_adaptation_after_spike",
      "kind": "method",
      "name": "_update_adaptation_after_spike",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin._update_adaptation_after_spike",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 64,
      "doc": "Atualiza I_adapt após spikes confirmados (pós-refratário).",
      "params": [
        "self",
        "spikes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._apply_adaptation",
      "kind": "method",
      "name": "_apply_adaptation",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin._apply_adaptation",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 72,
      "doc": "Compat: aplica SFA antes do threshold e atualiza com spikes.",
      "params": [
        "self",
        "u",
        "spikes",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.adaptation.AdaptationMixin.forward",
      "file": "src/pyfolds/advanced/adaptation.py",
      "line": 79,
      "doc": "Forward pass com adaptação POR AMOSTRA.",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.backprop",
      "kind": "module",
      "name": "backprop",
      "qname": "src.pyfolds.advanced.backprop",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "kind": "class",
      "name": "BackpropMixin",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 12,
      "doc": "Mixin para backpropagação dendrítica com opção proporcional.",
      "params": [],
      "returns": null,
      "bases": [
        "TimedMixin"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._init_backprop",
      "kind": "method",
      "name": "_init_backprop",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin._init_backprop",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 15,
      "doc": "Inicializa parâmetros de backpropagação a partir da config.",
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._ensure_backprop_trace",
      "kind": "method",
      "name": "_ensure_backprop_trace",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin._ensure_backprop_trace",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 37,
      "doc": "Garante que backprop_trace existe com tamanho correto.",
      "params": [
        "self",
        "batch_size",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._schedule_backprop",
      "kind": "method",
      "name": "_schedule_backprop",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin._schedule_backprop",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 44,
      "doc": "Agenda evento de backpropagação.",
      "params": [
        "self",
        "spike_time",
        "v_dend",
        "dend_contribution"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._process_backprop_queue",
      "kind": "method",
      "name": "_process_backprop_queue",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin._process_backprop_queue",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 63,
      "doc": "Processa eventos de backpropagação pendentes.",
      "params": [
        "self",
        "current_time"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin.forward",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 117,
      "doc": "Forward pass com backpropagação.",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.reset_backprop",
      "kind": "method",
      "name": "reset_backprop",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin.reset_backprop",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 140,
      "doc": "Reseta estado de backpropagação.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.get_backprop_metrics",
      "kind": "method",
      "name": "get_backprop_metrics",
      "qname": "src.pyfolds.advanced.backprop.BackpropMixin.get_backprop_metrics",
      "file": "src/pyfolds/advanced/backprop.py",
      "line": 147,
      "doc": "Retorna métricas de backpropagação.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.inhibition",
      "kind": "module",
      "name": "inhibition",
      "qname": "src.pyfolds.advanced.inhibition",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "kind": "class",
      "name": "InhibitionLayer",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 22,
      "doc": "Camada de inibição GABA para redes MPJRD.\n\nCaracterísticas:\n- Inibição lateral (gaussiana): neurônios próximos se inibem\n- Inibição feedforward (E→I): excitatórios ativam inibitórios\n- Inibição feedback (I→E): inibitórios inibem excitatórios\n- Esparsidade controlada (5-15%)\n- Overhead: ~5%\n\nUso típico:\n    exc_layer = MPJRDLayer(100, cfg)  # Excitatórios\n    inh_layer = InhibitionLayer(\n        n_excitatory=100,\n        n_inhibitory=25,\n        lateral_strength=0.5,\n        feedback_strength=0.4\n    )\n    \n    # Forward\n    exc_out = exc_layer(x)\n    inh_out = inh_layer(exc_out['spikes'])\n    exc_out_final = inh_layer.apply_inhibition(exc_out, inh_out)",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer.__init__",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 48,
      "doc": "Args:\n    n_excitatory: Número de neurônios excitatórios\n    n_inhibitory: Número de neurônios inibitórios (padrão: n_exc//4)\n    lateral_strength: Força da inibição lateral (0.0-1.0)\n    feedforward_strength: Força da inibição feedforward (0.0-1.0)\n    feedback_strength: Força da inibição feedback (0.0-1.0)\n    lateral_sigma: Largura do kernel gaussiano para inibição lateral\n    trainable_i2e: Se True, pesos I→E viram nn.Parameter treinável\n    seed: Seed opcional para inicialização de conectividade",
      "params": [
        "self",
        "n_excitatory",
        "n_inhibitory",
        "lateral_strength",
        "feedforward_strength",
        "feedback_strength",
        "lateral_sigma",
        "trainable_i2e",
        "seed"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._init_E2I_weights",
      "kind": "method",
      "name": "_init_E2I_weights",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer._init_E2I_weights",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 101,
      "doc": "Inicializa pesos E→I com conectividade esparsa determinística.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._init_I2E_weights",
      "kind": "method",
      "name": "_init_I2E_weights",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer._init_I2E_weights",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 119,
      "doc": "Inicializa pesos I→E com decay espacial.\n\nCada inibitório inibe todos os excitatórios,\nmas com força decaindo com a distância.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._create_lateral_kernel",
      "kind": "method",
      "name": "_create_lateral_kernel",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer._create_lateral_kernel",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 142,
      "doc": "Cria kernel gaussiano para inibição lateral entre excitatórios.\n\nReturns:\n    Tensor [n_exc, n_exc] com pesos de inibição lateral",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer.forward",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 161,
      "doc": "Processa neurônios inibitórios baseado nos spikes excitatórios.\n\nArgs:\n    exc_spikes: [batch, n_exc] spikes dos neurônios excitatórios\n    \nReturns:\n    Dict com:\n        'inh_spikes': [n_inh] spikes inibitórios (média sobre batch)\n        'inh_potential': [n_inh] potencial dos inibitórios\n        'feedforward_input': [n_inh] input feedforward",
      "params": [
        "self",
        "exc_spikes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.apply_inhibition",
      "kind": "method",
      "name": "apply_inhibition",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer.apply_inhibition",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 200,
      "doc": "Aplica inibição aos neurônios excitatórios.\n\nArgs:\n    exc_output: Output da camada excitatória (deve conter 'spikes' e 'u')\n    inh_output: Output desta camada (de 'forward')\n    \nReturns:\n    exc_output modificado com inibição aplicada",
      "params": [
        "self",
        "exc_output",
        "inh_output"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.get_inhibition_metrics",
      "kind": "method",
      "name": "get_inhibition_metrics",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer.get_inhibition_metrics",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 312,
      "doc": "Retorna métricas da inibição.\n\nReturns:\n    dict: Dicionário com métricas",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionLayer.extra_repr",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 331,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.inhibition.InhibitionMixin",
      "kind": "class",
      "name": "InhibitionMixin",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionMixin",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 337,
      "doc": "Mixin para integrar inibição em layers.\n\nNOTA: Este mixin opera no nível de Layer, não de neurônio individual.\nDeve ser usado com MPJRDLayer ou classes derivadas.\n\nUso:\n    class InhibitedLayer(InhibitionMixin, MPJRDLayer):\n        def __init__(self, n_neurons, cfg):\n            super().__init__(n_neurons, cfg)\n            self._init_inhibition()",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin._init_inhibition",
      "kind": "method",
      "name": "_init_inhibition",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionMixin._init_inhibition",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 351,
      "doc": "Inicializa camada inibitória.\n\nArgs:\n    n_inhibitory: Número de neurônios inibitórios (padrão: n_neurons//4)\n    lateral_strength: Força da inibição lateral\n    feedforward_strength: Força da inibição feedforward\n    feedback_strength: Força da inibição feedback\n    lateral_sigma: Largura do kernel gaussiano\n    trainable_i2e: Define se I→E é treinável (default usa cfg)\n    seed: Seed opcional para conectividade",
      "params": [
        "self",
        "n_inhibitory",
        "lateral_strength",
        "feedforward_strength",
        "feedback_strength",
        "lateral_sigma",
        "trainable_i2e",
        "seed"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionMixin.forward",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 390,
      "doc": "Forward com inibição aplicada.\n\nArgs:\n    x: Tensor de entrada [batch, n_neurons, dendrites, synapses]\n    **kwargs: Argumentos adicionais para a camada base\n\nReturns:\n    Dict com spikes após inibição",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin.get_inhibition_metrics",
      "kind": "method",
      "name": "get_inhibition_metrics",
      "qname": "src.pyfolds.advanced.inhibition.InhibitionMixin.get_inhibition_metrics",
      "file": "src/pyfolds/advanced/inhibition.py",
      "line": 417,
      "doc": "Retorna métricas da inibição desta layer.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.refractory",
      "kind": "module",
      "name": "refractory",
      "qname": "src.pyfolds.advanced.refractory",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "kind": "class",
      "name": "RefractoryMixin",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 8,
      "doc": "Mixin para período refratário.\n\n✅ SEMÂNTICA: POR AMOSTRA (batch independente)\n    - Cada amostra tem seu próprio estado refratário\n    - last_spike_time é [B] (um por amostra)\n    - Refratário aplicado individualmente",
      "params": [],
      "returns": null,
      "bases": [
        "TimedMixin"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._init_refractory",
      "kind": "method",
      "name": "_init_refractory",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin._init_refractory",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 18,
      "doc": "Inicializa parâmetros do período refratário.\n\nArgs:\n    t_refrac_abs: Duração do refratário absoluto (ms)\n    t_refrac_rel: Duração do refratário relativo (ms)\n    refrac_rel_strength: Força do boost no threshold durante refratário relativo",
      "params": [
        "self",
        "t_refrac_abs",
        "t_refrac_rel",
        "refrac_rel_strength"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._ensure_last_spike_time",
      "kind": "method",
      "name": "_ensure_last_spike_time",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin._ensure_last_spike_time",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 35,
      "doc": "Garante que last_spike_time existe com tamanho correto.\n\nArgs:\n    batch_size: Tamanho do batch\n    device: Device onde o tensor deve ser alocado",
      "params": [
        "self",
        "batch_size",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._check_refractory_batch",
      "kind": "method",
      "name": "_check_refractory_batch",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin._check_refractory_batch",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 49,
      "doc": "Verifica estado refratário para todas as amostras do batch.\n\nArgs:\n    current_time: Tempo atual\n    batch_size: Tamanho do batch\n    \nReturns:\n    Tuple com:\n        - blocked: [B] máscara de bloqueio (absoluto + relativo)\n        - theta_boost: [B] boost no threshold (apenas relativo)",
      "params": [
        "self",
        "current_time",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._update_refractory_batch",
      "kind": "method",
      "name": "_update_refractory_batch",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin._update_refractory_batch",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 85,
      "doc": "Atualiza estado refratário baseado nos spikes.\n\nArgs:\n    spikes: [B] spikes do passo atual\n    dt: Passo de tempo (ms)",
      "params": [
        "self",
        "spikes",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin.forward",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 104,
      "doc": "Forward pass com período refratário.\n\nArgs:\n    x: Tensor de entrada [B, D, S]\n    **kwargs: Argumentos adicionais (dt, etc.)\n    \nReturns:\n    Dict com spikes após aplicação do refratário",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.reset_refractory",
      "kind": "method",
      "name": "reset_refractory",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin.reset_refractory",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 176,
      "doc": "Reseta o estado refratário.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.get_refractory_metrics",
      "kind": "method",
      "name": "get_refractory_metrics",
      "qname": "src.pyfolds.advanced.refractory.RefractoryMixin.get_refractory_metrics",
      "file": "src/pyfolds/advanced/refractory.py",
      "line": 181,
      "doc": "Retorna métricas do período refratário.\n\nReturns:\n    dict: Dicionário com métricas",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.short_term",
      "kind": "module",
      "name": "short_term",
      "qname": "src.pyfolds.advanced.short_term",
      "file": "src/pyfolds/advanced/short_term.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "kind": "class",
      "name": "ShortTermDynamicsMixin",
      "qname": "src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "file": "src/pyfolds/advanced/short_term.py",
      "line": 8,
      "doc": "Mixin para dinâmica de curto prazo (facilitação/depressão).\n\n✅ SEMÂNTICA: GLOBAL (agregado sobre batch)\n    - Estados u_stp e R_stp são COMPARTILHADOS [D, S]\n    - Atualizações baseadas na MÉDIA do batch\n    - Modulação aplicada igualmente a todas as amostras\n\nImplementa:\n    - Facilitação (u): aumenta com spikes recentes\n    - Depressão (R): diminui com spikes recentes (recursos)\n\nA dinâmica de curto prazo é TEMPORÁRIA (100-1000ms) e NÃO deve\nmodificar os pesos estruturais (N) permanentemente.\n\nBaseado em:\n    - Markram et al. (1998) - Differential signaling via the same axon\n    - Tsodyks & Markram (1997) - The neural code between neocortical pyramidal neurons",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._init_short_term",
      "kind": "method",
      "name": "_init_short_term",
      "qname": "src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._init_short_term",
      "file": "src/pyfolds/advanced/short_term.py",
      "line": 29,
      "doc": "Inicializa parâmetros de curto prazo.\n\nArgs:\n    u0: Facilitação inicial\n    R0: Recursos iniciais\n    U: Incremento de facilitação por spike\n    tau_fac: Constante de tempo da facilitação (ms)\n    tau_rec: Constante de tempo da recuperação (ms)",
      "params": [
        "self",
        "u0",
        "R0",
        "U",
        "tau_fac",
        "tau_rec"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._update_short_term_dynamics",
      "kind": "method",
      "name": "_update_short_term_dynamics",
      "qname": "src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._update_short_term_dynamics",
      "file": "src/pyfolds/advanced/short_term.py",
      "line": 51,
      "doc": "Atualiza variáveis de curto prazo baseado em spikes pré-sinápticos.\n\n✅ CORRIGIDO:\n    - Usa math.exp em vez de torch.tensor (zero overhead)\n    - Operações mantidas no device correto via broadcasting\n\nArgs:\n    x: Tensor de entrada [B, D, S]\n    dt: Passo de tempo (ms)",
      "params": [
        "self",
        "x",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.short_term.ShortTermDynamicsMixin.forward",
      "file": "src/pyfolds/advanced/short_term.py",
      "line": 105,
      "doc": "Forward pass com dinâmica de curto prazo.\n\n✅ SEMÂNTICA GLOBAL (agregado sobre batch)\n✅ CORRIGIDO: sem criação de tensores desnecessários\n\nArgs:\n    x: Tensor de entrada [B, D, S]\n    **kwargs: Argumentos adicionais (dt, etc.)\n\nReturns:\n    Dict com spikes, potenciais e métricas de STP",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.stdp",
      "kind": "module",
      "name": "stdp",
      "qname": "src.pyfolds.advanced.stdp",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "kind": "class",
      "name": "STDPMixin",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 9,
      "doc": "Mixin de STDP (*Spike-Timing Dependent Plasticity*) vetorizado.\n\nO mecanismo mantém traços pré e pós-sinápticos por amostra de batch e\ncalcula atualizações locais de LTP/LTD sem loops em Python.\n\nSemântica implementada:\n\n- **LTP**: reforço proporcional ao traço pré quando há spike pós.\n- **LTD**: enfraquecimento proporcional ao traço pós quando há spike pós.\n\nNotes\n-----\nA atualização é aplicada ao tensor consolidado ``self.I`` quando disponível,\ncom *clamp* para o intervalo ``[cfg.i_min, cfg.i_max]``.\n\nReferences\n----------\nBi, G. Q., & Poo, M. M. (1998).\n\"Synaptic modifications in cultured hippocampal neurons\".\n\nSemântica implementada (determinística):\n\n- Traços pré/pós são mantidos por amostra, com shape ``[B, D, S]``.\n- O spike pós-sináptico é global por amostra e é broadcast para\n  todos os dendritos/sinapses.\n- Quando um neurônio dispara, todos os dendritos da mesma amostra\n  recebem a mesma modulação plástica.\n\nSe for necessário STDP por dendrito específico, ``_update_stdp_traces``\ndeve ser ajustado para aplicar máscara condicional por dendrito em vez\ndo broadcast global.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin._init_stdp",
      "kind": "method",
      "name": "_init_stdp",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin._init_stdp",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 43,
      "doc": "Inicializa parâmetros STDP.\n\nArgs:\n    tau_pre: Constante de tempo do traço pré-sináptico\n    tau_post: Constante de tempo do traço pós-sináptico\n    A_plus: Amplitude LTP\n    A_minus: Amplitude LTD\n    plasticity_mode: 'stdp', 'hebbian', 'both', 'none'",
      "params": [
        "self",
        "tau_pre",
        "tau_post",
        "A_plus",
        "A_minus",
        "plasticity_mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin._ensure_traces",
      "kind": "method",
      "name": "_ensure_traces",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin._ensure_traces",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 66,
      "doc": "Garante a alocação dos traços com shape compatível com o batch.\n\n:param batch_size: Tamanho do batch corrente.\n:param device: Dispositivo onde os traços serão mantidos.",
      "params": [
        "self",
        "batch_size",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin._stdp_pre_spike_source",
      "kind": "method",
      "name": "_stdp_pre_spike_source",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin._stdp_pre_spike_source",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 79,
      "doc": "Resolve fonte de pré-spike para STDP conforme configuração.",
      "params": [
        "self",
        "x",
        "x_pre_stp"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin._update_stdp_traces",
      "kind": "method",
      "name": "_update_stdp_traces",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin._update_stdp_traces",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 86,
      "doc": "Atualiza traços STDP e aplica deltas sinápticos vetorizados.\n\n:param x: Tensor de entrada com shape ``[B, D, S]``.\n:param post_spike: Spike pós-sináptico com shape ``[B]``.\n:param dt: Passo de tempo discreto da simulação.",
      "params": [
        "self",
        "x",
        "post_spike",
        "dt",
        "x_pre_stp"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin._should_apply_stdp",
      "kind": "method",
      "name": "_should_apply_stdp",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin._should_apply_stdp",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 143,
      "doc": "Determina se STDP deve ser aplicado no passo atual.\n\n:param mode: Modo explícito de aprendizado. Se ``None``, usa\n    ``self.mode`` quando disponível.\n:returns: ``True`` quando STDP está habilitado e o modo é compatível.",
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.stdp.STDPMixin.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.advanced.stdp.STDPMixin.forward",
      "file": "src/pyfolds/advanced/stdp.py",
      "line": 159,
      "doc": "Executa ``forward`` e acopla atualização de STDP quando habilitado.\n\n:param x: Entrada com shape ``[B, D, S]``.\n:param kwargs: Argumentos adicionais propagados ao ``forward`` base.\n    Chaves relevantes:\n\n    - ``mode``: modo de aprendizado.\n    - ``dt``: passo temporal para o decaimento dos traços.\n\n:returns: Dicionário de saída do neurônio acrescido de métricas STDP.\n\nExample\n-------\n>>> import torch\n>>> class _Base:\n...     def __init__(self):\n...         self.mode = LearningMode.ONLINE\n...     def forward(self, x, **kwargs):\n...         return {\"spikes\": torch.ones(x.shape[0])}\n>>> class _Cfg:\n...     n_dendrites = 1\n...     n_synapses_per_dendrite = 2\n...     i_min = 0.0\n...     i_max = 1.0\n...     spike_threshold = 0.0\n...     stdp_trace_threshold = 0.0\n>>> class _Neuron(STDPMixin, _Base):\n...     def __init__(self):\n...         _Base.__init__(self)\n...         self.cfg = _Cfg()\n...         self.I = torch.zeros(1, 2)\n...         self._init_stdp(plasticity_mode=\"stdp\")\n>>> n = _Neuron()\n>>> out = n.forward(torch.ones(1, 1, 2))\n>>> bool(out[\"stdp_applied\"].item())\nTrue\n>>> n.I.shape\ntorch.Size([1, 2])",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.advanced.time_mixin",
      "kind": "module",
      "name": "time_mixin",
      "qname": "src.pyfolds.advanced.time_mixin",
      "file": "src/pyfolds/advanced/time_mixin.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.advanced.time_mixin.TimedMixin",
      "kind": "class",
      "name": "TimedMixin",
      "qname": "src.pyfolds.advanced.time_mixin.TimedMixin",
      "file": "src/pyfolds/advanced/time_mixin.py",
      "line": 6,
      "doc": "Mixin base para mecanismos que precisam de contador de tempo.\n\nEste mixin resolve conflitos onde múltiplos mixins (Refractory, Backprop)\nprecisariam criar seus próprios contadores de tempo.\n\nUso:\n    class RefractoryMixin(TimedMixin):\n        def __init__(self):\n            self._ensure_time_counter()  # Garante que time_counter existe\n            # ...\n\nExample:\n    >>> class Neuron(RefractoryMixin, BackpropMixin, MPJRDNeuron):\n    ...     def __init__(self, cfg):\n    ...         self._ensure_time_counter()  # Único contador compartilhado\n    ...         # ...",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._ensure_time_counter",
      "kind": "method",
      "name": "_ensure_time_counter",
      "qname": "src.pyfolds.advanced.time_mixin.TimedMixin._ensure_time_counter",
      "file": "src/pyfolds/advanced/time_mixin.py",
      "line": 26,
      "doc": "Garante que time_counter existe.\n\nChamado por mixins que precisam de contador de tempo para garantir\nque apenas UM contador seja criado, evitando conflitos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._increment_time",
      "kind": "method",
      "name": "_increment_time",
      "qname": "src.pyfolds.advanced.time_mixin.TimedMixin._increment_time",
      "file": "src/pyfolds/advanced/time_mixin.py",
      "line": 36,
      "doc": "Incrementa contador de tempo.\n\nArgs:\n    dt: Passo de tempo a ser adicionado (ms)",
      "params": [
        "self",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._get_time",
      "kind": "method",
      "name": "_get_time",
      "qname": "src.pyfolds.advanced.time_mixin.TimedMixin._get_time",
      "file": "src/pyfolds/advanced/time_mixin.py",
      "line": 46,
      "doc": "Retorna o tempo atual.\n\nReturns:\n    float: Valor atual do contador de tempo",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.contracts",
      "kind": "module",
      "name": "contracts",
      "qname": "src.pyfolds.contracts",
      "file": "src/pyfolds/contracts/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.contracts.backends",
      "kind": "module",
      "name": "backends",
      "qname": "src.pyfolds.contracts.backends",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.contracts.backends._State",
      "kind": "class",
      "name": "_State",
      "qname": "src.pyfolds.contracts.backends._State",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 25,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "cls:src.pyfolds.contracts.backends._BaseContractBackend",
      "kind": "class",
      "name": "_BaseContractBackend",
      "qname": "src.pyfolds.contracts.backends._BaseContractBackend",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 32,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.contracts.backends._BaseContractBackend.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.contracts.backends._BaseContractBackend.__init__",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 33,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.contracts.backends._BaseContractBackend._trace",
      "kind": "method",
      "name": "_trace",
      "qname": "src.pyfolds.contracts.backends._BaseContractBackend._trace",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 36,
      "doc": null,
      "params": [
        "self",
        "t0"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.contracts.backends.TorchNeuronContractBackend",
      "kind": "class",
      "name": "TorchNeuronContractBackend",
      "qname": "src.pyfolds.contracts.backends.TorchNeuronContractBackend",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 40,
      "doc": "Implementação de referência do contrato com torch.",
      "params": [],
      "returns": null,
      "bases": [
        "_BaseContractBackend"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.contracts.backends.TorchNeuronContractBackend.run_step",
      "kind": "method",
      "name": "run_step",
      "qname": "src.pyfolds.contracts.backends.TorchNeuronContractBackend.run_step",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 43,
      "doc": null,
      "params": [
        "self",
        "step_input"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend",
      "kind": "class",
      "name": "TensorFlowNeuronContractBackend",
      "qname": "src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 88,
      "doc": "Implementação equivalente usando TensorFlow (quando disponível).",
      "params": [],
      "returns": null,
      "bases": [
        "_BaseContractBackend"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend.run_step",
      "kind": "method",
      "name": "run_step",
      "qname": "src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend.run_step",
      "file": "src/pyfolds/contracts/backends.py",
      "line": 91,
      "doc": null,
      "params": [
        "self",
        "step_input"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.contracts.neuron_contract",
      "kind": "module",
      "name": "neuron_contract",
      "qname": "src.pyfolds.contracts.neuron_contract",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.contracts.neuron_contract.MechanismStep",
      "kind": "class",
      "name": "MechanismStep",
      "qname": "src.pyfolds.contracts.neuron_contract.MechanismStep",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 8,
      "doc": "Enum com a ordem canônica dos mecanismos executados em um passo neuronal.",
      "params": [],
      "returns": null,
      "bases": [
        "str",
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.contracts.neuron_contract.NeuronStepInput",
      "kind": "class",
      "name": "NeuronStepInput",
      "qname": "src.pyfolds.contracts.neuron_contract.NeuronStepInput",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 34,
      "doc": "Entrada mínima necessária para executar um passo (`step`) do neurônio.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "cls:src.pyfolds.contracts.neuron_contract.StepExecutionTrace",
      "kind": "class",
      "name": "StepExecutionTrace",
      "qname": "src.pyfolds.contracts.neuron_contract.StepExecutionTrace",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 43,
      "doc": "Rastro de execução do passo contendo ordem e snapshots temporais.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "cls:src.pyfolds.contracts.neuron_contract.NeuronStepOutput",
      "kind": "class",
      "name": "NeuronStepOutput",
      "qname": "src.pyfolds.contracts.neuron_contract.NeuronStepOutput",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 53,
      "doc": "Saída contratual de um passo com spikes, potencial somático e rastro.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "cls:src.pyfolds.contracts.neuron_contract.ContractViolation",
      "kind": "class",
      "name": "ContractViolation",
      "qname": "src.pyfolds.contracts.neuron_contract.ContractViolation",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 61,
      "doc": "Erro lançado quando a saída de `step` viola o contrato formal.",
      "params": [],
      "returns": null,
      "bases": [
        "ValueError"
      ],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.contracts.neuron_contract.validate_step_output",
      "kind": "function",
      "name": "validate_step_output",
      "qname": "src.pyfolds.contracts.neuron_contract.validate_step_output",
      "file": "src/pyfolds/contracts/neuron_contract.py",
      "line": 67,
      "doc": "Valida invariantes de ordem e avanço temporal da execução de `step`.",
      "params": [
        "output",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core",
      "kind": "module",
      "name": "core",
      "qname": "src.pyfolds.core",
      "file": "src/pyfolds/core/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.create_neuron",
      "kind": "function",
      "name": "create_neuron",
      "qname": "src.pyfolds.core.create_neuron",
      "file": "src/pyfolds/core/__init__.py",
      "line": 74,
      "doc": "Cria neurônio MPJRD com configuração padrão ou personalizada.\n\nArgs:\n    cfg: MPJRDConfig (se None, cria com kwargs)\n    **kwargs: Parâmetros para MPJRDConfig\n\nReturns:\n    MPJRDNeuron configurado\n\nExemplos:\n    # Com config explícita\n    cfg = MPJRDConfig(n_dendrites=8)\n    neuron = create_neuron(cfg)\n    \n    # Com kwargs\n    neuron = create_neuron(n_dendrites=8, target_spike_rate=0.15)",
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.create_neuron_v2",
      "kind": "function",
      "name": "create_neuron_v2",
      "qname": "src.pyfolds.core.create_neuron_v2",
      "file": "src/pyfolds/core/__init__.py",
      "line": 100,
      "doc": "Cria neurônio MPJRD V2 (integração cooperativa).",
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.create_accumulator",
      "kind": "function",
      "name": "create_accumulator",
      "qname": "src.pyfolds.core.create_accumulator",
      "file": "src/pyfolds/core/__init__.py",
      "line": 108,
      "doc": "Cria acumulador de estatísticas a partir da configuração.\n\nArgs:\n    cfg: MPJRDConfig\n    track_extra: Se True, acumula estatísticas extras\n\nReturns:\n    StatisticsAccumulator configurado\n\nExemplo:\n    cfg = MPJRDConfig(n_dendrites=4, n_synapses_per_dendrite=32)\n    acc = create_accumulator(cfg, track_extra=True)",
      "params": [
        "cfg",
        "track_extra"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.demo",
      "kind": "function",
      "name": "demo",
      "qname": "src.pyfolds.core.demo",
      "file": "src/pyfolds/core/__init__.py",
      "line": 131,
      "doc": "Função de demonstração rápida.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.accumulator",
      "kind": "module",
      "name": "accumulator",
      "qname": "src.pyfolds.core.accumulator",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.accumulator.AccumulatedStats",
      "kind": "class",
      "name": "AccumulatedStats",
      "qname": "src.pyfolds.core.accumulator.AccumulatedStats",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 12,
      "doc": "Container para estatísticas acumuladas.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.AccumulatedStats.is_valid",
      "kind": "method",
      "name": "is_valid",
      "qname": "src.pyfolds.core.accumulator.AccumulatedStats.is_valid",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 26,
      "doc": "Verifica se há dados válidos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.AccumulatedStats.__repr__",
      "kind": "method",
      "name": "__repr__",
      "qname": "src.pyfolds.core.accumulator.AccumulatedStats.__repr__",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 30,
      "doc": "Representação legível.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "kind": "class",
      "name": "StatisticsAccumulator",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 38,
      "doc": "Acumulador de estatísticas para aprendizado em batch.\n\n✅ OTIMIZADO:\n    - Uso de buffers in-place\n    - Operações vetorizadas\n    - Histórico com lazy evaluation",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.__init__",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 48,
      "doc": null,
      "params": [
        "self",
        "n_dendrites",
        "n_synapses",
        "eps",
        "track_extra",
        "max_history_len"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.history",
      "kind": "method",
      "name": "history",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.history",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 84,
      "doc": "Histórico (deques circulares, criado sob demanda).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.enable_history",
      "kind": "method",
      "name": "enable_history",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.enable_history",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 90,
      "doc": "Ativa/desativa histórico.",
      "params": [
        "self",
        "enable"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.reset",
      "kind": "method",
      "name": "reset",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.reset",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 101,
      "doc": "Reseta todos os acumuladores.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.accumulate",
      "kind": "method",
      "name": "accumulate",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.accumulate",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 122,
      "doc": "Acumula estatísticas de um batch (versão otimizada).",
      "params": [
        "self",
        "x",
        "gated",
        "spikes",
        "v_dend",
        "u",
        "theta",
        "r_hat",
        "adaptation"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator._update_history",
      "kind": "method",
      "name": "_update_history",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator._update_history",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 205,
      "doc": "Atualiza histórico (lazy).",
      "params": [
        "self",
        "spikes",
        "gated",
        "theta",
        "r_hat"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.get_averages",
      "kind": "method",
      "name": "get_averages",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.get_averages",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 228,
      "doc": "Retorna médias de todas as estatísticas acumuladas.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.plot_history",
      "kind": "method",
      "name": "plot_history",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.plot_history",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 263,
      "doc": "Plota histórico (retorna figura para maior controle).",
      "params": [
        "self",
        "keys",
        "figsize"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.has_data",
      "kind": "method",
      "name": "has_data",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.has_data",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 301,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.batch_count",
      "kind": "method",
      "name": "batch_count",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.batch_count",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 305,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.accumulator.StatisticsAccumulator.extra_repr",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 308,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.accumulator.create_accumulator_from_config",
      "kind": "function",
      "name": "create_accumulator_from_config",
      "qname": "src.pyfolds.core.accumulator.create_accumulator_from_config",
      "file": "src/pyfolds/core/accumulator.py",
      "line": 316,
      "doc": "Cria accumulator a partir de config.",
      "params": [
        "config",
        "track_extra"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.base",
      "kind": "module",
      "name": "base",
      "qname": "src.pyfolds.core.base",
      "file": "src/pyfolds/core/base.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.base.BasePlasticityRule",
      "kind": "class",
      "name": "BasePlasticityRule",
      "qname": "src.pyfolds.core.base.BasePlasticityRule",
      "file": "src/pyfolds/core/base.py",
      "line": 12,
      "doc": "Contrato mínimo para regras de plasticidade locais.",
      "params": [],
      "returns": null,
      "bases": [
        "ABC"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.base.BasePlasticityRule.update",
      "kind": "method",
      "name": "update",
      "qname": "src.pyfolds.core.base.BasePlasticityRule.update",
      "file": "src/pyfolds/core/base.py",
      "line": 16,
      "doc": "Retorna delta de pesos para o passo atual.",
      "params": [
        "self",
        "pre_rate",
        "post_rate",
        "reward"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "abstractmethod"
      ]
    },
    {
      "id": "cls:src.pyfolds.core.base.BaseNeuron",
      "kind": "class",
      "name": "BaseNeuron",
      "qname": "src.pyfolds.core.base.BaseNeuron",
      "file": "src/pyfolds/core/base.py",
      "line": 25,
      "doc": "Contrato comum para neurônios MPJRD e variantes.",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module",
        "ABC"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.base.BaseNeuron.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.base.BaseNeuron.forward",
      "file": "src/pyfolds/core/base.py",
      "line": 29,
      "doc": "Executa o passo forward do neurônio.",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "abstractmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.base.BaseNeuron.apply_plasticity",
      "kind": "method",
      "name": "apply_plasticity",
      "qname": "src.pyfolds.core.base.BaseNeuron.apply_plasticity",
      "file": "src/pyfolds/core/base.py",
      "line": 33,
      "doc": "Aplica atualizações plásticas acumuladas.",
      "params": [
        "self",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "abstractmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.base.BaseNeuron.get_metrics",
      "kind": "method",
      "name": "get_metrics",
      "qname": "src.pyfolds.core.base.BaseNeuron.get_metrics",
      "file": "src/pyfolds/core/base.py",
      "line": 37,
      "doc": "Retorna métricas agregadas do estado interno.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "abstractmethod"
      ]
    },
    {
      "id": "mod:src.pyfolds.core.config",
      "kind": "module",
      "name": "config",
      "qname": "src.pyfolds.core.config",
      "file": "src/pyfolds/core/config.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.config.MPJRDConfig",
      "kind": "class",
      "name": "MPJRDConfig",
      "qname": "src.pyfolds.core.config.MPJRDConfig",
      "file": "src/pyfolds/core/config.py",
      "line": 18,
      "doc": "Configuração completa do neurônio MPJRD com 9 mecanismos avançados.\n\n✅ CONSTANTES CONFIGURÁVEIS ADICIONADAS:\n    - i_decay_sleep: Decaimento de I durante sono\n    - activity_threshold: Threshold para sinapse ativa\n    - homeostasis_eps: Epsilon para homeostase",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.__post_init__",
      "kind": "method",
      "name": "__post_init__",
      "qname": "src.pyfolds.core.config.MPJRDConfig.__post_init__",
      "file": "src/pyfolds/core/config.py",
      "line": 159,
      "doc": "Validações pós-inicialização.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.validate_numerical_safety",
      "kind": "method",
      "name": "validate_numerical_safety",
      "qname": "src.pyfolds.core.config.MPJRDConfig.validate_numerical_safety",
      "file": "src/pyfolds/core/config.py",
      "line": 268,
      "doc": "Valida parâmetros críticos para segurança numérica.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.get_ts",
      "kind": "method",
      "name": "get_ts",
      "qname": "src.pyfolds.core.config.MPJRDConfig.get_ts",
      "file": "src/pyfolds/core/config.py",
      "line": 294,
      "doc": "Retorna constante de tempo em ms para um parâmetro.",
      "params": [
        "self",
        "param_name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.get_decay_rate",
      "kind": "method",
      "name": "get_decay_rate",
      "qname": "src.pyfolds.core.config.MPJRDConfig.get_decay_rate",
      "file": "src/pyfolds/core/config.py",
      "line": 307,
      "doc": "Calcula taxa de decaimento exponencial.",
      "params": [
        "self",
        "tau",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.to_dict",
      "kind": "method",
      "name": "to_dict",
      "qname": "src.pyfolds.core.config.MPJRDConfig.to_dict",
      "file": "src/pyfolds/core/config.py",
      "line": 320,
      "doc": "Converte configuração para dicionário.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.from_dict",
      "kind": "method",
      "name": "from_dict",
      "qname": "src.pyfolds.core.config.MPJRDConfig.from_dict",
      "file": "src/pyfolds/core/config.py",
      "line": 326,
      "doc": "Cria configuração a partir de dicionário.",
      "params": [
        "cls",
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.get_preset",
      "kind": "method",
      "name": "get_preset",
      "qname": "src.pyfolds.core.config.MPJRDConfig.get_preset",
      "file": "src/pyfolds/core/config.py",
      "line": 330,
      "doc": "Retorna configuração pré-definida.",
      "params": [
        "self",
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.config.MPJRDConfig.__repr__",
      "kind": "method",
      "name": "__repr__",
      "qname": "src.pyfolds.core.config.MPJRDConfig.__repr__",
      "file": "src/pyfolds/core/config.py",
      "line": 369,
      "doc": "Representação string da configuração.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.dendrite",
      "kind": "module",
      "name": "dendrite",
      "qname": "src.pyfolds.core.dendrite",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "kind": "class",
      "name": "MPJRDDendrite",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 11,
      "doc": "Dendrito MPJRD com processamento vetorizado e cache OTIMIZADO.\n\n✅ OTIMIZAÇÃO CRÍTICA:\n    - Cache único que coleta estados UMA ÚNICA VEZ\n    - Evita loops múltiplos sobre as sinapses\n    - Propriedades retornam do cache, não recalculam",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.__init__",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 21,
      "doc": null,
      "params": [
        "self",
        "cfg",
        "dendrite_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._ensure_cache_valid",
      "kind": "method",
      "name": "_ensure_cache_valid",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite._ensure_cache_valid",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 37,
      "doc": "✅ OTIMIZADO: Coleta estados UMA ÚNICA VEZ e cacheia tudo.\nPropriedades individuais retornam do cache, não recalculam.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._invalidate_cache",
      "kind": "method",
      "name": "_invalidate_cache",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite._invalidate_cache",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 78,
      "doc": "Invalida o cache (chamar após modificar sinapses).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.N",
      "kind": "method",
      "name": "N",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.N",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 86,
      "doc": "Filamentos [S] - ✅ retorna do cache.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.I",
      "kind": "method",
      "name": "I",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.I",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 92,
      "doc": "Potencial interno [S] - ✅ retorna do cache.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.u",
      "kind": "method",
      "name": "u",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.u",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 98,
      "doc": "Facilitação [S] quando disponível no backend sináptico.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.R",
      "kind": "method",
      "name": "R",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.R",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 104,
      "doc": "Recuperação [S] quando disponível no backend sináptico.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.W",
      "kind": "method",
      "name": "W",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.W",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 110,
      "doc": "Pesos [S] derivados de N - ✅ cacheado.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.forward",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 117,
      "doc": "Forward pass vetorizado.",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._validate_finite",
      "kind": "method",
      "name": "_validate_finite",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite._validate_finite",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 144,
      "doc": "Falha cedo quando entradas contêm NaN/Inf.",
      "params": [
        "name",
        "value"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.update_synapses_rate_based",
      "kind": "method",
      "name": "update_synapses_rate_based",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.update_synapses_rate_based",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 150,
      "doc": "Atualiza sinapses de forma indexada (pré-sináptico por sinapse).",
      "params": [
        "self",
        "pre_rate",
        "post_rate",
        "R",
        "dt",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.consolidate",
      "kind": "method",
      "name": "consolidate",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.consolidate",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 178,
      "doc": "Consolida mudanças sinápticas.",
      "params": [
        "self",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.get_states",
      "kind": "method",
      "name": "get_states",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.get_states",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 186,
      "doc": "Retorna todos os estados.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.load_states",
      "kind": "method",
      "name": "load_states",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.load_states",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 202,
      "doc": "Carrega estados.",
      "params": [
        "self",
        "states"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.dendrite.MPJRDDendrite.extra_repr",
      "file": "src/pyfolds/core/dendrite.py",
      "line": 215,
      "doc": "Representação string.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.dendrite_integration",
      "kind": "module",
      "name": "dendrite_integration",
      "qname": "src.pyfolds.core.dendrite_integration",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.dendrite_integration.DendriticOutput",
      "kind": "class",
      "name": "DendriticOutput",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticOutput",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 20,
      "doc": "Output completo da integração dendrítica.\n\nAttributes:\n    u: Potencial somático [B]\n    v_nmda: Potenciais após gate NMDA [B, D]\n    contribution: Contribuição proporcional por dendrito [B, D]",
      "params": [],
      "returns": null,
      "bases": [
        "NamedTuple"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "kind": "class",
      "name": "DendriticIntegration",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 34,
      "doc": "Integração dendrítica com NMDA local + shunting divisivo.",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticIntegration.__init__",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 37,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration._theta_dend",
      "kind": "method",
      "name": "_theta_dend",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticIntegration._theta_dend",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 42,
      "doc": "Threshold local por dendrito = θ_soma × ratio.",
      "params": [
        "self",
        "theta"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticIntegration.forward",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 48,
      "doc": "Integra potenciais dendríticos com NMDA + shunting.\n\nArgs:\n    v_dend: Potenciais lineares [B, D]\n    theta: Threshold somático atual",
      "params": [
        "self",
        "v_dend",
        "theta"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.dendrite_integration.DendriticIntegration.extra_repr",
      "file": "src/pyfolds/core/dendrite_integration.py",
      "line": 70,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.factory",
      "kind": "module",
      "name": "factory",
      "qname": "src.pyfolds.core.factory",
      "file": "src/pyfolds/core/factory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.factory.NeuronType",
      "kind": "class",
      "name": "NeuronType",
      "qname": "src.pyfolds.core.factory.NeuronType",
      "file": "src/pyfolds/core/factory.py",
      "line": 12,
      "doc": "Tipos de neurônio suportados pelo factory.",
      "params": [],
      "returns": null,
      "bases": [
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.factory.NeuronFactory",
      "kind": "class",
      "name": "NeuronFactory",
      "qname": "src.pyfolds.core.factory.NeuronFactory",
      "file": "src/pyfolds/core/factory.py",
      "line": 20,
      "doc": "Factory registry-based para criação desacoplada de neurônios.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.factory.NeuronFactory.register",
      "kind": "method",
      "name": "register",
      "qname": "src.pyfolds.core.factory.NeuronFactory.register",
      "file": "src/pyfolds/core/factory.py",
      "line": 27,
      "doc": "Registra uma classe de neurônio no factory.\n\nArgs:\n    neuron_type: Tipo do neurônio (STANDARD, WAVE, V2)\n    neuron_class: Classe a ser registrada",
      "params": [
        "cls",
        "neuron_type",
        "neuron_class"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.factory.NeuronFactory.create",
      "kind": "method",
      "name": "create",
      "qname": "src.pyfolds.core.factory.NeuronFactory.create",
      "file": "src/pyfolds/core/factory.py",
      "line": 39,
      "doc": "Cria uma instância de neurônio do tipo especificado.\n\nArgs:\n    neuron_type: Tipo do neurônio a ser criado\n    cfg: Configuração do neurônio\n    **kwargs: Argumentos adicionais para o construtor\n    \nReturns:\n    Instância do neurônio\n    \nRaises:\n    ValueError: Se o tipo não estiver registrado\n    RuntimeError: Se os imports falharem",
      "params": [
        "cls",
        "neuron_type",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.factory.NeuronFactory.is_registered",
      "kind": "method",
      "name": "is_registered",
      "qname": "src.pyfolds.core.factory.NeuronFactory.is_registered",
      "file": "src/pyfolds/core/factory.py",
      "line": 73,
      "doc": "Verifica se um tipo está registrado.",
      "params": [
        "cls",
        "neuron_type"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "fn:src.pyfolds.core.factory.register_neuron",
      "kind": "function",
      "name": "register_neuron",
      "qname": "src.pyfolds.core.factory.register_neuron",
      "file": "src/pyfolds/core/factory.py",
      "line": 78,
      "doc": "Decorator para registrar classes de neurônio automaticamente.",
      "params": [
        "neuron_type"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.factory.register_default_neurons",
      "kind": "function",
      "name": "register_default_neurons",
      "qname": "src.pyfolds.core.factory.register_default_neurons",
      "file": "src/pyfolds/core/factory.py",
      "line": 88,
      "doc": "Registra tipos padrão de forma lazy para evitar import circular.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.factory.infer_neuron_type",
      "kind": "function",
      "name": "infer_neuron_type",
      "qname": "src.pyfolds.core.factory.infer_neuron_type",
      "file": "src/pyfolds/core/factory.py",
      "line": 116,
      "doc": "Infere tipo de neurônio com base na configuração.",
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.core.factory.get_available_types",
      "kind": "function",
      "name": "get_available_types",
      "qname": "src.pyfolds.core.factory.get_available_types",
      "file": "src/pyfolds/core/factory.py",
      "line": 129,
      "doc": "Retorna lista de tipos de neurônio disponíveis.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.homeostasis",
      "kind": "module",
      "name": "homeostasis",
      "qname": "src.pyfolds.core.homeostasis",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "kind": "class",
      "name": "HomeostasisController",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 12,
      "doc": "Controla a homeostase do neurônio MPJRD.\n\n✅ CORRIGIDO:\n    - Removido +self.eps incorreto da média móvel\n    - is_stable unificado como método com tolerance opcional\n    - Adicionado callback para eventos de estabilidade",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.__init__",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 22,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.update",
      "kind": "method",
      "name": "update",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.update",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 52,
      "doc": "Atualiza parâmetros homeostáticos (PID-like).\n\nArgs:\n    current_rate: Taxa atual no intervalo [0, 1].\n        Aceita float ou tensor escalar.\n    clamp_theta: Se deve limitar `theta` entre [theta_min, theta_max].\n\nReturns:\n    torch.Tensor: theta atualizado (tensor escalar shape [1]).",
      "params": [
        "self",
        "current_rate",
        "clamp_theta"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController._check_stability_change",
      "kind": "method",
      "name": "_check_stability_change",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController._check_stability_change",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 128,
      "doc": "Verifica se houve mudança no estado de estabilidade.",
      "params": [
        "self",
        "tolerance"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.on_stable",
      "kind": "method",
      "name": "on_stable",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.on_stable",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 148,
      "doc": "Registra callback para quando a homeostase se tornar estável.",
      "params": [
        "self",
        "callback"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.on_unstable",
      "kind": "method",
      "name": "on_unstable",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.on_unstable",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 158,
      "doc": "Registra callback para quando a homeostase se tornar instável.",
      "params": [
        "self",
        "callback"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.reset",
      "kind": "method",
      "name": "reset",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.reset",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 168,
      "doc": "Reseta buffers.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.homeostasis_error",
      "kind": "method",
      "name": "homeostasis_error",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.homeostasis_error",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 178,
      "doc": "Erro homeostático atual (r_hat - target).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.is_stable",
      "kind": "method",
      "name": "is_stable",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.is_stable",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 182,
      "doc": "Verifica se homeostase está estável com tolerância configurável.",
      "params": [
        "self",
        "tolerance"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.stability_ratio",
      "kind": "method",
      "name": "stability_ratio",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.stability_ratio",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 186,
      "doc": "Calcula proporção de passos estáveis na janela recente.\n\nArgs:\n    window: Número de passos para considerar\n    \nReturns:\n    Float entre 0 e 1 indicando proporção de estabilidade",
      "params": [
        "self",
        "window"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.homeostasis.HomeostasisController.extra_repr",
      "file": "src/pyfolds/core/homeostasis.py",
      "line": 202,
      "doc": "Representação string detalhada do módulo.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.neuromodulation",
      "kind": "module",
      "name": "neuromodulation",
      "qname": "src.pyfolds.core.neuromodulation",
      "file": "src/pyfolds/core/neuromodulation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "kind": "class",
      "name": "Neuromodulator",
      "qname": "src.pyfolds.core.neuromodulation.Neuromodulator",
      "file": "src/pyfolds/core/neuromodulation.py",
      "line": 20,
      "doc": "Neuromodulador para o neurônio MPJRD.\n\nEste módulo calcula o sinal neuromodulador R que influencia a plasticidade\nsináptica. Diferentes estratégias podem ser usadas, configuradas via\n`cfg.neuromod_mode`.\n\nModos disponíveis:\n    - 'external': R = reward (fornecido externamente)\n    - 'capacity': R baseado em capacidade livre (1 - saturação)\n    - 'surprise': R = bias + k * |rate - r_hat|\n\nArgs:\n    cfg: Configuração do neurônio (MPJRDConfig)\n\nExample:\n    >>> cfg = MPJRDConfig(neuromod_mode='surprise', sup_k=2.0, sup_bias=0.0)\n    >>> neuromod = Neuromodulator(cfg)\n    >>> R = neuromod(rate=0.25, r_hat=0.10)\n    >>> print(R.item())  # 0.30 (surpresa de 0.15 * 2.0)",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.neuromodulation.Neuromodulator.__init__",
      "file": "src/pyfolds/core/neuromodulation.py",
      "line": 43,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.neuromodulation.Neuromodulator.forward",
      "file": "src/pyfolds/core/neuromodulation.py",
      "line": 47,
      "doc": "Calcula o sinal neuromodulador R.\n\nArgs:\n    rate: Taxa de disparo atual [0, 1]\n    r_hat: Média móvel da taxa [0, 1]\n    saturation_ratio: Proporção de sinapses saturadas [0,1] (para modo 'capacity')\n    reward: Recompensa externa (obrigatória no modo 'external')\n    device: Device para o tensor resultante (se None, usa CPU)\n\nReturns:\n    Tensor escalar R no device especificado, clampado em [-1, 1]\n\nRaises:\n    ValueError: Se reward for None no modo 'external'\n    ValueError: Se saturation_ratio for None no modo 'capacity'",
      "params": [
        "self",
        "rate",
        "r_hat",
        "saturation_ratio",
        "reward",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.neuromodulation.Neuromodulator.extra_repr",
      "file": "src/pyfolds/core/neuromodulation.py",
      "line": 156,
      "doc": "Representação string do módulo.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.neuron",
      "kind": "module",
      "name": "neuron",
      "qname": "src.pyfolds.core.neuron",
      "file": "src/pyfolds/core/neuron.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "kind": "class",
      "name": "MPJRDNeuron",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron",
      "file": "src/pyfolds/core/neuron.py",
      "line": 43,
      "doc": "Neurônio MPJRD completo.\n\n✅ OTIMIZADO:\n    - Forward pass eficiente\n    - Suporte a learning_rate_multiplier\n    - Usa activity_threshold da config\n    - ✅ LOGGING integrado\n    - ✅ Validação de devices\n    - ✅ Thread-safe telemetry",
      "params": [],
      "returns": null,
      "bases": [
        "BaseNeuron"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.__init__",
      "file": "src/pyfolds/core/neuron.py",
      "line": 56,
      "doc": null,
      "params": [
        "self",
        "cfg",
        "enable_telemetry",
        "telemetry_profile",
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._validate_internal_devices",
      "kind": "method",
      "name": "_validate_internal_devices",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._validate_internal_devices",
      "file": "src/pyfolds/core/neuron.py",
      "line": 131,
      "doc": "Valida consistência de devices internos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_stable",
      "kind": "method",
      "name": "_on_homeostasis_stable",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_stable",
      "file": "src/pyfolds/core/neuron.py",
      "line": 159,
      "doc": "Callback quando homeostase se torna estável.",
      "params": [
        "self",
        "controller"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_unstable",
      "kind": "method",
      "name": "_on_homeostasis_unstable",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_unstable",
      "file": "src/pyfolds/core/neuron.py",
      "line": 165,
      "doc": "Callback quando homeostase se torna instável.",
      "params": [
        "self",
        "controller"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.N",
      "kind": "method",
      "name": "N",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.N",
      "file": "src/pyfolds/core/neuron.py",
      "line": 175,
      "doc": "Filamentos [dendrites, synapses].",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.I",
      "kind": "method",
      "name": "I",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.I",
      "file": "src/pyfolds/core/neuron.py",
      "line": 180,
      "doc": "Potenciais internos [dendrites, synapses].",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.W",
      "kind": "method",
      "name": "W",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.W",
      "file": "src/pyfolds/core/neuron.py",
      "line": 185,
      "doc": "Pesos [dendrites, synapses].",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.protection",
      "kind": "method",
      "name": "protection",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.protection",
      "file": "src/pyfolds/core/neuron.py",
      "line": 190,
      "doc": "Flags de proteção [dendrites, synapses].",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.theta",
      "kind": "method",
      "name": "theta",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.theta",
      "file": "src/pyfolds/core/neuron.py",
      "line": 199,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.r_hat",
      "kind": "method",
      "name": "r_hat",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.r_hat",
      "file": "src/pyfolds/core/neuron.py",
      "line": 203,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.set_mode",
      "kind": "method",
      "name": "set_mode",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.set_mode",
      "file": "src/pyfolds/core/neuron.py",
      "line": 208,
      "doc": "Define modo de aprendizado.",
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._compute_R_endogenous",
      "kind": "method",
      "name": "_compute_R_endogenous",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._compute_R_endogenous",
      "file": "src/pyfolds/core/neuron.py",
      "line": 223,
      "doc": "Computa sinal neuromodulador interno.",
      "params": [
        "self",
        "current_rate",
        "saturation_ratio"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._validate_input_device",
      "kind": "method",
      "name": "_validate_input_device",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._validate_input_device",
      "file": "src/pyfolds/core/neuron.py",
      "line": 245,
      "doc": "Valida se input está no device correto.",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._apply_online_plasticity",
      "kind": "method",
      "name": "_apply_online_plasticity",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron._apply_online_plasticity",
      "file": "src/pyfolds/core/neuron.py",
      "line": 256,
      "doc": "Aplica regra local imediatamente (modo ONLINE sem defer).",
      "params": [
        "self",
        "x",
        "post_rate",
        "R_tensor",
        "dt",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.forward",
      "file": "src/pyfolds/core/neuron.py",
      "line": 287,
      "doc": "Forward pass do neurônio.\n\nArgs:\n    x: Tensor de entrada [batch, dendrites, synapses]\n    reward: Sinal de recompensa externo\n    mode: Modo de aprendizado (sobrescreve o atual)\n    collect_stats: Se deve coletar estatísticas\n    dt: Passo de tempo (ms)\n\nReturns:\n    Dict com spikes, potenciais e estatísticas",
      "params": [
        "self",
        "x",
        "reward",
        "mode",
        "collect_stats",
        "dt",
        "defer_homeostasis"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "validate_input(expected_ndim=3, expected_shape_fn=lambda self: (self.cfg.n_dendrites, self.cfg.n_synapses_per_dendrite))"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.step",
      "kind": "method",
      "name": "step",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.step",
      "file": "src/pyfolds/core/neuron.py",
      "line": 493,
      "doc": "API explícita de passo temporal (compatível com README).",
      "params": [
        "self",
        "x",
        "reward",
        "dt",
        "mode",
        "collect_stats"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.apply_plasticity",
      "kind": "method",
      "name": "apply_plasticity",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.apply_plasticity",
      "file": "src/pyfolds/core/neuron.py",
      "line": 513,
      "doc": "Aplica plasticidade acumulada (deferred updates).\n\n✅ CORRIGIDO: Passa mode para as sinapses",
      "params": [
        "self",
        "dt",
        "reward"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.sleep",
      "kind": "method",
      "name": "sleep",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.sleep",
      "file": "src/pyfolds/core/neuron.py",
      "line": 599,
      "doc": "Ciclo de sono: consolida sinapses.",
      "params": [
        "self",
        "duration"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.to",
      "kind": "method",
      "name": "to",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.to",
      "file": "src/pyfolds/core/neuron.py",
      "line": 624,
      "doc": "Move neurônio para device e valida consistência.",
      "params": [
        "self",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.get_metrics",
      "kind": "method",
      "name": "get_metrics",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.get_metrics",
      "file": "src/pyfolds/core/neuron.py",
      "line": 633,
      "doc": "Retorna métricas consolidadas do neurônio.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.neuron.MPJRDNeuron.extra_repr",
      "file": "src/pyfolds/core/neuron.py",
      "line": 676,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.neuron_v2",
      "kind": "module",
      "name": "neuron_v2",
      "qname": "src.pyfolds.core.neuron_v2",
      "file": "src/pyfolds/core/neuron_v2.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "kind": "class",
      "name": "MPJRDNeuronV2",
      "qname": "src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "file": "src/pyfolds/core/neuron_v2.py",
      "line": 11,
      "doc": "Versão experimental com soma cooperativa não-linear entre dendritos.\n\n✅ CORRIGIDO:\n    - Herda todas as melhorias do MPJRDNeuron (validação de devices, logging, etc.)\n    - Reutiliza validação de input device da classe base\n    - Mantém consistência com a versão base\n    - Preserva semântica do acumulador",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDNeuron"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.core.neuron_v2.MPJRDNeuronV2.forward",
      "file": "src/pyfolds/core/neuron_v2.py",
      "line": 22,
      "doc": "Forward pass com integração cooperativa.\n\nArgs:\n    x: Tensor de entrada [batch, dendrites, synapses]\n    reward: Sinal de recompensa externo\n    mode: Modo de aprendizado (sobrescreve o atual)\n    collect_stats: Se deve coletar estatísticas\n    dt: Passo de tempo (ms)\n\nReturns:\n    Dict com:\n        - Tensores: spikes, u/somatic, v_dend, gated, theta, r_hat, R,\n          N_mean/W_mean/I_mean\n        - Floats: spike_rate, saturation_ratio\n        - Strings: mode, device",
      "params": [
        "self",
        "x",
        "reward",
        "mode",
        "collect_stats",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2._telemetry_forward_event",
      "kind": "method",
      "name": "_telemetry_forward_event",
      "qname": "src.pyfolds.core.neuron_v2.MPJRDNeuronV2._telemetry_forward_event",
      "file": "src/pyfolds/core/neuron_v2.py",
      "line": 186,
      "doc": "Gera evento de telemetria para forward (compatível com versão base).",
      "params": [
        "self",
        "sid",
        "spike_rate",
        "saturation_ratio",
        "R_tensor"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.neuron_v2.MPJRDNeuronV2.extra_repr",
      "file": "src/pyfolds/core/neuron_v2.py",
      "line": 209,
      "doc": "Representação string.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.core.synapse",
      "kind": "module",
      "name": "synapse",
      "qname": "src.pyfolds.core.synapse",
      "file": "src/pyfolds/core/synapse.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "kind": "class",
      "name": "MPJRDSynapse",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse",
      "file": "src/pyfolds/core/synapse.py",
      "line": 32,
      "doc": "Sinapse MPJRD com plasticidade three-factor e two-factor consolidation.\n\n✅ OTIMIZADO: trabalha com tensores diretamente\n✅ CONFIGURÁVEL: usa constantes da config\n✅ MODOS: suporta multiplicador de learning rate por modo",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.__init__",
      "file": "src/pyfolds/core/synapse.py",
      "line": 41,
      "doc": null,
      "params": [
        "self",
        "cfg",
        "init_n"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.W",
      "kind": "method",
      "name": "W",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.W",
      "file": "src/pyfolds/core/synapse.py",
      "line": 67,
      "doc": "Peso sináptico derivado do número de filamentos (Bartol Log Law).\n\nImplementa a relação:\n    W = log2(1 + N) / w_scale\n\nReturns:\n    Tensor escalar com o peso derivado em ponto flutuante.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse._update_with_soft_saturation",
      "kind": "method",
      "name": "_update_with_soft_saturation",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse._update_with_soft_saturation",
      "file": "src/pyfolds/core/synapse.py",
      "line": 85,
      "doc": "Atualiza I com amortecimento suave perto dos limites.",
      "params": [
        "self",
        "delta_mean"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.update",
      "kind": "method",
      "name": "update",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.update",
      "file": "src/pyfolds/core/synapse.py",
      "line": 107,
      "doc": "Atualização baseada em taxas (Three-factor learning rule).\n\n✅ OTIMIZADO: trabalha com tensores, evita .item() no caminho crítico\n✅ MODOS: aplica multiplicador de learning rate baseado no modo\n✅ FILTRO: aplica activity_threshold para sinapses inativas\n\nArgs:\n    pre_rate: Taxa pré-sináptica [B] ou [1]\n    post_rate: Taxa pós-sináptica [1]\n    R: Sinal neuromodulador [1]\n    dt: Passo de tempo (ms)\n    mode: Modo de aprendizado (para multiplicador de LR)",
      "params": [
        "self",
        "pre_rate",
        "post_rate",
        "R",
        "dt",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.consolidate",
      "kind": "method",
      "name": "consolidate",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.consolidate",
      "file": "src/pyfolds/core/synapse.py",
      "line": 225,
      "doc": "Consolida o fator volátil em estável (two-factor consolidation).\n\n✅ OTIMIZADO: usa i_decay_sleep da config",
      "params": [
        "self",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.get_state",
      "kind": "method",
      "name": "get_state",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.get_state",
      "file": "src/pyfolds/core/synapse.py",
      "line": 253,
      "doc": "Retorna estado completo da sinapse (sem .item() para tensores).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.load_state",
      "kind": "method",
      "name": "load_state",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.load_state",
      "file": "src/pyfolds/core/synapse.py",
      "line": 264,
      "doc": "Carrega estado na sinapse.",
      "params": [
        "self",
        "state"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.core.synapse.MPJRDSynapse.extra_repr",
      "file": "src/pyfolds/core/synapse.py",
      "line": 277,
      "doc": "Representação string da sinapse.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.factory",
      "kind": "module",
      "name": "factory",
      "qname": "src.pyfolds.factory",
      "file": "src/pyfolds/factory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.factory.NeuronType",
      "kind": "class",
      "name": "NeuronType",
      "qname": "src.pyfolds.factory.NeuronType",
      "file": "src/pyfolds/factory.py",
      "line": 14,
      "doc": "Tipos nativos de neurônios suportados pela fábrica.",
      "params": [],
      "returns": null,
      "bases": [
        "str",
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.factory.NeuronFactory",
      "kind": "class",
      "name": "NeuronFactory",
      "qname": "src.pyfolds.factory.NeuronFactory",
      "file": "src/pyfolds/factory.py",
      "line": 22,
      "doc": "Factory pattern para criação de neurônios PyFolds.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.factory.NeuronFactory.register",
      "kind": "method",
      "name": "register",
      "qname": "src.pyfolds.factory.NeuronFactory.register",
      "file": "src/pyfolds/factory.py",
      "line": 28,
      "doc": "Registra um tipo customizado de neurônio.",
      "params": [
        "cls",
        "name",
        "neuron_class"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.factory.NeuronFactory.create",
      "kind": "method",
      "name": "create",
      "qname": "src.pyfolds.factory.NeuronFactory.create",
      "file": "src/pyfolds/factory.py",
      "line": 33,
      "doc": "Cria uma instância de neurônio por tipo.",
      "params": [
        "cls",
        "neuron_type",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mod:src.pyfolds.layers",
      "kind": "module",
      "name": "layers",
      "qname": "src.pyfolds.layers",
      "file": "src/pyfolds/layers/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.layers.layer",
      "kind": "module",
      "name": "layer",
      "qname": "src.pyfolds.layers.layer",
      "file": "src/pyfolds/layers/layer.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "kind": "class",
      "name": "MPJRDLayer",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer",
      "file": "src/pyfolds/layers/layer.py",
      "line": 11,
      "doc": "Camada de neurônios MPJRD para construção de redes neurais.\n\nCaracterísticas:\n    - Múltiplos neurônios em paralelo\n    - Processamento em batch eficiente\n    - Suporte a telemetria (repassada para neurônios)\n    - Métricas agregadas por camada\n    - Modos de aprendizado (online/batch/inference)\n\nArgs:\n    n_neurons: Número de neurônios na camada\n    cfg: Configuração dos neurônios (compartilhada)\n    name: Nome opcional para identificação\n    enable_telemetry: Se True, ativa telemetria nos neurônios\n    telemetry_profile: Perfil de telemetria ('off', 'light', 'heavy')\n    device: Device para os tensores (opcional)\n\nExample:\n    >>> cfg = MPJRDConfig(n_dendrites=4, n_synapses_per_dendrite=32)\n    >>> layer = MPJRDLayer(10, cfg, name=\"hidden1\", enable_telemetry=True)\n    >>> x = torch.randn(128, 10, 4, 32)  # [batch, neurons, dendrites, synapses]\n    >>> out = layer(x)\n    >>> print(out['spikes'].shape)  # [128, 10]",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.__init__",
      "file": "src/pyfolds/layers/layer.py",
      "line": 38,
      "doc": null,
      "params": [
        "self",
        "n_neurons",
        "cfg",
        "name",
        "neuron_cls",
        "enable_telemetry",
        "telemetry_profile",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.n_dendrites",
      "kind": "method",
      "name": "n_dendrites",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.n_dendrites",
      "file": "src/pyfolds/layers/layer.py",
      "line": 84,
      "doc": "Número de dendritos por neurônio (da config).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.n_synapses",
      "kind": "method",
      "name": "n_synapses",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.n_synapses",
      "file": "src/pyfolds/layers/layer.py",
      "line": 89,
      "doc": "Número de sinapses por dendrito (da config).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.theta_mean",
      "kind": "method",
      "name": "theta_mean",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.theta_mean",
      "file": "src/pyfolds/layers/layer.py",
      "line": 94,
      "doc": "Média dos thresholds de todos neurônios.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.r_hat_mean",
      "kind": "method",
      "name": "r_hat_mean",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.r_hat_mean",
      "file": "src/pyfolds/layers/layer.py",
      "line": 103,
      "doc": "Média das taxas de todos neurônios.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.forward",
      "file": "src/pyfolds/layers/layer.py",
      "line": 111,
      "doc": "Forward pass da camada.\n\nArgs:\n    x: Tensor de entrada. Formatos aceitos:\n        - [batch, n_neurons, n_dendrites, n_synapses] (completo)\n        - [batch, n_neurons, n_dendrites] (expande sinapses)\n        - [batch, n_dendrites, n_synapses] (mesmo para todos neurônios)\n    reward: Sinal de recompensa (opcional)\n    mode: Modo de aprendizado (opcional)\n\nReturns:\n    Dict com:\n        - spikes: [batch, n_neurons] spikes de cada neurônio\n        - spike_rates: [n_neurons] taxas médias por neurônio\n        - theta_values: [n_neurons] thresholds atuais\n        - r_hat_values: [n_neurons] médias móveis",
      "params": [
        "self",
        "x",
        "reward",
        "mode",
        "dt",
        "neuron_kwargs"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer._prepare_input",
      "kind": "method",
      "name": "_prepare_input",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer._prepare_input",
      "file": "src/pyfolds/layers/layer.py",
      "line": 244,
      "doc": "Prepara entrada para o formato [batch, neurons, dendrites, synapses].\n\nArgs:\n    x: Tensor em vários formatos possíveis\n\nReturns:\n    Tensor no formato [batch, neurons, dendrites, synapses]\n\nRaises:\n    ValueError: Se formato for inválido",
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.set_mode",
      "kind": "method",
      "name": "set_mode",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.set_mode",
      "file": "src/pyfolds/layers/layer.py",
      "line": 308,
      "doc": "Define modo de aprendizado para todos os neurônios.",
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.apply_batch_update",
      "kind": "method",
      "name": "apply_batch_update",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.apply_batch_update",
      "file": "src/pyfolds/layers/layer.py",
      "line": 315,
      "doc": "Aplica plasticidade acumulada em todos os neurônios.\nÚtil no modo BATCH após processar múltiplos exemplos.",
      "params": [
        "self",
        "reward"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.sleep",
      "kind": "method",
      "name": "sleep",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.sleep",
      "file": "src/pyfolds/layers/layer.py",
      "line": 323,
      "doc": "Ciclo de sono para consolidação two-factor em todos neurônios.\n\nArgs:\n    duration: Duração do sono em unidades de tempo",
      "params": [
        "self",
        "duration"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.get_all_metrics",
      "kind": "method",
      "name": "get_all_metrics",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.get_all_metrics",
      "file": "src/pyfolds/layers/layer.py",
      "line": 333,
      "doc": "Retorna métricas de todos os neurônios na camada.\n\nReturns:\n    Lista de dicionários com métricas de cada neurônio",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.get_layer_metrics",
      "kind": "method",
      "name": "get_layer_metrics",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.get_layer_metrics",
      "file": "src/pyfolds/layers/layer.py",
      "line": 342,
      "doc": "Retorna métricas agregadas da camada.\n\nReturns:\n    Dicionário com estatísticas da camada",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.layer.MPJRDLayer.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.layers.layer.MPJRDLayer.extra_repr",
      "file": "src/pyfolds/layers/layer.py",
      "line": 374,
      "doc": "Representação string da camada.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.layers.wave_layer",
      "kind": "module",
      "name": "wave_layer",
      "qname": "src.pyfolds.layers.wave_layer",
      "file": "src/pyfolds/layers/wave_layer.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.layers.wave_layer.MPJRDWaveLayer",
      "kind": "class",
      "name": "MPJRDWaveLayer",
      "qname": "src.pyfolds.layers.wave_layer.MPJRDWaveLayer",
      "file": "src/pyfolds/layers/wave_layer.py",
      "line": 10,
      "doc": "Wrapper de conveniência para construir camadas wave.",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDLayer"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.layers.wave_layer.MPJRDWaveLayer.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.layers.wave_layer.MPJRDWaveLayer.__init__",
      "file": "src/pyfolds/layers/wave_layer.py",
      "line": 13,
      "doc": null,
      "params": [
        "self",
        "n_neurons",
        "cfg",
        "name",
        "enable_telemetry",
        "telemetry_profile",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.monitoring",
      "kind": "module",
      "name": "monitoring",
      "qname": "src.pyfolds.monitoring",
      "file": "src/pyfolds/monitoring/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.monitoring.health",
      "kind": "module",
      "name": "health",
      "qname": "src.pyfolds.monitoring.health",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.monitoring.health.HealthStatus",
      "kind": "class",
      "name": "HealthStatus",
      "qname": "src.pyfolds.monitoring.health.HealthStatus",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 11,
      "doc": "Estados de saúde operacional calculados pelo monitoramento.",
      "params": [],
      "returns": null,
      "bases": [
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.monitoring.health.NeuronHealthCheck",
      "kind": "class",
      "name": "NeuronHealthCheck",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthCheck",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 19,
      "doc": "Monitora métricas de saúde e gera alertas de operação.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.monitoring.health.NeuronHealthCheck.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthCheck.__init__",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 22,
      "doc": null,
      "params": [
        "self",
        "neuron",
        "thresholds"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.monitoring.health.NeuronHealthCheck.check",
      "kind": "method",
      "name": "check",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthCheck.check",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 30,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "kind": "class",
      "name": "NeuronHealthMonitor",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 53,
      "doc": "Monitor de saúde contínuo para execução longa.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthMonitor.__init__",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 56,
      "doc": null,
      "params": [
        "self",
        "neuron",
        "check_every_n_steps"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.check_health",
      "kind": "method",
      "name": "check_health",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthMonitor.check_health",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 62,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.get_health_score",
      "kind": "method",
      "name": "get_health_score",
      "qname": "src.pyfolds.monitoring.health.NeuronHealthMonitor.get_health_score",
      "file": "src/pyfolds/monitoring/health.py",
      "line": 95,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.network",
      "kind": "module",
      "name": "network",
      "qname": "src.pyfolds.network",
      "file": "src/pyfolds/network/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.network.builder",
      "kind": "module",
      "name": "builder",
      "qname": "src.pyfolds.network.builder",
      "file": "src/pyfolds/network/builder.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.network.builder.NetworkBuilder",
      "kind": "class",
      "name": "NetworkBuilder",
      "qname": "src.pyfolds.network.builder.NetworkBuilder",
      "file": "src/pyfolds/network/builder.py",
      "line": 12,
      "doc": "Builder pattern para redes feedforward MPJRD.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.builder.NetworkBuilder.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.network.builder.NetworkBuilder.__init__",
      "file": "src/pyfolds/network/builder.py",
      "line": 15,
      "doc": null,
      "params": [
        "self",
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.builder.NetworkBuilder.add_layer",
      "kind": "method",
      "name": "add_layer",
      "qname": "src.pyfolds.network.builder.NetworkBuilder.add_layer",
      "file": "src/pyfolds/network/builder.py",
      "line": 19,
      "doc": "Adiciona camada e conecta automaticamente à camada anterior.",
      "params": [
        "self",
        "name",
        "n_neurons",
        "cfg",
        "connect_from_previous"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.builder.NetworkBuilder.build",
      "kind": "method",
      "name": "build",
      "qname": "src.pyfolds.network.builder.NetworkBuilder.build",
      "file": "src/pyfolds/network/builder.py",
      "line": 39,
      "doc": "Finaliza a construção validando a topologia.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.network.network",
      "kind": "module",
      "name": "network",
      "qname": "src.pyfolds.network.network",
      "file": "src/pyfolds/network/network.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "kind": "class",
      "name": "MPJRDNetwork",
      "qname": "src.pyfolds.network.network.MPJRDNetwork",
      "file": "src/pyfolds/network/network.py",
      "line": 11,
      "doc": "Rede neural completa com camadas MPJRD.\n\nCaracterísticas:\n    - Múltiplas camadas de neurônios MPJRD\n    - Conexões configuráveis entre camadas\n    - Ordenação topológica automática (algoritmo de Kahn)\n    - Detecção de ciclos\n    - Preparação inteligente de entrada para camadas\n    - Modos de aprendizado por camada\n    - Métricas agregadas da rede\n\nArgs:\n    name: Nome da rede (opcional)\n\nExample:\n    >>> from pyfolds import MPJRDConfig, MPJRDLayer\n    >>> cfg = MPJRDConfig(n_dendrites=4)\n    >>> \n    >>> net = MPJRDNetwork(\"minha_rede\")\n    >>> net.add_layer(\"input\", MPJRDLayer(10, cfg))\n    >>> net.add_layer(\"hidden\", MPJRDLayer(20, cfg))\n    >>> net.add_layer(\"output\", MPJRDLayer(5, cfg))\n    >>> net.connect(\"input\", \"hidden\")\n    >>> net.connect(\"hidden\", \"output\")\n    >>> net.build()\n    >>> \n    >>> x = torch.randn(32, 10, 4, 32)  # [batch, neurons, dendrites, synapses]\n    >>> out = net(x)\n    >>> print(out['output'].shape)  # [32, 5]",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.__init__",
      "file": "src/pyfolds/network/network.py",
      "line": 44,
      "doc": null,
      "params": [
        "self",
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.add_layer",
      "kind": "method",
      "name": "add_layer",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.add_layer",
      "file": "src/pyfolds/network/network.py",
      "line": 55,
      "doc": "Adiciona uma camada à rede.\n\nArgs:\n    name: Nome único da camada\n    layer: Camada MPJRDLayer\n\nReturns:\n    self (para encadeamento)",
      "params": [
        "self",
        "name",
        "layer"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.connect",
      "kind": "method",
      "name": "connect",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.connect",
      "file": "src/pyfolds/network/network.py",
      "line": 77,
      "doc": "Conecta duas camadas com validação de ciclos.\n\nArgs:\n    from_layer: Nome da camada de origem\n    to_layer: Nome da camada de destino\n    weight_init: Inicialização dos pesos (padrão: 1.0)\n\nReturns:\n    self (para encadeamento)",
      "params": [
        "self",
        "from_layer",
        "to_layer",
        "weight_init"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork._has_cycle",
      "kind": "method",
      "name": "_has_cycle",
      "qname": "src.pyfolds.network.network.MPJRDNetwork._has_cycle",
      "file": "src/pyfolds/network/network.py",
      "line": 122,
      "doc": "Detecta ciclos no grafo de conexões usando DFS.\n\nArgs:\n    connections: Lista de tuplas (origem, destino)\n    \nReturns:\n    True se houver ciclo, False caso contrário",
      "params": [
        "self",
        "connections"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork._topological_sort",
      "kind": "method",
      "name": "_topological_sort",
      "qname": "src.pyfolds.network.network.MPJRDNetwork._topological_sort",
      "file": "src/pyfolds/network/network.py",
      "line": 160,
      "doc": "Ordenação topológica usando algoritmo de Kahn.\n\nReturns:\n    Lista de nomes de camadas em ordem topológica\n    \nRaises:\n    ValueError: Se houver ciclo no grafo",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork._prepare_input_for_layer",
      "kind": "method",
      "name": "_prepare_input_for_layer",
      "qname": "src.pyfolds.network.network.MPJRDNetwork._prepare_input_for_layer",
      "file": "src/pyfolds/network/network.py",
      "line": 200,
      "doc": "Prepara spikes de origem para entrada da camada destino.\n\n✅ OTIMIZADO: Distribui ativação entre dendritos de forma realista\n\nArgs:\n    spikes: Spikes da camada origem [B, from]\n    to_layer: Nome da camada destino\n    weights: Pesos da conexão [from, to]\n\nReturns:\n    Tensor [B, to, D, S] pronto para a camada destino",
      "params": [
        "self",
        "spikes",
        "to_layer",
        "weights"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.build",
      "kind": "method",
      "name": "build",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.build",
      "file": "src/pyfolds/network/network.py",
      "line": 251,
      "doc": "Constrói a rede (valida conexões, ordena topologicamente).\n\nReturns:\n    self (para encadeamento)",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.forward",
      "file": "src/pyfolds/network/network.py",
      "line": 277,
      "doc": "Forward pass da rede com ordenação topológica real.\n\nArgs:\n    x: Tensor de entrada (formato depende da primeira camada)\n    reward: Sinal de recompensa (opcional)\n    mode: Modo de aprendizado\n\nReturns:\n    Dict com:\n        - output: spikes da última camada [B, output_neurons]\n        - layers: saídas de todas as camadas\n        - final_layer: nome da última camada\n        - layer_order: ordem de processamento",
      "params": [
        "self",
        "x",
        "reward",
        "mode",
        "layer_kwargs"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.set_mode",
      "kind": "method",
      "name": "set_mode",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.set_mode",
      "file": "src/pyfolds/network/network.py",
      "line": 373,
      "doc": "Define modo de aprendizado para todas as camadas.",
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.apply_batch_update",
      "kind": "method",
      "name": "apply_batch_update",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.apply_batch_update",
      "file": "src/pyfolds/network/network.py",
      "line": 380,
      "doc": "Aplica plasticidade acumulada em todas as camadas.\nÚtil no modo BATCH após processar múltiplos exemplos.",
      "params": [
        "self",
        "reward"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.sleep",
      "kind": "method",
      "name": "sleep",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.sleep",
      "file": "src/pyfolds/network/network.py",
      "line": 388,
      "doc": "Ciclo de sono para consolidação two-factor em todas camadas.\n\nArgs:\n    duration: Duração do sono em unidades de tempo",
      "params": [
        "self",
        "duration"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.get_all_metrics",
      "kind": "method",
      "name": "get_all_metrics",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.get_all_metrics",
      "file": "src/pyfolds/network/network.py",
      "line": 398,
      "doc": "Retorna métricas de todas as camadas.\n\nReturns:\n    Dict com métricas por camada",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.get_network_metrics",
      "kind": "method",
      "name": "get_network_metrics",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.get_network_metrics",
      "file": "src/pyfolds/network/network.py",
      "line": 410,
      "doc": "Retorna métricas agregadas da rede.\n\nReturns:\n    Dict com estatísticas da rede",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.network.MPJRDNetwork.extra_repr",
      "kind": "method",
      "name": "extra_repr",
      "qname": "src.pyfolds.network.network.MPJRDNetwork.extra_repr",
      "file": "src/pyfolds/network/network.py",
      "line": 436,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.network.wave_network",
      "kind": "module",
      "name": "wave_network",
      "qname": "src.pyfolds.network.wave_network",
      "file": "src/pyfolds/network/wave_network.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.network.wave_network.MPJRDWaveNetwork",
      "kind": "class",
      "name": "MPJRDWaveNetwork",
      "qname": "src.pyfolds.network.wave_network.MPJRDWaveNetwork",
      "file": "src/pyfolds/network/wave_network.py",
      "line": 8,
      "doc": "Wrapper para construção de redes com camadas wave.",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDNetwork"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.network.wave_network.MPJRDWaveNetwork.add_wave_layer",
      "kind": "method",
      "name": "add_wave_layer",
      "qname": "src.pyfolds.network.wave_network.MPJRDWaveNetwork.add_wave_layer",
      "file": "src/pyfolds/network/wave_network.py",
      "line": 11,
      "doc": null,
      "params": [
        "self",
        "name",
        "n_neurons",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.serialization",
      "kind": "module",
      "name": "serialization",
      "qname": "src.pyfolds.serialization",
      "file": "src/pyfolds/serialization/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.serialization.ecc",
      "kind": "module",
      "name": "ecc",
      "qname": "src.pyfolds.serialization.ecc",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.ecc.ECCResult",
      "kind": "class",
      "name": "ECCResult",
      "qname": "src.pyfolds.serialization.ecc.ECCResult",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 10,
      "doc": "Resultado da codificação ECC para um bloco de bytes.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "cls:src.pyfolds.serialization.ecc.ECCCodec",
      "kind": "class",
      "name": "ECCCodec",
      "qname": "src.pyfolds.serialization.ecc.ECCCodec",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 17,
      "doc": "Contrato de codec ECC utilizado por chunk.",
      "params": [],
      "returns": null,
      "bases": [
        "Protocol"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.ECCCodec.encode",
      "kind": "method",
      "name": "encode",
      "qname": "src.pyfolds.serialization.ecc.ECCCodec.encode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 22,
      "doc": "Gera bytes de paridade para os dados informados.",
      "params": [
        "self",
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.ECCCodec.decode",
      "kind": "method",
      "name": "decode",
      "qname": "src.pyfolds.serialization.ecc.ECCCodec.decode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 25,
      "doc": "Tenta corrigir dados usando bytes de paridade.",
      "params": [
        "self",
        "data",
        "ecc_bytes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.ecc.NoECC",
      "kind": "class",
      "name": "NoECC",
      "qname": "src.pyfolds.serialization.ecc.NoECC",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 29,
      "doc": "Codec nulo (somente detecção via CRC/SHA).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.NoECC.encode",
      "kind": "method",
      "name": "encode",
      "qname": "src.pyfolds.serialization.ecc.NoECC.encode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 34,
      "doc": null,
      "params": [
        "self",
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.NoECC.decode",
      "kind": "method",
      "name": "decode",
      "qname": "src.pyfolds.serialization.ecc.NoECC.decode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 37,
      "doc": null,
      "params": [
        "self",
        "data",
        "ecc_bytes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.ecc.ReedSolomonECC",
      "kind": "class",
      "name": "ReedSolomonECC",
      "qname": "src.pyfolds.serialization.ecc.ReedSolomonECC",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 41,
      "doc": "Codec Reed-Solomon opcional para correção de corrupção por chunk.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.serialization.ecc.ReedSolomonECC.__init__",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 44,
      "doc": null,
      "params": [
        "self",
        "symbols"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.encode",
      "kind": "method",
      "name": "encode",
      "qname": "src.pyfolds.serialization.ecc.ReedSolomonECC.encode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 54,
      "doc": null,
      "params": [
        "self",
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.decode",
      "kind": "method",
      "name": "decode",
      "qname": "src.pyfolds.serialization.ecc.ReedSolomonECC.decode",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 60,
      "doc": null,
      "params": [
        "self",
        "data",
        "ecc_bytes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.ecc.ecc_from_protection",
      "kind": "function",
      "name": "ecc_from_protection",
      "qname": "src.pyfolds.serialization.ecc.ecc_from_protection",
      "file": "src/pyfolds/serialization/ecc.py",
      "line": 73,
      "doc": "Mapeia nível de proteção em codec ECC.\n\nNíveis:\n    - off/none/0 -> NoECC\n    - low -> ReedSolomonECC(16)\n    - med -> ReedSolomonECC(32)\n    - high -> ReedSolomonECC(64)",
      "params": [
        "level"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.serialization.foldio",
      "kind": "module",
      "name": "foldio",
      "qname": "src.pyfolds.serialization.foldio",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._optional_import",
      "kind": "function",
      "name": "_optional_import",
      "qname": "src.pyfolds.serialization.foldio._optional_import",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 36,
      "doc": null,
      "params": [
        "module_name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._init_crc32c_table",
      "kind": "function",
      "name": "_init_crc32c_table",
      "qname": "src.pyfolds.serialization.foldio._init_crc32c_table",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 71,
      "doc": "Inicializa tabela CRC32C na primeira chamada.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._crc32c_fallback",
      "kind": "function",
      "name": "_crc32c_fallback",
      "qname": "src.pyfolds.serialization.foldio._crc32c_fallback",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 88,
      "doc": null,
      "params": [
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.foldio.FoldSecurityError",
      "kind": "class",
      "name": "FoldSecurityError",
      "qname": "src.pyfolds.serialization.foldio.FoldSecurityError",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 95,
      "doc": "Erro de segurança ao desserializar payload torch.",
      "params": [],
      "returns": null,
      "bases": [
        "RuntimeError"
      ],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.crc32c_u32",
      "kind": "function",
      "name": "crc32c_u32",
      "qname": "src.pyfolds.serialization.foldio.crc32c_u32",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 99,
      "doc": "Retorna CRC32C (Castagnoli) como inteiro unsigned de 32 bits.",
      "params": [
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.sha256_hex",
      "kind": "function",
      "name": "sha256_hex",
      "qname": "src.pyfolds.serialization.foldio.sha256_hex",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 126,
      "doc": "Retorna digest SHA-256 em formato hexadecimal.",
      "params": [
        "data"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._json_bytes",
      "kind": "function",
      "name": "_json_bytes",
      "qname": "src.pyfolds.serialization.foldio._json_bytes",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 131,
      "doc": null,
      "params": [
        "obj"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._canonical_json",
      "kind": "function",
      "name": "_canonical_json",
      "qname": "src.pyfolds.serialization.foldio._canonical_json",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 135,
      "doc": null,
      "params": [
        "obj"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._cfg_to_dict",
      "kind": "function",
      "name": "_cfg_to_dict",
      "qname": "src.pyfolds.serialization.foldio._cfg_to_dict",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 139,
      "doc": null,
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._safe_git_hash",
      "kind": "function",
      "name": "_safe_git_hash",
      "qname": "src.pyfolds.serialization.foldio._safe_git_hash",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 151,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._telemetry_snapshot",
      "kind": "function",
      "name": "_telemetry_snapshot",
      "qname": "src.pyfolds.serialization.foldio._telemetry_snapshot",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 163,
      "doc": null,
      "params": [
        "neuron",
        "max_events"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._history_snapshot",
      "kind": "function",
      "name": "_history_snapshot",
      "qname": "src.pyfolds.serialization.foldio._history_snapshot",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 185,
      "doc": null,
      "params": [
        "neuron"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._build_nuclear_npz",
      "kind": "function",
      "name": "_build_nuclear_npz",
      "qname": "src.pyfolds.serialization.foldio._build_nuclear_npz",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 195,
      "doc": null,
      "params": [
        "neuron"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.read_nuclear_arrays",
      "kind": "function",
      "name": "read_nuclear_arrays",
      "qname": "src.pyfolds.serialization.foldio.read_nuclear_arrays",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 221,
      "doc": "Lê apenas o chunk `nuclear_arrays` para análises científicas parciais.",
      "params": [
        "path",
        "use_mmap",
        "verify"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "kind": "class",
      "name": "FoldWriter",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 230,
      "doc": "Writer do container .fold/.mind.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter.__init__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 233,
      "doc": null,
      "params": [
        "self",
        "path",
        "compress",
        "zstd_level",
        "ecc"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__enter__",
      "kind": "method",
      "name": "__enter__",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter.__enter__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 247,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__exit__",
      "kind": "method",
      "name": "__exit__",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter.__exit__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 254,
      "doc": null,
      "params": [
        "self",
        "exc_type",
        "exc",
        "tb"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter._compress",
      "kind": "method",
      "name": "_compress",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter._compress",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 258,
      "doc": null,
      "params": [
        "self",
        "raw"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter.add_chunk",
      "kind": "method",
      "name": "add_chunk",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter.add_chunk",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 266,
      "doc": "Adiciona chunk com compressão, integridade e ECC opcional.\n\nOrdem de escrita:\n    1. compressão (se habilitada)\n    2. checksum (CRC32C/SHA256) do conteúdo comprimido\n    3. codificação ECC do conteúdo comprimido\n    4. persistência: [header | comp | ecc]\n\nNa leitura a ordem é invertida: leitura -> ECC -> verificação -> descompressão.",
      "params": [
        "self",
        "name",
        "ctype4",
        "payload"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldWriter.finalize",
      "kind": "method",
      "name": "finalize",
      "qname": "src.pyfolds.serialization.foldio.FoldWriter.finalize",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 327,
      "doc": null,
      "params": [
        "self",
        "metadata"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "kind": "class",
      "name": "FoldReader",
      "qname": "src.pyfolds.serialization.foldio.FoldReader",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 375,
      "doc": "Reader do container .fold/.mind com suporte a mmap.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.__init__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 378,
      "doc": null,
      "params": [
        "self",
        "path",
        "use_mmap"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.__enter__",
      "kind": "method",
      "name": "__enter__",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.__enter__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 386,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.__exit__",
      "kind": "method",
      "name": "__exit__",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.__exit__",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 393,
      "doc": null,
      "params": [
        "self",
        "exc_type",
        "exc",
        "tb"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader._read_at",
      "kind": "method",
      "name": "_read_at",
      "qname": "src.pyfolds.serialization.foldio.FoldReader._read_at",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 417,
      "doc": null,
      "params": [
        "self",
        "offset",
        "length"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader._read_header_and_index",
      "kind": "method",
      "name": "_read_header_and_index",
      "qname": "src.pyfolds.serialization.foldio.FoldReader._read_header_and_index",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 440,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.list_chunks",
      "kind": "method",
      "name": "list_chunks",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.list_chunks",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 512,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader._decompress",
      "kind": "method",
      "name": "_decompress",
      "qname": "src.pyfolds.serialization.foldio.FoldReader._decompress",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 515,
      "doc": null,
      "params": [
        "self",
        "comp",
        "flags"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader._ecc_codec",
      "kind": "method",
      "name": "_ecc_codec",
      "qname": "src.pyfolds.serialization.foldio.FoldReader._ecc_codec",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 523,
      "doc": null,
      "params": [
        "self",
        "algo"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_chunk_bytes",
      "kind": "method",
      "name": "read_chunk_bytes",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.read_chunk_bytes",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 531,
      "doc": null,
      "params": [
        "self",
        "name",
        "verify"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_json",
      "kind": "method",
      "name": "read_json",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.read_json",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 598,
      "doc": null,
      "params": [
        "self",
        "name",
        "verify"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_torch",
      "kind": "method",
      "name": "read_torch",
      "qname": "src.pyfolds.serialization.foldio.FoldReader.read_torch",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 601,
      "doc": null,
      "params": [
        "self",
        "name",
        "map_location",
        "verify",
        "trusted"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.foldio._TrustedFoldReader",
      "kind": "class",
      "name": "_TrustedFoldReader",
      "qname": "src.pyfolds.serialization.foldio._TrustedFoldReader",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 623,
      "doc": "Reader dedicado para ambientes de confiança explícita.",
      "params": [],
      "returns": null,
      "bases": [
        "FoldReader"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.foldio._TrustedFoldReader.read_torch",
      "kind": "method",
      "name": "read_torch",
      "qname": "src.pyfolds.serialization.foldio._TrustedFoldReader.read_torch",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 626,
      "doc": null,
      "params": [
        "self",
        "name",
        "map_location",
        "verify",
        "trusted"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._expression_summary",
      "kind": "function",
      "name": "_expression_summary",
      "qname": "src.pyfolds.serialization.foldio._expression_summary",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 637,
      "doc": null,
      "params": [
        "neuron"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._reproducibility_metadata",
      "kind": "function",
      "name": "_reproducibility_metadata",
      "qname": "src.pyfolds.serialization.foldio._reproducibility_metadata",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 671,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._collect_hyperparameters",
      "kind": "function",
      "name": "_collect_hyperparameters",
      "qname": "src.pyfolds.serialization.foldio._collect_hyperparameters",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 681,
      "doc": null,
      "params": [
        "neuron"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._sign_payload_ed25519",
      "kind": "function",
      "name": "_sign_payload_ed25519",
      "qname": "src.pyfolds.serialization.foldio._sign_payload_ed25519",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 688,
      "doc": null,
      "params": [
        "payload",
        "private_key_pem"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio._verify_payload_signature_ed25519",
      "kind": "function",
      "name": "_verify_payload_signature_ed25519",
      "qname": "src.pyfolds.serialization.foldio._verify_payload_signature_ed25519",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 700,
      "doc": null,
      "params": [
        "payload",
        "signature_hex",
        "public_key_pem"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.save_fold_or_mind",
      "kind": "function",
      "name": "save_fold_or_mind",
      "qname": "src.pyfolds.serialization.foldio.save_fold_or_mind",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 716,
      "doc": "Salva neurônio MPJRD em container .fold/.mind único e extensível.",
      "params": [
        "neuron",
        "path",
        "tags",
        "include_history",
        "include_telemetry",
        "include_nuclear_arrays",
        "compress",
        "ecc",
        "protection",
        "extra_manifest",
        "dataset_manifest",
        "performance_manifest",
        "fairness_manifest",
        "explainability_manifest",
        "compliance_manifest",
        "audit_events",
        "signature_private_key_pem",
        "signature_key_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.peek_fold_or_mind",
      "kind": "function",
      "name": "peek_fold_or_mind",
      "qname": "src.pyfolds.serialization.foldio.peek_fold_or_mind",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 844,
      "doc": "Inspeção rápida (header + índice + manifesto), sem carregar state_dict.",
      "params": [
        "path",
        "use_mmap"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.peek_mind",
      "kind": "function",
      "name": "peek_mind",
      "qname": "src.pyfolds.serialization.foldio.peek_mind",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 859,
      "doc": "Alias semântico para fluxos .mind.",
      "params": [
        "path",
        "use_mmap"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.load_fold_or_mind",
      "kind": "function",
      "name": "load_fold_or_mind",
      "qname": "src.pyfolds.serialization.foldio.load_fold_or_mind",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 865,
      "doc": "Carrega neurônio pelo chunk `torch_state` com validação por chunk.",
      "params": [
        "path",
        "neuron_class",
        "map_location",
        "trusted_torch_payload",
        "signature_public_key_pem"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.is_mind",
      "kind": "function",
      "name": "is_mind",
      "qname": "src.pyfolds.serialization.foldio.is_mind",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 921,
      "doc": "Regra de branding: arquivo com chunks IA explícitos é `.mind`.",
      "params": [
        "path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.serialization.foldio.is_mind_chunks",
      "kind": "function",
      "name": "is_mind_chunks",
      "qname": "src.pyfolds.serialization.foldio.is_mind_chunks",
      "file": "src/pyfolds/serialization/foldio.py",
      "line": 928,
      "doc": "Indica se um conjunto de chunks representa conteúdo com extensão `.mind`.",
      "params": [
        "chunks"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "kind": "module",
      "name": "versioned_checkpoint",
      "qname": "src.pyfolds.serialization.versioned_checkpoint",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "kind": "class",
      "name": "VersionedCheckpoint",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 16,
      "doc": "Salva/recupera estado do modelo com metadados e hash de integridade.\n\n✅ CORRIGIDO:\n    - Warnings para git hash ausente\n    - Validação de versão ao carregar\n    - Otimização de hash\n    - Suporte a compressão",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__init__",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 27,
      "doc": "Args:\n    model: Modelo a ser salvo/restaurado\n    version: Versão semântica do modelo (ex: \"2.0.0\")",
      "params": [
        "self",
        "model",
        "version"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._cfg_dict",
      "kind": "method",
      "name": "_cfg_dict",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._cfg_dict",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 36,
      "doc": "Extrai configuração do modelo em formato dict.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._git_hash",
      "kind": "method",
      "name": "_git_hash",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._git_hash",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 51,
      "doc": "Obtém hash atual do git para reprodutibilidade.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._metadata",
      "kind": "method",
      "name": "_metadata",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._metadata",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 73,
      "doc": "Gera metadados para o checkpoint.",
      "params": [
        "self",
        "extra"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._compute_hash",
      "kind": "method",
      "name": "_compute_hash",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._compute_hash",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 86,
      "doc": "Calcula hash SHA-256 do state dict.",
      "params": [
        "self",
        "state_dict"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.save",
      "kind": "method",
      "name": "save",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.save",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 99,
      "doc": "Salva checkpoint e retorna payload persistido.\n\nArgs:\n    path: Caminho do arquivo .pt\n    extra_metadata: Metadados adicionais\n    compress: Usar compressão zip (recomendado)\n\nReturns:\n    Dicionário com o checkpoint salvo",
      "params": [
        "self",
        "path",
        "extra_metadata",
        "compress"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.load",
      "kind": "method",
      "name": "load",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.load",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 138,
      "doc": "Carrega checkpoint, valida hash e opcionalmente restaura modelo.\n\nArgs:\n    path: Caminho do arquivo .pt\n    model: Modelo para carregar o estado (opcional)\n    map_location: Device para carregar tensores\n    strict: Se True, valida hash e versão\n    expected_version: Versão esperada (opcional)\n\nReturns:\n    Dicionário com o checkpoint carregado\n\nRaises:\n    ValueError: Se hash ou versão não coincidirem",
      "params": [
        "cls",
        "path",
        "model",
        "map_location",
        "strict",
        "expected_version"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__repr__",
      "kind": "method",
      "name": "__repr__",
      "qname": "src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__repr__",
      "file": "src/pyfolds/serialization/versioned_checkpoint.py",
      "line": 201,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry",
      "kind": "module",
      "name": "telemetry",
      "qname": "src.pyfolds.telemetry",
      "file": "src/pyfolds/telemetry/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.controller",
      "kind": "module",
      "name": "controller",
      "qname": "src.pyfolds.telemetry.controller",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.controller.TelemetryProfile",
      "kind": "class",
      "name": "TelemetryProfile",
      "qname": "src.pyfolds.telemetry.controller.TelemetryProfile",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 14,
      "doc": "Perfis disponíveis para telemetria.",
      "params": [],
      "returns": null,
      "bases": [
        "str",
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.controller.TelemetryStats",
      "kind": "class",
      "name": "TelemetryStats",
      "qname": "src.pyfolds.telemetry.controller.TelemetryStats",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 24,
      "doc": "Typed statistics for telemetry system.",
      "params": [],
      "returns": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.controller.TelemetryConfig",
      "kind": "class",
      "name": "TelemetryConfig",
      "qname": "src.pyfolds.telemetry.controller.TelemetryConfig",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 38,
      "doc": "Configuration for telemetry system.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryConfig.__post_init__",
      "kind": "method",
      "name": "__post_init__",
      "qname": "src.pyfolds.telemetry.controller.TelemetryConfig.__post_init__",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 45,
      "doc": "Validate configuration eagerly.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "kind": "class",
      "name": "TelemetryController",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 72,
      "doc": "Telemetry controller with thread-safe event collection.\n\nThis controller manages event filtering, sampling, and routing to sinks.\nAll public methods are thread-safe.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.__init__",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 80,
      "doc": "Initialize telemetry controller.\n\nArgs:\n    cfg: Telemetry configuration (uses defaults if None)\n    sink: Destination sink (auto-selected based on profile if None)",
      "params": [
        "self",
        "cfg",
        "sink"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.step_count",
      "kind": "method",
      "name": "step_count",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.step_count",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 103,
      "doc": "Thread-safe step counter.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController._increment_step",
      "kind": "method",
      "name": "_increment_step",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController._increment_step",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 108,
      "doc": "Thread-safe step increment.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.enabled",
      "kind": "method",
      "name": "enabled",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.enabled",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 113,
      "doc": "Is telemetry enabled?",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.should_emit",
      "kind": "method",
      "name": "should_emit",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.should_emit",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 117,
      "doc": "Should emit event at this step based on sample_every?\n\nArgs:\n    step_id: Current step ID\n    \nReturns:\n    True if should emit",
      "params": [
        "self",
        "step_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.should_emit_sample",
      "kind": "method",
      "name": "should_emit_sample",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.should_emit_sample",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 139,
      "doc": "Probabilistic sampling independent of step_id.\n\nArgs:\n    sample_rate: Probability of emitting (0.0 to 1.0)\n    \nReturns:\n    True if should emit based on random sampling",
      "params": [
        "self",
        "sample_rate"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.emit",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 155,
      "doc": "Emit a telemetry event (thread-safe).\n\nArgs:\n    event: Event to emit (may have lazy payload)",
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.snapshot",
      "kind": "method",
      "name": "snapshot",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.snapshot",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 173,
      "doc": "Return snapshot of stored events (thread-safe).\n\nReturns:\n    List of event payloads",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.clear",
      "kind": "method",
      "name": "clear",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.clear",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 185,
      "doc": "Clear memory buffer (thread-safe).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.get_stats",
      "kind": "method",
      "name": "get_stats",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.get_stats",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 191,
      "doc": "Return telemetry system statistics.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.controller.TelemetryController.get_telemetry_metrics",
      "kind": "method",
      "name": "get_telemetry_metrics",
      "qname": "src.pyfolds.telemetry.controller.TelemetryController.get_telemetry_metrics",
      "file": "src/pyfolds/telemetry/controller.py",
      "line": 212,
      "doc": "Return metrics about telemetry overhead.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.decorator",
      "kind": "module",
      "name": "decorator",
      "qname": "src.pyfolds.telemetry.decorator",
      "file": "src/pyfolds/telemetry/decorator.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.decorator.telemetry",
      "kind": "function",
      "name": "telemetry",
      "qname": "src.pyfolds.telemetry.decorator.telemetry",
      "file": "src/pyfolds/telemetry/decorator.py",
      "line": 10,
      "doc": "Decorador para coletar telemetria automaticamente.\n\nArgs:\n    phase: Fase do evento ('forward', 'commit', 'sleep')\n    sample_rate: Taxa de amostragem (ex: 0.1 = 10% das chamadas)\n    capture_args: Se True, captura argumentos da função\n    capture_return: Se True, captura valor de retorno\n\nExample:\n    >>> @telemetry(phase=\"forward\", capture_return=True)\n    ... def forward_pass(self, x):\n    ...     # ... código ...\n    ...     return {'spike_rate': 0.15, 'theta': 4.5}",
      "params": [
        "phase",
        "sample_rate",
        "capture_args",
        "capture_return"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.events",
      "kind": "module",
      "name": "events",
      "qname": "src.pyfolds.telemetry.events",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.events.TelemetryEvent",
      "kind": "class",
      "name": "TelemetryEvent",
      "qname": "src.pyfolds.telemetry.events.TelemetryEvent",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 14,
      "doc": "Evento base de telemetria com suporte a lazy evaluation.\n\nAttributes:\n    step_id: ID do passo atual\n    phase: Fase do evento (forward, commit, sleep)\n    mode: Modo de aprendizado\n    _payload: Dicionário ou função que retorna o payload\n    timestamp: Timestamp de alta precisão (perf_counter)\n    wall_time: Timestamp de parede (para análise temporal)\n    neuron_id: ID opcional do neurônio",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.events.TelemetryEvent.payload",
      "kind": "method",
      "name": "payload",
      "qname": "src.pyfolds.telemetry.events.TelemetryEvent.payload",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 36,
      "doc": "Avalia payload lazy se necessário.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.forward_event",
      "kind": "function",
      "name": "forward_event",
      "qname": "src.pyfolds.telemetry.events.forward_event",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 43,
      "doc": "Cria evento de forward pass (eager).\n\nArgs:\n    step_id: ID do passo\n    mode: Modo de aprendizado\n    neuron_id: ID do neurônio (opcional)\n    **payload: Métricas a serem coletadas",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.forward_event_lazy",
      "kind": "function",
      "name": "forward_event_lazy",
      "qname": "src.pyfolds.telemetry.events.forward_event_lazy",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 63,
      "doc": "Cria evento de forward pass com lazy evaluation (economia de CPU).\n\nArgs:\n    step_id: ID do passo\n    mode: Modo de aprendizado\n    neuron_id: ID do neurônio (opcional)\n    payload_fn: Função que retorna o payload (só é chamada se o evento for emitido)\n\nExample:\n    >>> telem.emit(forward_event_lazy(\n    ...     step_id=step,\n    ...     mode=\"online\",\n    ...     payload_fn=lambda: {\n    ...         'spike_rate': neuron.get_spike_rate(),  # Só calcula se necessário\n    ...         'theta': neuron.theta.item()\n    ...     }\n    ... ))",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.commit_event",
      "kind": "function",
      "name": "commit_event",
      "qname": "src.pyfolds.telemetry.events.commit_event",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 94,
      "doc": "Cria evento de commit (plasticidade).",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.commit_event_lazy",
      "kind": "function",
      "name": "commit_event_lazy",
      "qname": "src.pyfolds.telemetry.events.commit_event_lazy",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 106,
      "doc": "Cria evento de commit com lazy evaluation.",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.sleep_event",
      "kind": "function",
      "name": "sleep_event",
      "qname": "src.pyfolds.telemetry.events.sleep_event",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 119,
      "doc": "Cria evento de sleep (consolidação).",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.telemetry.events.sleep_event_lazy",
      "kind": "function",
      "name": "sleep_event_lazy",
      "qname": "src.pyfolds.telemetry.events.sleep_event_lazy",
      "file": "src/pyfolds/telemetry/events.py",
      "line": 131,
      "doc": "Cria evento de sleep com lazy evaluation.",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.ringbuffer",
      "kind": "module",
      "name": "ringbuffer",
      "qname": "src.pyfolds.telemetry.ringbuffer",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "kind": "class",
      "name": "RingBuffer",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 10,
      "doc": "Thread-safe circular buffer with fixed capacity.\n\nThis buffer maintains items in FIFO order and overwrites oldest\nitems when capacity is reached. All operations are thread-safe.\n\nArgs:\n    capacity: Maximum number of elements\n    \nExample:\n    >>> buf = RingBuffer[int](3)\n    >>> buf.append(1)\n    >>> buf.append(2)\n    >>> buf.append(3)\n    >>> buf.append(4)  # Overwrites oldest (1)\n    >>> buf.snapshot()  # [2, 3, 4]\n    >>> len(buf)  # 3",
      "params": [],
      "returns": null,
      "bases": [
        "Generic[T]"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.__init__",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 30,
      "doc": null,
      "params": [
        "self",
        "capacity"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.append",
      "kind": "method",
      "name": "append",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.append",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 40,
      "doc": "Add an item to the buffer (thread-safe).",
      "params": [
        "self",
        "item"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.extend",
      "kind": "method",
      "name": "extend",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.extend",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 48,
      "doc": "Add multiple items to the buffer (thread-safe).",
      "params": [
        "self",
        "items"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.snapshot",
      "kind": "method",
      "name": "snapshot",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.snapshot",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 53,
      "doc": "Return a copy of elements in chronological order (thread-safe).\n\nReturns:\n    List of elements from oldest to newest",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.clear",
      "kind": "method",
      "name": "clear",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.clear",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 73,
      "doc": "Clear the buffer (thread-safe).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.capacity",
      "kind": "method",
      "name": "capacity",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.capacity",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 81,
      "doc": "Maximum buffer capacity.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.is_full",
      "kind": "method",
      "name": "is_full",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.is_full",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 86,
      "doc": "Is buffer full?",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__len__",
      "kind": "method",
      "name": "__len__",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.__len__",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 91,
      "doc": "Current number of elements.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__repr__",
      "kind": "method",
      "name": "__repr__",
      "qname": "src.pyfolds.telemetry.ringbuffer.RingBuffer.__repr__",
      "file": "src/pyfolds/telemetry/ringbuffer.py",
      "line": 96,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.sinks",
      "kind": "module",
      "name": "sinks",
      "qname": "src.pyfolds.telemetry.sinks",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.Sink",
      "kind": "class",
      "name": "Sink",
      "qname": "src.pyfolds.telemetry.sinks.Sink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 21,
      "doc": "Base class for telemetry sinks with context manager support.",
      "params": [],
      "returns": null,
      "bases": [
        "ABC"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.Sink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.Sink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 25,
      "doc": "Emit an event to this sink.",
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "abstractmethod"
      ]
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.Sink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.Sink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 29,
      "doc": "Force buffer writes (if applicable).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.Sink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.Sink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 33,
      "doc": "Close the sink (release resources).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.Sink.__enter__",
      "kind": "method",
      "name": "__enter__",
      "qname": "src.pyfolds.telemetry.sinks.Sink.__enter__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 37,
      "doc": "Context manager entry.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.Sink.__exit__",
      "kind": "method",
      "name": "__exit__",
      "qname": "src.pyfolds.telemetry.sinks.Sink.__exit__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 41,
      "doc": "Context manager exit - ensures close.",
      "params": [
        "self",
        "exc_type",
        "exc_val",
        "exc_tb"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "kind": "class",
      "name": "NoOpSink",
      "qname": "src.pyfolds.telemetry.sinks.NoOpSink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 46,
      "doc": "Sink that does nothing (for profile=off).",
      "params": [],
      "returns": null,
      "bases": [
        "Sink"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.NoOpSink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 49,
      "doc": null,
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.NoOpSink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 52,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.NoOpSink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 55,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "kind": "class",
      "name": "MemorySink",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 59,
      "doc": "Sink that keeps events in memory (circular buffer).\n\nArgs:\n    capacity: Maximum buffer capacity",
      "params": [],
      "returns": null,
      "bases": [
        "Sink"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.__init__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 67,
      "doc": null,
      "params": [
        "self",
        "capacity"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 70,
      "doc": null,
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.snapshot",
      "kind": "method",
      "name": "snapshot",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.snapshot",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 73,
      "doc": "Return copy of events in buffer.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.clear",
      "kind": "method",
      "name": "clear",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.clear",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 77,
      "doc": "Clear the buffer.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 81,
      "doc": "Nothing to flush for memory sink.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.MemorySink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.MemorySink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 85,
      "doc": "Nothing to close for memory sink.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "kind": "class",
      "name": "ConsoleSink",
      "qname": "src.pyfolds.telemetry.sinks.ConsoleSink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 90,
      "doc": "Sink que escreve eventos diretamente no stdout via ``print``.\n\nNota: este sink ignora a configuração de handlers do ``logging``.\nPara execução silenciosa (console limpo), prefira ``JSONLinesSink``\nou ``MemorySink``.\n\nArgs:\n    verbose: If True, print full payload",
      "params": [],
      "returns": null,
      "bases": [
        "Sink"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.sinks.ConsoleSink.__init__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 102,
      "doc": null,
      "params": [
        "self",
        "verbose"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.ConsoleSink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 105,
      "doc": null,
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.ConsoleSink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 115,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.ConsoleSink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 118,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "kind": "class",
      "name": "JSONLinesSink",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 122,
      "doc": "Sink that writes events to JSON Lines file.\n\nArgs:\n    path: File path\n    flush_every: Number of events before auto-flush (0 = never)\n    truncate: If True, overwrite file on open; otherwise append\n\nExample:\n    >>> with JSONLinesSink(\"telemetry.jsonl\", truncate=True) as sink:\n    ...     sink.emit(event)\n    ... # File automatically closed",
      "params": [],
      "returns": null,
      "bases": [
        "Sink"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.__init__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 137,
      "doc": null,
      "params": [
        "self",
        "path",
        "flush_every",
        "truncate"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__enter__",
      "kind": "method",
      "name": "__enter__",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.__enter__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 144,
      "doc": "Open file when entering context.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__exit__",
      "kind": "method",
      "name": "__exit__",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.__exit__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 149,
      "doc": "Ensure close even with error.",
      "params": [
        "self",
        "exc_type",
        "exc_val",
        "exc_tb"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink._ensure_open",
      "kind": "method",
      "name": "_ensure_open",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink._ensure_open",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 153,
      "doc": "Open file if needed.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink._make_serializable",
      "kind": "method",
      "name": "_make_serializable",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink._make_serializable",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 160,
      "doc": "Convert objects to JSON-serializable formats.",
      "params": [
        "self",
        "obj",
        "_depth",
        "_max_depth"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 182,
      "doc": "Emit event to file.",
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 217,
      "doc": "Force write to disk.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.JSONLinesSink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 222,
      "doc": "Close the file.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "kind": "class",
      "name": "DistributorSink",
      "qname": "src.pyfolds.telemetry.sinks.DistributorSink",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 230,
      "doc": "Sink that distributes events to multiple sinks.\n\nUseful for sending events to multiple destinations simultaneously:\n- MemorySink for MindBoard (real-time)\n- JSONLinesSink for MindAudit (persistence)\n- ConsoleSink for debug\n\nArgs:\n    sinks: List of sinks to distribute events to\n\nExample:\n    >>> sink = DistributorSink([\n    ...     MemorySink(1000),           # For MindBoard\n    ...     JSONLinesSink(\"audit.jsonl\") # For MindAudit\n    ... ])\n    >>> telem = TelemetryController(sink=sink)",
      "params": [],
      "returns": null,
      "bases": [
        "Sink"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.telemetry.sinks.DistributorSink.__init__",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 250,
      "doc": null,
      "params": [
        "self",
        "sinks"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.telemetry.sinks.DistributorSink.emit",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 253,
      "doc": "Distribute event to all sinks.",
      "params": [
        "self",
        "event"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.flush",
      "kind": "method",
      "name": "flush",
      "qname": "src.pyfolds.telemetry.sinks.DistributorSink.flush",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 261,
      "doc": "Flush all sinks that support it.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.close",
      "kind": "method",
      "name": "close",
      "qname": "src.pyfolds.telemetry.sinks.DistributorSink.close",
      "file": "src/pyfolds/telemetry/sinks.py",
      "line": 270,
      "doc": "Close all sinks.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.telemetry.types",
      "kind": "module",
      "name": "types",
      "qname": "src.pyfolds.telemetry.types",
      "file": "src/pyfolds/telemetry/types.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.types.ForwardPayload",
      "kind": "class",
      "name": "ForwardPayload",
      "qname": "src.pyfolds.telemetry.types.ForwardPayload",
      "file": "src/pyfolds/telemetry/types.py",
      "line": 6,
      "doc": "Payload tipado para fase forward.",
      "params": [],
      "returns": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.types.CommitPayload",
      "kind": "class",
      "name": "CommitPayload",
      "qname": "src.pyfolds.telemetry.types.CommitPayload",
      "file": "src/pyfolds/telemetry/types.py",
      "line": 23,
      "doc": "Payload tipado para fase commit.",
      "params": [],
      "returns": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.telemetry.types.SleepPayload",
      "kind": "class",
      "name": "SleepPayload",
      "qname": "src.pyfolds.telemetry.types.SleepPayload",
      "file": "src/pyfolds/telemetry/types.py",
      "line": 33,
      "doc": "Payload tipado para fase sleep.",
      "params": [],
      "returns": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.tf",
      "kind": "module",
      "name": "tf",
      "qname": "src.pyfolds.tf",
      "file": "src/pyfolds/tf/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.tf.__getattr__",
      "kind": "function",
      "name": "__getattr__",
      "qname": "src.pyfolds.tf.__getattr__",
      "file": "src/pyfolds/tf/__init__.py",
      "line": 26,
      "doc": null,
      "params": [
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.tf.layers",
      "kind": "module",
      "name": "layers",
      "qname": "src.pyfolds.tf.layers",
      "file": "src/pyfolds/tf/layers.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.tf.layers.MPJRDTFLayer",
      "kind": "class",
      "name": "MPJRDTFLayer",
      "qname": "src.pyfolds.tf.layers.MPJRDTFLayer",
      "file": "src/pyfolds/tf/layers.py",
      "line": 16,
      "doc": "Keras-compatible wrapper that exposes torch-like dict output.",
      "params": [],
      "returns": null,
      "bases": [
        "tf.keras.layers.Layer"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.layers.MPJRDTFLayer.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.tf.layers.MPJRDTFLayer.__init__",
      "file": "src/pyfolds/tf/layers.py",
      "line": 19,
      "doc": null,
      "params": [
        "self",
        "units"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.layers.MPJRDTFLayer.call",
      "kind": "method",
      "name": "call",
      "qname": "src.pyfolds.tf.layers.MPJRDTFLayer.call",
      "file": "src/pyfolds/tf/layers.py",
      "line": 35,
      "doc": null,
      "params": [
        "self",
        "inputs",
        "initial_state",
        "training"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.tf.neuron",
      "kind": "module",
      "name": "neuron",
      "qname": "src.pyfolds.tf.neuron",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "kind": "class",
      "name": "MPJRDTFNeuronCell",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 16,
      "doc": "Minimal recurrent cell implementing a membrane/spike update step.",
      "params": [],
      "returns": null,
      "bases": [
        "tf.keras.layers.Layer"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.__init__",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 19,
      "doc": null,
      "params": [
        "self",
        "units"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.state_size",
      "kind": "method",
      "name": "state_size",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.state_size",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 37,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.output_size",
      "kind": "method",
      "name": "output_size",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.output_size",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 41,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_initial_state",
      "kind": "method",
      "name": "get_initial_state",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_initial_state",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 44,
      "doc": null,
      "params": [
        "self",
        "inputs",
        "batch_size",
        "dtype"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.step",
      "kind": "method",
      "name": "step",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.step",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 55,
      "doc": null,
      "params": [
        "self",
        "inputs",
        "prev_state"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.call",
      "kind": "method",
      "name": "call",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.call",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 68,
      "doc": null,
      "params": [
        "self",
        "inputs",
        "states",
        "training",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_config",
      "kind": "method",
      "name": "get_config",
      "qname": "src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_config",
      "file": "src/pyfolds/tf/neuron.py",
      "line": 74,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils",
      "kind": "module",
      "name": "utils",
      "qname": "src.pyfolds.utils",
      "file": "src/pyfolds/utils/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils.context",
      "kind": "module",
      "name": "context",
      "qname": "src.pyfolds.utils.context",
      "file": "src/pyfolds/utils/context.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.context.learning_mode",
      "kind": "function",
      "name": "learning_mode",
      "qname": "src.pyfolds.utils.context.learning_mode",
      "file": "src/pyfolds/utils/context.py",
      "line": 13,
      "doc": "Altera temporariamente o modo de aprendizado de um neurônio.",
      "params": [
        "neuron",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ]
    },
    {
      "id": "mod:src.pyfolds.utils.device",
      "kind": "module",
      "name": "device",
      "qname": "src.pyfolds.utils.device",
      "file": "src/pyfolds/utils/device.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.device.infer_device",
      "kind": "function",
      "name": "infer_device",
      "qname": "src.pyfolds.utils.device.infer_device",
      "file": "src/pyfolds/utils/device.py",
      "line": 10,
      "doc": "Infere device a partir de inputs.",
      "params": [
        "inputs"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.device.get_device",
      "kind": "function",
      "name": "get_device",
      "qname": "src.pyfolds.utils.device.get_device",
      "file": "src/pyfolds/utils/device.py",
      "line": 28,
      "doc": "Retorna melhor device disponível.",
      "params": [
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.device.ensure_device",
      "kind": "function",
      "name": "ensure_device",
      "qname": "src.pyfolds.utils.device.ensure_device",
      "file": "src/pyfolds/utils/device.py",
      "line": 35,
      "doc": "Garante que tensor está no device especificado.",
      "params": [
        "tensor",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.device.DeviceManager",
      "kind": "class",
      "name": "DeviceManager",
      "qname": "src.pyfolds.utils.device.DeviceManager",
      "file": "src/pyfolds/utils/device.py",
      "line": 42,
      "doc": "Gerenciador de device para PyFolds.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.device.DeviceManager.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.utils.device.DeviceManager.__init__",
      "file": "src/pyfolds/utils/device.py",
      "line": 45,
      "doc": null,
      "params": [
        "self",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.device.DeviceManager._validate_device",
      "kind": "method",
      "name": "_validate_device",
      "qname": "src.pyfolds.utils.device.DeviceManager._validate_device",
      "file": "src/pyfolds/utils/device.py",
      "line": 53,
      "doc": "Valida que device está disponível.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.device.DeviceManager.to",
      "kind": "method",
      "name": "to",
      "qname": "src.pyfolds.utils.device.DeviceManager.to",
      "file": "src/pyfolds/utils/device.py",
      "line": 58,
      "doc": "Move objetos para o device gerenciado.\n\nArgs:\n    *objs: Objetos a mover (tensores, módulos, etc)\n\nReturns:\n    Objeto único ou tupla de objetos movidos",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.device.DeviceManager.check_consistency",
      "kind": "method",
      "name": "check_consistency",
      "qname": "src.pyfolds.utils.device.DeviceManager.check_consistency",
      "file": "src/pyfolds/utils/device.py",
      "line": 82,
      "doc": "Verifica que todos os tensores estão no device correto.\n\nArgs:\n    *tensors: Tensores a verificar\n\nReturns:\n    True se consistentes\n\nRaises:\n    ValueError: Se devices não correspondem",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils.logging",
      "kind": "module",
      "name": "logging",
      "qname": "src.pyfolds.utils.logging",
      "file": "src/pyfolds/utils/logging.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.trace",
      "kind": "function",
      "name": "trace",
      "qname": "src.pyfolds.utils.logging.trace",
      "file": "src/pyfolds/utils/logging.py",
      "line": 32,
      "doc": "Método trace para logging (nível 5 - mais detalhado que DEBUG).",
      "params": [
        "self",
        "message"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.logging.StructuredFormatter",
      "kind": "class",
      "name": "StructuredFormatter",
      "qname": "src.pyfolds.utils.logging.StructuredFormatter",
      "file": "src/pyfolds/utils/logging.py",
      "line": 41,
      "doc": "JSON formatter para logs estruturados (ideal para produção).",
      "params": [],
      "returns": null,
      "bases": [
        "logging.Formatter"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.StructuredFormatter.format",
      "kind": "method",
      "name": "format",
      "qname": "src.pyfolds.utils.logging.StructuredFormatter.format",
      "file": "src/pyfolds/utils/logging.py",
      "line": 44,
      "doc": null,
      "params": [
        "self",
        "record"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.logging.FixedLayoutFormatter",
      "kind": "class",
      "name": "FixedLayoutFormatter",
      "qname": "src.pyfolds.utils.logging.FixedLayoutFormatter",
      "file": "src/pyfolds/utils/logging.py",
      "line": 64,
      "doc": "Formatter de layout fixo (largura estável) para auditoria/debug.",
      "params": [],
      "returns": null,
      "bases": [
        "logging.Formatter"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.FixedLayoutFormatter.format",
      "kind": "method",
      "name": "format",
      "qname": "src.pyfolds.utils.logging.FixedLayoutFormatter.format",
      "file": "src/pyfolds/utils/logging.py",
      "line": 67,
      "doc": null,
      "params": [
        "self",
        "record"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "kind": "class",
      "name": "PyFoldsLogger",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger",
      "file": "src/pyfolds/utils/logging.py",
      "line": 79,
      "doc": "Gerenciador singleton de logging para PyFolds.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.__new__",
      "kind": "method",
      "name": "__new__",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger.__new__",
      "file": "src/pyfolds/utils/logging.py",
      "line": 84,
      "doc": null,
      "params": [
        "cls"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger.__init__",
      "file": "src/pyfolds/utils/logging.py",
      "line": 89,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.setup",
      "kind": "method",
      "name": "setup",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger.setup",
      "file": "src/pyfolds/utils/logging.py",
      "line": 102,
      "doc": "Configura logging global e permite reconfiguração segura.",
      "params": [
        "self",
        "level",
        "log_file",
        "format_string",
        "module_levels",
        "structured",
        "circular_buffer_lines",
        "console",
        "fixed_layout"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.get_logger",
      "kind": "method",
      "name": "get_logger",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger.get_logger",
      "file": "src/pyfolds/utils/logging.py",
      "line": 175,
      "doc": "Retorna logger configurado.",
      "params": [
        "self",
        "name",
        "level"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.add_file_handler",
      "kind": "method",
      "name": "add_file_handler",
      "qname": "src.pyfolds.utils.logging.PyFoldsLogger.add_file_handler",
      "file": "src/pyfolds/utils/logging.py",
      "line": 187,
      "doc": "Adiciona handler de arquivo adicional com rotação.",
      "params": [
        "self",
        "path",
        "level",
        "max_bytes",
        "backup_count"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.get_logger",
      "kind": "function",
      "name": "get_logger",
      "qname": "src.pyfolds.utils.logging.get_logger",
      "file": "src/pyfolds/utils/logging.py",
      "line": 213,
      "doc": "Função conveniência para obter logger.",
      "params": [
        "name"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.setup_run_logging",
      "kind": "function",
      "name": "setup_run_logging",
      "qname": "src.pyfolds.utils.logging.setup_run_logging",
      "file": "src/pyfolds/utils/logging.py",
      "line": 220,
      "doc": "Configuração recomendada para execução (treino/debug em produção).\n\nCria automaticamente um arquivo incremental e configura logging para arquivo\ncom terminal silencioso por padrão.\n\nReturns:\n    Tupla ``(logger, log_path)``.",
      "params": [
        "app",
        "version",
        "log_dir",
        "level",
        "structured",
        "fixed_layout",
        "console",
        "circular_buffer_lines"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.setup_logging",
      "kind": "function",
      "name": "setup_logging",
      "qname": "src.pyfolds.utils.logging.setup_logging",
      "file": "src/pyfolds/utils/logging.py",
      "line": 258,
      "doc": "Setup rápido de logging.",
      "params": [
        "log_file",
        "level",
        "structured",
        "circular_buffer_lines",
        "console",
        "fixed_layout"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.logging.CircularBufferFileHandler",
      "kind": "class",
      "name": "CircularBufferFileHandler",
      "qname": "src.pyfolds.utils.logging.CircularBufferFileHandler",
      "file": "src/pyfolds/utils/logging.py",
      "line": 278,
      "doc": "Handler TXT com buffer circular em número de linhas.\n\nMantém somente as últimas ``capacity_lines`` mensagens no arquivo,\nsobrescrevendo-o a cada emissão para preservar ordem cronológica.\n\nNota:\n    Recomendado para debug e inspeção dos últimos eventos.\n    Não é recomendado para treinos longos, pois cada ``emit``\n    reescreve o arquivo inteiro (custo O(n) no tamanho do buffer).",
      "params": [],
      "returns": null,
      "bases": [
        "logging.Handler"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.CircularBufferFileHandler.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.utils.logging.CircularBufferFileHandler.__init__",
      "file": "src/pyfolds/utils/logging.py",
      "line": 290,
      "doc": null,
      "params": [
        "self",
        "path",
        "capacity_lines",
        "encoding"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.logging.CircularBufferFileHandler.emit",
      "kind": "method",
      "name": "emit",
      "qname": "src.pyfolds.utils.logging.CircularBufferFileHandler.emit",
      "file": "src/pyfolds/utils/logging.py",
      "line": 308,
      "doc": null,
      "params": [
        "self",
        "record"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.next_log_path",
      "kind": "function",
      "name": "next_log_path",
      "qname": "src.pyfolds.utils.logging.next_log_path",
      "file": "src/pyfolds/utils/logging.py",
      "line": 321,
      "doc": "Gera caminho de log incremental: NNN_app_version_YYYYMMDD_HHMMSS.log.",
      "params": [
        "log_dir",
        "app",
        "version"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.logging.build_log_path",
      "kind": "function",
      "name": "build_log_path",
      "qname": "src.pyfolds.utils.logging.build_log_path",
      "file": "src/pyfolds/utils/logging.py",
      "line": 338,
      "doc": "Alias de compatibilidade para ``next_log_path``.",
      "params": [
        "log_dir",
        "app",
        "version"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils.math",
      "kind": "module",
      "name": "math",
      "qname": "src.pyfolds.utils.math",
      "file": "src/pyfolds/utils/math.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.safe_weight_law",
      "kind": "function",
      "name": "safe_weight_law",
      "qname": "src.pyfolds.utils.math.safe_weight_law",
      "file": "src/pyfolds/utils/math.py",
      "line": 8,
      "doc": "Lei logarítmica estável para conversão de filamentos em peso.\n\nImplementa a regra Bartol com proteção numérica:\n    W = log2(1 + N) / w_scale\n\nProteções:\n  1) clip de ``N`` antes do log2\n  2) saturação do resultado final\n  3) checagens opcionais de NaN/Inf",
      "params": [
        "N",
        "w_scale",
        "max_log_val",
        "enforce_checks"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.safe_div",
      "kind": "function",
      "name": "safe_div",
      "qname": "src.pyfolds.utils.math.safe_div",
      "file": "src/pyfolds/utils/math.py",
      "line": 40,
      "doc": "Divisão segura com epsilon para evitar divisão por zero.\n\nArgs:\n    x: Numerador\n    y: Denominador\n    eps: Epsilon para evitar divisão por zero\n\nReturns:\n    x / (y + eps)",
      "params": [
        "x",
        "y",
        "eps"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.clamp_rate",
      "kind": "function",
      "name": "clamp_rate",
      "qname": "src.pyfolds.utils.math.clamp_rate",
      "file": "src/pyfolds/utils/math.py",
      "line": 55,
      "doc": "Mantém taxa de disparo em [0, 1].\n\nArgs:\n    r: Taxa de disparo (tensor ou float)\n\nReturns:\n    Valor clampado em [0, 1]",
      "params": [
        "r"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.clamp_R",
      "kind": "function",
      "name": "clamp_R",
      "qname": "src.pyfolds.utils.math.clamp_R",
      "file": "src/pyfolds/utils/math.py",
      "line": 70,
      "doc": "Mantém sinal neuromodulador em [-1, 1].\n\nArgs:\n    r: Sinal neuromodulador (tensor ou float)\n\nReturns:\n    Valor clampado em [-1, 1]",
      "params": [
        "r"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.xavier_init",
      "kind": "function",
      "name": "xavier_init",
      "qname": "src.pyfolds.utils.math.xavier_init",
      "file": "src/pyfolds/utils/math.py",
      "line": 85,
      "doc": "Inicialização Xavier para pesos.\n\nArgs:\n    shape: Dimensões do tensor\n    gain: Ganho (1.0 para sigmoid/tanh, sqrt(2) para ReLU)\n\nReturns:\n    Tensor inicializado com distribuição normal * std",
      "params": [
        "shape",
        "gain"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.math.calculate_vc_dimension",
      "kind": "function",
      "name": "calculate_vc_dimension",
      "qname": "src.pyfolds.utils.math.calculate_vc_dimension",
      "file": "src/pyfolds/utils/math.py",
      "line": 105,
      "doc": "Calcula VC-dimension aproximado de uma rede MPJRD.\n\nA VC-dimension mede a capacidade de aprendizado da rede.\nFórmula: VC-dim ≈ N * D * log2(N * D * S * C)\n\nArgs:\n    n_neurons: Número de neurônios\n    n_dendrites: Número de dendritos por neurônio\n    n_synapses: Número de sinapses por dendrito\n    avg_connections: Média de conexões ativas (default: 1.0)\n\nReturns:\n    VC-dimension aproximada\n\nExample:\n    >>> vc = calculate_vc_dimension(100, 4, 32)\n    >>> print(f\"VC-dimension: {vc:.0f}\")",
      "params": [
        "n_neurons",
        "n_dendrites",
        "n_synapses",
        "avg_connections"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils.types",
      "kind": "module",
      "name": "types",
      "qname": "src.pyfolds.utils.types",
      "file": "src/pyfolds/utils/types.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.types.LearningMode",
      "kind": "class",
      "name": "LearningMode",
      "qname": "src.pyfolds.utils.types.LearningMode",
      "file": "src/pyfolds/utils/types.py",
      "line": 13,
      "doc": "Modos de aprendizado do neurônio MPJRD.",
      "params": [],
      "returns": null,
      "bases": [
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.types.LearningMode.learning_rate_multiplier",
      "kind": "method",
      "name": "learning_rate_multiplier",
      "qname": "src.pyfolds.utils.types.LearningMode.learning_rate_multiplier",
      "file": "src/pyfolds/utils/types.py",
      "line": 22,
      "doc": "Multiplicador de learning rate para cada modo.\n\nReturns:\n    ONLINE: 5.0 (aprendizado acelerado)\n    BATCH: 0.2 (atualização conservadora)\n    SLEEP: 0.0 (sem plasticidade ativa)\n    INFERENCE: 0.0 (sem aprendizado)",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.utils.types.LearningMode.description",
      "kind": "method",
      "name": "description",
      "qname": "src.pyfolds.utils.types.LearningMode.description",
      "file": "src/pyfolds/utils/types.py",
      "line": 41,
      "doc": "Descrição do modo de aprendizado.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "mtd:src.pyfolds.utils.types.LearningMode.is_learning",
      "kind": "method",
      "name": "is_learning",
      "qname": "src.pyfolds.utils.types.LearningMode.is_learning",
      "file": "src/pyfolds/utils/types.py",
      "line": 51,
      "doc": "Retorna True se o modo permite aprendizado.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.types.LearningMode.is_consolidating",
      "kind": "method",
      "name": "is_consolidating",
      "qname": "src.pyfolds.utils.types.LearningMode.is_consolidating",
      "file": "src/pyfolds/utils/types.py",
      "line": 55,
      "doc": "Retorna True se o modo é consolidação (sono).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.types.normalize_learning_mode",
      "kind": "function",
      "name": "normalize_learning_mode",
      "qname": "src.pyfolds.utils.types.normalize_learning_mode",
      "file": "src/pyfolds/utils/types.py",
      "line": 60,
      "doc": "Normaliza o modo aceitando enum ou string (case-insensitive).",
      "params": [
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.types.ConnectionType",
      "kind": "class",
      "name": "ConnectionType",
      "qname": "src.pyfolds.utils.types.ConnectionType",
      "file": "src/pyfolds/utils/types.py",
      "line": 76,
      "doc": "Tipos de conexão entre camadas.",
      "params": [],
      "returns": null,
      "bases": [
        "Enum"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.types.ModeConfig",
      "kind": "class",
      "name": "ModeConfig",
      "qname": "src.pyfolds.utils.types.ModeConfig",
      "file": "src/pyfolds/utils/types.py",
      "line": 92,
      "doc": "Configurações específicas por modo de aprendizado.\n\nConfiguração global para escalonar parâmetros por `LearningMode`.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "mtd:src.pyfolds.utils.types.ModeConfig.__post_init__",
      "kind": "method",
      "name": "__post_init__",
      "qname": "src.pyfolds.utils.types.ModeConfig.__post_init__",
      "file": "src/pyfolds/utils/types.py",
      "line": 102,
      "doc": "Valida configuração.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.types.ModeConfig.get_learning_rate",
      "kind": "method",
      "name": "get_learning_rate",
      "qname": "src.pyfolds.utils.types.ModeConfig.get_learning_rate",
      "file": "src/pyfolds/utils/types.py",
      "line": 111,
      "doc": "Retorna learning rate efetivo para o modo.",
      "params": [
        "self",
        "base_lr",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.types.ModeConfig.get_consolidation_factor",
      "kind": "method",
      "name": "get_consolidation_factor",
      "qname": "src.pyfolds.utils.types.ModeConfig.get_consolidation_factor",
      "file": "src/pyfolds/utils/types.py",
      "line": 119,
      "doc": "Retorna fator de consolidação no modo sono.",
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.utils.types.ModeConfig.from_learning_mode",
      "kind": "method",
      "name": "from_learning_mode",
      "qname": "src.pyfolds.utils.types.ModeConfig.from_learning_mode",
      "file": "src/pyfolds/utils/types.py",
      "line": 126,
      "doc": "Cria config com foco no modo informado (compatibilidade).",
      "params": [
        "cls",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "cls:src.pyfolds.utils.types.AdaptationOutput",
      "kind": "class",
      "name": "AdaptationOutput",
      "qname": "src.pyfolds.utils.types.AdaptationOutput",
      "file": "src/pyfolds/utils/types.py",
      "line": 152,
      "doc": "Output de _apply_adaptation.",
      "params": [],
      "returns": null,
      "bases": [
        "NamedTuple"
      ],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.utils.types.AdaptationConfig",
      "kind": "class",
      "name": "AdaptationConfig",
      "qname": "src.pyfolds.utils.types.AdaptationConfig",
      "file": "src/pyfolds/utils/types.py",
      "line": 160,
      "doc": "Configuração para adaptação de neurônios.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "mtd:src.pyfolds.utils.types.AdaptationConfig.validate",
      "kind": "method",
      "name": "validate",
      "qname": "src.pyfolds.utils.types.AdaptationConfig.validate",
      "file": "src/pyfolds/utils/types.py",
      "line": 175,
      "doc": "Valida parâmetros.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.utils.validation",
      "kind": "module",
      "name": "validation",
      "qname": "src.pyfolds.utils.validation",
      "file": "src/pyfolds/utils/validation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.validation.validate_device_consistency",
      "kind": "function",
      "name": "validate_device_consistency",
      "qname": "src.pyfolds.utils.validation.validate_device_consistency",
      "file": "src/pyfolds/utils/validation.py",
      "line": 11,
      "doc": "Valida se todos os tensores informados estão no mesmo device.\n\nArgs:\n    *tensors: Tensors opcionais a serem validados.\n\nReturns:\n    O ``torch.device`` compartilhado pelos tensores válidos.\n\nRaises:\n    ValueError: Se nenhum tensor for informado.\n    RuntimeError: Se houver inconsistência de devices.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:src.pyfolds.utils.validation.validate_input",
      "kind": "function",
      "name": "validate_input",
      "qname": "src.pyfolds.utils.validation.validate_input",
      "file": "src/pyfolds/utils/validation.py",
      "line": 36,
      "doc": "Decorator para validação de tensores de entrada.\n\nArgs:\n    expected_ndim: Número esperado de dimensões.\n    expected_shape_fn: Função que recebe ``self`` e retorna shape esperado\n        para os eixos [dendrites, synapses].\n    value_range: Faixa permitida para os valores do tensor.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.wave",
      "kind": "module",
      "name": "wave",
      "qname": "src.pyfolds.wave",
      "file": "src/pyfolds/wave/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.wave.config",
      "kind": "module",
      "name": "config",
      "qname": "src.pyfolds.wave.config",
      "file": "src/pyfolds/wave/config.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.wave.config.MPJRDWaveConfig",
      "kind": "class",
      "name": "MPJRDWaveConfig",
      "qname": "src.pyfolds.wave.config.MPJRDWaveConfig",
      "file": "src/pyfolds/wave/config.py",
      "line": 10,
      "doc": "Extensão de configuração para codificação por fase/frequência.\n\nEste neurônio implementa codificação temporal via oscilações (WAVE)\nusando fase e frequência para representação distribuída de informação.\n\nReferências:\n    Brette, R. (2012). Computing with neurons.\n    Körding, K. P., & König, P. (2000).",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDConfig"
      ],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "mtd:src.pyfolds.wave.config.MPJRDWaveConfig.__post_init__",
      "kind": "method",
      "name": "__post_init__",
      "qname": "src.pyfolds.wave.config.MPJRDWaveConfig.__post_init__",
      "file": "src/pyfolds/wave/config.py",
      "line": 35,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:src.pyfolds.wave.neuron",
      "kind": "module",
      "name": "neuron",
      "qname": "src.pyfolds.wave.neuron",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "kind": "class",
      "name": "MPJRDWaveNeuron",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 14,
      "doc": "Neurônio v3.0 com saída oscilatória em quadratura.",
      "params": [],
      "returns": null,
      "bases": [
        "MPJRDNeuron"
      ],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron.__init__",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 17,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._frequency_for_class",
      "kind": "method",
      "name": "_frequency_for_class",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron._frequency_for_class",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 26,
      "doc": null,
      "params": [
        "self",
        "class_idx"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_phase",
      "kind": "method",
      "name": "_compute_phase",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_phase",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 36,
      "doc": null,
      "params": [
        "self",
        "u"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_latency",
      "kind": "method",
      "name": "_compute_latency",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_latency",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 42,
      "doc": null,
      "params": [
        "self",
        "amplitude"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._generate_wave_output",
      "kind": "method",
      "name": "_generate_wave_output",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron._generate_wave_output",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 45,
      "doc": null,
      "params": [
        "self",
        "amplitude",
        "phase",
        "frequency_hz",
        "t"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.forward",
      "kind": "method",
      "name": "forward",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron.forward",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 64,
      "doc": null,
      "params": [
        "self",
        "x",
        "reward",
        "mode",
        "collect_stats",
        "target_class",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "validate_input(expected_ndim=3, expected_shape_fn=lambda self: (self.cfg.n_dendrites, self.cfg.n_synapses_per_dendrite))"
      ]
    },
    {
      "id": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.apply_plasticity",
      "kind": "method",
      "name": "apply_plasticity",
      "qname": "src.pyfolds.wave.neuron.MPJRDWaveNeuron.apply_plasticity",
      "file": "src/pyfolds/wave/neuron.py",
      "line": 195,
      "doc": null,
      "params": [
        "self",
        "dt",
        "reward"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "torch.no_grad()"
      ]
    },
    {
      "id": "mod:tests",
      "kind": "module",
      "name": "tests",
      "qname": "tests",
      "file": "tests/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.checkpoint",
      "kind": "module",
      "name": "checkpoint",
      "qname": "tests.checkpoint",
      "file": "tests/checkpoint.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.checkpoint.CheckpointMixin",
      "kind": "class",
      "name": "CheckpointMixin",
      "qname": "tests.checkpoint.CheckpointMixin",
      "file": "tests/checkpoint.py",
      "line": 12,
      "doc": "Mixin para adicionar funcionalidade de checkpoint a qualquer módulo.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.checkpoint.CheckpointMixin.save",
      "kind": "method",
      "name": "save",
      "qname": "tests.checkpoint.CheckpointMixin.save",
      "file": "tests/checkpoint.py",
      "line": 15,
      "doc": "Salva checkpoint completo do modelo.\n\nArgs:\n    path: Caminho para salvar (.pt ou .pth)\n    metrics: Métricas adicionais para salvar\n    metadata: Metadados extras\n    include_optimizer: Se True, tenta salvar optimizer se existir\n    \nReturns:\n    Caminho absoluto do arquivo salvo",
      "params": [
        "self",
        "path",
        "metrics",
        "metadata",
        "include_optimizer"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.checkpoint.CheckpointMixin.load",
      "kind": "method",
      "name": "load",
      "qname": "tests.checkpoint.CheckpointMixin.load",
      "file": "tests/checkpoint.py",
      "line": 81,
      "doc": "Carrega modelo a partir de checkpoint.\n\nArgs:\n    path: Caminho do checkpoint\n    map_location: Device para carregar (cpu, cuda, etc)\n    **kwargs: Argumentos extras para o construtor\n    \nReturns:\n    Instância do modelo carregada",
      "params": [
        "cls",
        "path",
        "map_location"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ]
    },
    {
      "id": "mtd:tests.checkpoint.CheckpointMixin.save_weights_only",
      "kind": "method",
      "name": "save_weights_only",
      "qname": "tests.checkpoint.CheckpointMixin.save_weights_only",
      "file": "tests/checkpoint.py",
      "line": 122,
      "doc": "Salva apenas os pesos (sem configuração).",
      "params": [
        "self",
        "path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.checkpoint.CheckpointMixin.load_weights_only",
      "kind": "method",
      "name": "load_weights_only",
      "qname": "tests.checkpoint.CheckpointMixin.load_weights_only",
      "file": "tests/checkpoint.py",
      "line": 128,
      "doc": "Carrega apenas os pesos.",
      "params": [
        "self",
        "path",
        "strict"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.conftest",
      "kind": "module",
      "name": "conftest",
      "qname": "tests.conftest",
      "file": "tests/conftest.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.conftest._module_requires_torch",
      "kind": "function",
      "name": "_module_requires_torch",
      "qname": "tests.conftest._module_requires_torch",
      "file": "tests/conftest.py",
      "line": 25,
      "doc": "Define se um módulo de teste depende de PyTorch.",
      "params": [
        "path"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "lru_cache(maxsize=1)"
      ]
    },
    {
      "id": "fn:tests.conftest.pytest_configure",
      "kind": "function",
      "name": "pytest_configure",
      "qname": "tests.conftest.pytest_configure",
      "file": "tests/conftest.py",
      "line": 43,
      "doc": null,
      "params": [
        "config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.conftest.pytest_report_header",
      "kind": "function",
      "name": "pytest_report_header",
      "qname": "tests.conftest.pytest_report_header",
      "file": "tests/conftest.py",
      "line": 50,
      "doc": null,
      "params": [
        "config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.conftest.pytest_collection_modifyitems",
      "kind": "function",
      "name": "pytest_collection_modifyitems",
      "qname": "tests.conftest.pytest_collection_modifyitems",
      "file": "tests/conftest.py",
      "line": 56,
      "doc": null,
      "params": [
        "config",
        "items"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.conftest.torch_module",
      "kind": "function",
      "name": "torch_module",
      "qname": "tests.conftest.torch_module",
      "file": "tests/conftest.py",
      "line": 68,
      "doc": "Módulo torch disponível para testes dependentes de backend.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest._core_symbols",
      "kind": "function",
      "name": "_core_symbols",
      "qname": "tests.conftest._core_symbols",
      "file": "tests/conftest.py",
      "line": 74,
      "doc": "Carrega símbolos de core apenas quando torch está disponível.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.small_config",
      "kind": "function",
      "name": "small_config",
      "qname": "tests.conftest.small_config",
      "file": "tests/conftest.py",
      "line": 83,
      "doc": "Configuração pequena para testes rápidos.",
      "params": [
        "_core_symbols"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.full_config",
      "kind": "function",
      "name": "full_config",
      "qname": "tests.conftest.full_config",
      "file": "tests/conftest.py",
      "line": 94,
      "doc": "Configuração completa para testes de mecanismos avançados.",
      "params": [
        "_core_symbols"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.tiny_config",
      "kind": "function",
      "name": "tiny_config",
      "qname": "tests.conftest.tiny_config",
      "file": "tests/conftest.py",
      "line": 105,
      "doc": "Configuração mínima para testes de unidade.",
      "params": [
        "_core_symbols"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.small_neuron",
      "kind": "function",
      "name": "small_neuron",
      "qname": "tests.conftest.small_neuron",
      "file": "tests/conftest.py",
      "line": 116,
      "doc": "Neurônio com configuração pequena.",
      "params": [
        "small_config",
        "_core_symbols"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.device",
      "kind": "function",
      "name": "device",
      "qname": "tests.conftest.device",
      "file": "tests/conftest.py",
      "line": 123,
      "doc": "Device para testes (CPU sempre).",
      "params": [
        "torch_module"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "fn:tests.conftest.batch_size",
      "kind": "function",
      "name": "batch_size",
      "qname": "tests.conftest.batch_size",
      "file": "tests/conftest.py",
      "line": 129,
      "doc": "Batch size padrão para testes.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.fixture"
      ]
    },
    {
      "id": "mod:tests.integration",
      "kind": "module",
      "name": "integration",
      "qname": "tests.integration",
      "file": "tests/integration/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.integration.test_advanced_integration",
      "kind": "module",
      "name": "test_advanced_integration",
      "qname": "tests.integration.test_advanced_integration",
      "file": "tests/integration/test_advanced_integration.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.integration.test_advanced_integration.test_all_mixins_together_smoke",
      "kind": "function",
      "name": "test_all_mixins_together_smoke",
      "qname": "tests.integration.test_advanced_integration.test_all_mixins_together_smoke",
      "file": "tests/integration/test_advanced_integration.py",
      "line": 9,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.integration.test_mnist_file_logging",
      "kind": "module",
      "name": "test_mnist_file_logging",
      "qname": "tests.integration.test_mnist_file_logging",
      "file": "tests/integration/test_mnist_file_logging.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.integration.test_mnist_file_logging.test_pyfolds_imports_are_stable",
      "kind": "function",
      "name": "test_pyfolds_imports_are_stable",
      "qname": "tests.integration.test_mnist_file_logging.test_pyfolds_imports_are_stable",
      "file": "tests/integration/test_mnist_file_logging.py",
      "line": 10,
      "doc": "Validate direct/advanced imports to detect circular import regressions.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.integration.test_mnist_file_logging.test_training_script_runs_end_to_end",
      "kind": "function",
      "name": "test_training_script_runs_end_to_end",
      "qname": "tests.integration.test_mnist_file_logging.test_training_script_runs_end_to_end",
      "file": "tests/integration/test_mnist_file_logging.py",
      "line": 18,
      "doc": "Run a tiny end-to-end training and ensure log file is produced.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.integration.test_neuron_advanced",
      "kind": "module",
      "name": "test_neuron_advanced",
      "qname": "tests.integration.test_neuron_advanced",
      "file": "tests/integration/test_neuron_advanced.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.integration.test_neuron_advanced.TestAdvancedNeuron",
      "kind": "class",
      "name": "TestAdvancedNeuron",
      "qname": "tests.integration.test_neuron_advanced.TestAdvancedNeuron",
      "file": "tests/integration/test_neuron_advanced.py",
      "line": 9,
      "doc": "Test advanced neuron with all features.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.integration"
      ]
    },
    {
      "id": "mtd:tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_full_pipeline",
      "kind": "method",
      "name": "test_full_pipeline",
      "qname": "tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_full_pipeline",
      "file": "tests/integration/test_neuron_advanced.py",
      "line": 12,
      "doc": "Test complete pipeline.",
      "params": [
        "self",
        "full_config",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_backprop_disabled_does_not_apply_dendritic_gain",
      "kind": "method",
      "name": "test_backprop_disabled_does_not_apply_dendritic_gain",
      "qname": "tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_backprop_disabled_does_not_apply_dendritic_gain",
      "file": "tests/integration/test_neuron_advanced.py",
      "line": 33,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.integration.test_temporal_sequence_stability",
      "kind": "module",
      "name": "test_temporal_sequence_stability",
      "qname": "tests.integration.test_temporal_sequence_stability",
      "file": "tests/integration/test_temporal_sequence_stability.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.integration.test_temporal_sequence_stability.forward_sequence",
      "kind": "function",
      "name": "forward_sequence",
      "qname": "tests.integration.test_temporal_sequence_stability.forward_sequence",
      "file": "tests/integration/test_temporal_sequence_stability.py",
      "line": 11,
      "doc": "Executa sequência temporal chamando step/forward em cada timestep.\n\nx_seq: [T, B, D, S]",
      "params": [
        "neuron",
        "x_seq",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.integration.test_temporal_sequence_stability.test_forward_sequence_torch_stability_minimal_criteria",
      "kind": "function",
      "name": "test_forward_sequence_torch_stability_minimal_criteria",
      "qname": "tests.integration.test_temporal_sequence_stability.test_forward_sequence_torch_stability_minimal_criteria",
      "file": "tests/integration/test_temporal_sequence_stability.py",
      "line": 23,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.integration"
      ]
    },
    {
      "id": "fn:tests.integration.test_temporal_sequence_stability.test_tf_sequence_equivalent_stability_minimal_criteria",
      "kind": "function",
      "name": "test_tf_sequence_equivalent_stability_minimal_criteria",
      "qname": "tests.integration.test_temporal_sequence_stability.test_tf_sequence_equivalent_stability_minimal_criteria",
      "file": "tests/integration/test_temporal_sequence_stability.py",
      "line": 63,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.integration",
        "pytest.mark.tf",
        "pytest.mark.skipif(importlib.util.find_spec('tensorflow') is None, reason='TensorFlow não instalado neste ambiente.')"
      ]
    },
    {
      "id": "mod:tests.integration.test_training_loop",
      "kind": "module",
      "name": "test_training_loop",
      "qname": "tests.integration.test_training_loop",
      "file": "tests/integration/test_training_loop.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.integration.test_training_loop.TestTrainingLoop",
      "kind": "class",
      "name": "TestTrainingLoop",
      "qname": "tests.integration.test_training_loop.TestTrainingLoop",
      "file": "tests/integration/test_training_loop.py",
      "line": 9,
      "doc": "Test complete training loop.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.integration"
      ]
    },
    {
      "id": "mtd:tests.integration.test_training_loop.TestTrainingLoop.test_batch_training",
      "kind": "method",
      "name": "test_batch_training",
      "qname": "tests.integration.test_training_loop.TestTrainingLoop.test_batch_training",
      "file": "tests/integration/test_training_loop.py",
      "line": 12,
      "doc": "Test batch training loop.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.performance",
      "kind": "module",
      "name": "performance",
      "qname": "tests.performance",
      "file": "tests/performance/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.performance.test_batch_speed",
      "kind": "module",
      "name": "test_batch_speed",
      "qname": "tests.performance.test_batch_speed",
      "file": "tests/performance/test_batch_speed.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.performance.test_batch_speed.TestBatchSpeed",
      "kind": "class",
      "name": "TestBatchSpeed",
      "qname": "tests.performance.test_batch_speed.TestBatchSpeed",
      "file": "tests/performance/test_batch_speed.py",
      "line": 11,
      "doc": "Test batch processing speed.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.performance",
        "pytest.mark.slow"
      ]
    },
    {
      "id": "mtd:tests.performance.test_batch_speed.TestBatchSpeed.test_forward_speed",
      "kind": "method",
      "name": "test_forward_speed",
      "qname": "tests.performance.test_batch_speed.TestBatchSpeed.test_forward_speed",
      "file": "tests/performance/test_batch_speed.py",
      "line": 14,
      "doc": "Measure forward pass speed.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.performance.test_memory_usage",
      "kind": "module",
      "name": "test_memory_usage",
      "qname": "tests.performance.test_memory_usage",
      "file": "tests/performance/test_memory_usage.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.performance.test_memory_usage.TestMemoryUsage",
      "kind": "class",
      "name": "TestMemoryUsage",
      "qname": "tests.performance.test_memory_usage.TestMemoryUsage",
      "file": "tests/performance/test_memory_usage.py",
      "line": 9,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.performance.test_memory_usage.TestMemoryUsage.test_memory_leak",
      "kind": "method",
      "name": "test_memory_leak",
      "qname": "tests.performance.test_memory_usage.TestMemoryUsage.test_memory_leak",
      "file": "tests/performance/test_memory_usage.py",
      "line": 10,
      "doc": "Verifica limite de uso de memória de pico em workload curto.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.test_concurrent_reads",
      "kind": "module",
      "name": "test_concurrent_reads",
      "qname": "tests.test_concurrent_reads",
      "file": "tests/test_concurrent_reads.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_concurrent_reads._build_neuron",
      "kind": "function",
      "name": "_build_neuron",
      "qname": "tests.test_concurrent_reads._build_neuron",
      "file": "tests/test_concurrent_reads.py",
      "line": 11,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_concurrent_reads._read_signature",
      "kind": "function",
      "name": "_read_signature",
      "qname": "tests.test_concurrent_reads._read_signature",
      "file": "tests/test_concurrent_reads.py",
      "line": 22,
      "doc": null,
      "params": [
        "path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_concurrent_reads.test_parallel_reads_are_consistent",
      "kind": "function",
      "name": "test_parallel_reads_are_consistent",
      "qname": "tests.test_concurrent_reads.test_parallel_reads_are_consistent",
      "file": "tests/test_concurrent_reads.py",
      "line": 35,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.concurrency"
      ]
    },
    {
      "id": "mod:tests.test_corruption_detection",
      "kind": "module",
      "name": "test_corruption_detection",
      "qname": "tests.test_corruption_detection",
      "file": "tests/test_corruption_detection.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection._build_neuron",
      "kind": "function",
      "name": "_build_neuron",
      "qname": "tests.test_corruption_detection._build_neuron",
      "file": "tests/test_corruption_detection.py",
      "line": 11,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection._write_base_fold",
      "kind": "function",
      "name": "_write_base_fold",
      "qname": "tests.test_corruption_detection._write_base_fold",
      "file": "tests/test_corruption_detection.py",
      "line": 22,
      "doc": null,
      "params": [
        "path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection.test_bit_flip_is_detected",
      "kind": "function",
      "name": "test_bit_flip_is_detected",
      "qname": "tests.test_corruption_detection.test_bit_flip_is_detected",
      "file": "tests/test_corruption_detection.py",
      "line": 34,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection.test_truncation_is_detected",
      "kind": "function",
      "name": "test_truncation_is_detected",
      "qname": "tests.test_corruption_detection.test_truncation_is_detected",
      "file": "tests/test_corruption_detection.py",
      "line": 53,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection.test_invalid_magic_is_rejected",
      "kind": "function",
      "name": "test_invalid_magic_is_rejected",
      "qname": "tests.test_corruption_detection.test_invalid_magic_is_rejected",
      "file": "tests/test_corruption_detection.py",
      "line": 65,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection.test_huge_index_len_dos_guard",
      "kind": "function",
      "name": "test_huge_index_len_dos_guard",
      "qname": "tests.test_corruption_detection.test_huge_index_len_dos_guard",
      "file": "tests/test_corruption_detection.py",
      "line": 78,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_corruption_detection.test_partial_read_raises_eoferror",
      "kind": "function",
      "name": "test_partial_read_raises_eoferror",
      "qname": "tests.test_corruption_detection.test_partial_read_raises_eoferror",
      "file": "tests/test_corruption_detection.py",
      "line": 88,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.test_fold_corruption",
      "kind": "module",
      "name": "test_fold_corruption",
      "qname": "tests.test_fold_corruption",
      "file": "tests/test_fold_corruption.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_fold_corruption.test_fold_corruption_is_detected",
      "kind": "function",
      "name": "test_fold_corruption_is_detected",
      "qname": "tests.test_fold_corruption.test_fold_corruption_is_detected",
      "file": "tests/test_fold_corruption.py",
      "line": 13,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.test_fold_fuzz",
      "kind": "module",
      "name": "test_fold_fuzz",
      "qname": "tests.test_fold_fuzz",
      "file": "tests/test_fold_fuzz.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_fold_fuzz.test_fold_reader_rejects_random_payload",
      "kind": "function",
      "name": "test_fold_reader_rejects_random_payload",
      "qname": "tests.test_fold_fuzz.test_fold_reader_rejects_random_payload",
      "file": "tests/test_fold_fuzz.py",
      "line": 13,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.test_stress_long",
      "kind": "module",
      "name": "test_stress_long",
      "qname": "tests.test_stress_long",
      "file": "tests/test_stress_long.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.test_stress_long.test_100k_steps_stability_and_memory_signals",
      "kind": "function",
      "name": "test_100k_steps_stability_and_memory_signals",
      "qname": "tests.test_stress_long.test_100k_steps_stability_and_memory_signals",
      "file": "tests/test_stress_long.py",
      "line": 16,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.slow",
        "pytest.mark.stress"
      ]
    },
    {
      "id": "mod:tests.tools.test_batch_create_issues",
      "kind": "module",
      "name": "test_batch_create_issues",
      "qname": "tests.tools.test_batch_create_issues",
      "file": "tests/tools/test_batch_create_issues.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.tools.test_batch_create_issues.test_validate_batch_structure_duplicate_ids",
      "kind": "function",
      "name": "test_validate_batch_structure_duplicate_ids",
      "qname": "tests.tools.test_batch_create_issues.test_validate_batch_structure_duplicate_ids",
      "file": "tests/tools/test_batch_create_issues.py",
      "line": 4,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.tools.test_create_issue_report",
      "kind": "module",
      "name": "test_create_issue_report",
      "qname": "tests.tools.test_create_issue_report",
      "file": "tests/tools/test_create_issue_report.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.tools.test_create_issue_report.test_generate_yaml_frontmatter_contains_id",
      "kind": "function",
      "name": "test_generate_yaml_frontmatter_contains_id",
      "qname": "tests.tools.test_create_issue_report.test_generate_yaml_frontmatter_contains_id",
      "file": "tests/tools/test_create_issue_report.py",
      "line": 4,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.tools.test_link_validation",
      "kind": "module",
      "name": "test_link_validation",
      "qname": "tests.tools.test_link_validation",
      "file": "tests/tools/test_link_validation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.tools.test_link_validation.test_validate_links_missing",
      "kind": "function",
      "name": "test_validate_links_missing",
      "qname": "tests.tools.test_link_validation.test_validate_links_missing",
      "file": "tests/tools/test_link_validation.py",
      "line": 4,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.tools.test_sync_hub_auto",
      "kind": "module",
      "name": "test_sync_hub_auto",
      "qname": "tests.tools.test_sync_hub_auto",
      "file": "tests/tools/test_sync_hub_auto.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.tools.test_sync_hub_auto.test_status_to_emoji_done",
      "kind": "function",
      "name": "test_status_to_emoji_done",
      "qname": "tests.tools.test_sync_hub_auto.test_status_to_emoji_done",
      "file": "tests/tools/test_sync_hub_auto.py",
      "line": 4,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.tools.test_validate_issue_format",
      "kind": "module",
      "name": "test_validate_issue_format",
      "qname": "tests.tools.test_validate_issue_format",
      "file": "tests/tools/test_validate_issue_format.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.tools.test_validate_issue_format.test_validate_structure_filename",
      "kind": "function",
      "name": "test_validate_structure_filename",
      "qname": "tests.tools.test_validate_issue_format.test_validate_structure_filename",
      "file": "tests/tools/test_validate_issue_format.py",
      "line": 6,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.training.mnist_cifar_training_reference",
      "kind": "module",
      "name": "mnist_cifar_training_reference",
      "qname": "tests.training.mnist_cifar_training_reference",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.training.mnist_cifar_training_reference.TrainingConfig",
      "kind": "class",
      "name": "TrainingConfig",
      "qname": "tests.training.mnist_cifar_training_reference.TrainingConfig",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 22,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass"
      ]
    },
    {
      "id": "cls:tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "kind": "class",
      "name": "PyFoldsMLP",
      "qname": "tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 31,
      "doc": "MLP simples com gate de ativação baseado em MPJRDNeuron.",
      "params": [],
      "returns": null,
      "bases": [
        "nn.Module"
      ],
      "decorators": []
    },
    {
      "id": "mtd:tests.training.mnist_cifar_training_reference.PyFoldsMLP.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "tests.training.mnist_cifar_training_reference.PyFoldsMLP.__init__",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 34,
      "doc": null,
      "params": [
        "self",
        "input_dim",
        "hidden_dim",
        "num_classes"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.training.mnist_cifar_training_reference.PyFoldsMLP.forward",
      "kind": "method",
      "name": "forward",
      "qname": "tests.training.mnist_cifar_training_reference.PyFoldsMLP.forward",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 42,
      "doc": null,
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.training.mnist_cifar_training_reference.build_dataset",
      "kind": "function",
      "name": "build_dataset",
      "qname": "tests.training.mnist_cifar_training_reference.build_dataset",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 54,
      "doc": null,
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.training.mnist_cifar_training_reference.train_reference",
      "kind": "function",
      "name": "train_reference",
      "qname": "tests.training.mnist_cifar_training_reference.train_reference",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 84,
      "doc": null,
      "params": [
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.training.mnist_cifar_training_reference.evaluate",
      "kind": "function",
      "name": "evaluate",
      "qname": "tests.training.mnist_cifar_training_reference.evaluate",
      "file": "tests/training/mnist_cifar_training_reference.py",
      "line": 111,
      "doc": null,
      "params": [
        "model",
        "loader",
        "device"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit",
      "kind": "module",
      "name": "unit",
      "qname": "tests.unit",
      "file": "tests/unit/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced",
      "kind": "module",
      "name": "advanced",
      "qname": "tests.unit.advanced",
      "file": "tests/unit/advanced/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_adaptation",
      "kind": "module",
      "name": "test_adaptation",
      "qname": "tests.unit.advanced.test_adaptation",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "kind": "class",
      "name": "TestAdaptationMixin",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 8,
      "doc": "Test adaptation mechanism (SFA).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_initialization",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 11,
      "doc": "Test adaptation parameters.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_decay",
      "kind": "method",
      "name": "test_adaptation_decay",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_decay",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 20,
      "doc": "Test adaptation current decay.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_increment",
      "kind": "method",
      "name": "test_adaptation_increment",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_increment",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 45,
      "doc": "Test adaptation increment with spikes.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_respects_string_inference_mode",
      "kind": "method",
      "name": "test_adaptation_respects_string_inference_mode",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_respects_string_inference_mode",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 70,
      "doc": "mode='inference' (str) não deve aplicar adaptação.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_forward_updates_u_for_downstream_mixins",
      "kind": "method",
      "name": "test_forward_updates_u_for_downstream_mixins",
      "qname": "tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_forward_updates_u_for_downstream_mixins",
      "file": "tests/unit/advanced/test_adaptation.py",
      "line": 84,
      "doc": "Adaptação deve atualizar campo `u` para mixins posteriores (e.g., refratário).",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_backprop",
      "kind": "module",
      "name": "test_backprop",
      "qname": "tests.unit.advanced.test_backprop",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "kind": "class",
      "name": "TestBackpropMixin",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 8,
      "doc": "Test dendritic backpropagation.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin.test_initialization",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 11,
      "doc": "Test backprop parameters.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_backprop_queue",
      "kind": "method",
      "name": "test_backprop_queue",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin.test_backprop_queue",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 20,
      "doc": "Test backprop event queue.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_dendrite_amplification_decay",
      "kind": "method",
      "name": "test_dendrite_amplification_decay",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin.test_dendrite_amplification_decay",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 34,
      "doc": "Test amplification decay when there are pending events.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_bap_proportional_uses_dendritic_contribution",
      "kind": "method",
      "name": "test_bap_proportional_uses_dendritic_contribution",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin.test_bap_proportional_uses_dendritic_contribution",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 64,
      "doc": "Com bap_proportional=True, ganho deve seguir contribuição.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_time_counter_advances_only_after_forward",
      "kind": "method",
      "name": "test_time_counter_advances_only_after_forward",
      "qname": "tests.unit.advanced.test_backprop.TestBackpropMixin.test_time_counter_advances_only_after_forward",
      "file": "tests/unit/advanced/test_backprop.py",
      "line": 87,
      "doc": "Semântica temporal unificada: incremento ao final do passo.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_inhibition",
      "kind": "module",
      "name": "test_inhibition",
      "qname": "tests.unit.advanced.test_inhibition",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "kind": "class",
      "name": "TestInhibitionLayer",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 8,
      "doc": "Test inhibition layer.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_initialization",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 11,
      "doc": "Test layer initialization.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_lateral_kernel",
      "kind": "method",
      "name": "test_lateral_kernel",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_lateral_kernel",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 29,
      "doc": "Test lateral kernel properties.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_forward_feedforward",
      "kind": "method",
      "name": "test_forward_feedforward",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_forward_feedforward",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 46,
      "doc": "Test feedforward E→I.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_apply_inhibition_accepts_u_values",
      "kind": "method",
      "name": "test_apply_inhibition_accepts_u_values",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_apply_inhibition_accepts_u_values",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 62,
      "doc": "apply_inhibition deve suportar saída de layer com `u_values`.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_e2i_initialization_is_deterministic",
      "kind": "method",
      "name": "test_e2i_initialization_is_deterministic",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_e2i_initialization_is_deterministic",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 79,
      "doc": "E→I should be reproducible across instances.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_inhibition.TestInhibitionMixin",
      "kind": "class",
      "name": "TestInhibitionMixin",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionMixin",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 92,
      "doc": "Tests for InhibitionMixin guard clauses.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionMixin.test_forward_requires_initialized_inhibition",
      "kind": "method",
      "name": "test_forward_requires_initialized_inhibition",
      "qname": "tests.unit.advanced.test_inhibition.TestInhibitionMixin.test_forward_requires_initialized_inhibition",
      "file": "tests/unit/advanced/test_inhibition.py",
      "line": 95,
      "doc": "Forward should fail fast when inhibition layer is missing.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_refractory",
      "kind": "module",
      "name": "test_refractory",
      "qname": "tests.unit.advanced.test_refractory",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "kind": "class",
      "name": "TestRefractoryMixin",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 8,
      "doc": "Test refractory period.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin.test_initialization",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 11,
      "doc": "Test refractory parameters.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_check_refractory_periods",
      "kind": "method",
      "name": "test_check_refractory_periods",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin.test_check_refractory_periods",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 20,
      "doc": "Absolute and relative windows should be blocked with relative boost only in relative.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_update_refractory",
      "kind": "method",
      "name": "test_update_refractory",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin.test_update_refractory",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 55,
      "doc": "Test last spike time update.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_refractory_blocks_spikes",
      "kind": "method",
      "name": "test_refractory_blocks_spikes",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin.test_refractory_blocks_spikes",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 75,
      "doc": "Absolute refractory window should force spikes to zero.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_forward_increments_time_once",
      "kind": "method",
      "name": "test_forward_increments_time_once",
      "qname": "tests.unit.advanced.test_refractory.TestRefractoryMixin.test_forward_increments_time_once",
      "file": "tests/unit/advanced/test_refractory.py",
      "line": 97,
      "doc": "Backprop + refractory chain deve incrementar tempo uma única vez por passo.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_short_term",
      "kind": "module",
      "name": "test_short_term",
      "qname": "tests.unit.advanced.test_short_term",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "kind": "class",
      "name": "TestShortTermDynamicsMixin",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 8,
      "doc": "Test short-term plasticity (STP).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_initialization",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 11,
      "doc": "Test STP parameters.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_no_spikes",
      "kind": "method",
      "name": "test_update_no_spikes",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_no_spikes",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 24,
      "doc": "Test decay without spikes.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_with_spikes",
      "kind": "method",
      "name": "test_update_with_spikes",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_with_spikes",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 50,
      "doc": "Test facilitation with spikes.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_tsodyks_markram_recovery",
      "kind": "method",
      "name": "test_tsodyks_markram_recovery",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_tsodyks_markram_recovery",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 75,
      "doc": "R deve recuperar para próximo de 1 sem estímulo.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_aligns_stp_buffers_to_input_device",
      "kind": "method",
      "name": "test_update_aligns_stp_buffers_to_input_device",
      "qname": "tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_aligns_stp_buffers_to_input_device",
      "file": "tests/unit/advanced/test_short_term.py",
      "line": 90,
      "doc": "Buffers de STP devem acompanhar device da entrada para evitar mismatch.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.advanced.test_stdp",
      "kind": "module",
      "name": "test_stdp",
      "qname": "tests.unit.advanced.test_stdp",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "kind": "class",
      "name": "TestSTDPMixin",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 9,
      "doc": "Test STDP (Spike-Timing Dependent Plasticity).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_initialization",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 12,
      "doc": "Test STDP parameters.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_trace_decay",
      "kind": "method",
      "name": "test_trace_decay",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_trace_decay",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 22,
      "doc": "Test trace decay.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_pre_spike_updates_trace",
      "kind": "method",
      "name": "test_pre_spike_updates_trace",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_pre_spike_updates_trace",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 50,
      "doc": "Test pre-synaptic spike updates trace.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_should_apply_stdp",
      "kind": "method",
      "name": "test_should_apply_stdp",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_should_apply_stdp",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 74,
      "doc": "Test STDP application logic.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_updates_underlying_synapses_online",
      "kind": "method",
      "name": "test_stdp_updates_underlying_synapses_online",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_updates_underlying_synapses_online",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 83,
      "doc": "Online STDP update deve persistir nas sinapses reais.",
      "params": [
        "self",
        "full_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_input_source_raw_vs_stp",
      "kind": "method",
      "name": "test_stdp_input_source_raw_vs_stp",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_input_source_raw_vs_stp",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 101,
      "doc": "raw deve detectar spike pré mesmo quando STP deprime abaixo do limiar.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_ltd_rule_classic_vs_current",
      "kind": "method",
      "name": "test_ltd_rule_classic_vs_current",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_ltd_rule_classic_vs_current",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 133,
      "doc": "classic usa pre_spike; current preserva regra legada dependente de post.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_update_is_batch_size_invariant_for_identical_samples",
      "kind": "method",
      "name": "test_stdp_update_is_batch_size_invariant_for_identical_samples",
      "qname": "tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_update_is_batch_size_invariant_for_identical_samples",
      "file": "tests/unit/advanced/test_stdp.py",
      "line": 172,
      "doc": "Delta sináptico médio não deve escalar linearmente com batch.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core",
      "kind": "module",
      "name": "core",
      "qname": "tests.unit.core",
      "file": "tests/unit/core/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_accumulator",
      "kind": "module",
      "name": "test_accumulator",
      "qname": "tests.unit.core.test_accumulator",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "kind": "class",
      "name": "TestStatisticsAccumulator",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 9,
      "doc": "Test accumulator.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_initialization",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 12,
      "doc": "Test initialization.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate",
      "kind": "method",
      "name": "test_accumulate",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 20,
      "doc": "Test accumulation.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_history_respects_max_len",
      "kind": "method",
      "name": "test_history_respects_max_len",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_history_respects_max_len",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 36,
      "doc": "History must not grow unbounded when enabled.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate_rejects_invalid_shape",
      "kind": "method",
      "name": "test_accumulate_rejects_invalid_shape",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate_rejects_invalid_shape",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 54,
      "doc": "Accumulator should fail fast when input shape is invalid.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_track_extra_accumulates_scalars_and_vectors",
      "kind": "method",
      "name": "test_track_extra_accumulates_scalars_and_vectors",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_track_extra_accumulates_scalars_and_vectors",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 66,
      "doc": "Extra tracked signals should be averaged correctly across batches.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_reset_clears_state_and_history",
      "kind": "method",
      "name": "test_reset_clears_state_and_history",
      "qname": "tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_reset_clears_state_and_history",
      "file": "tests/unit/core/test_accumulator.py",
      "line": 92,
      "doc": "Reset should clear accumulated values and optional history.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_config",
      "kind": "module",
      "name": "test_config",
      "qname": "tests.unit.core.test_config",
      "file": "tests/unit/core/test_config.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "kind": "class",
      "name": "TestMPJRDConfig",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig",
      "file": "tests/unit/core/test_config.py",
      "line": 8,
      "doc": "Test configuration class.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_default_values",
      "kind": "method",
      "name": "test_default_values",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_default_values",
      "file": "tests/unit/core/test_config.py",
      "line": 11,
      "doc": "Test default values.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_custom_values",
      "kind": "method",
      "name": "test_custom_values",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_custom_values",
      "file": "tests/unit/core/test_config.py",
      "line": 17,
      "doc": "Test custom values.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_validation",
      "kind": "method",
      "name": "test_validation",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_validation",
      "file": "tests/unit/core/test_config.py",
      "line": 30,
      "doc": "Test validation.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_validation",
      "kind": "method",
      "name": "test_get_decay_rate_validation",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_validation",
      "file": "tests/unit/core/test_config.py",
      "line": 36,
      "doc": "Tau inválido deve gerar erro explícito.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_negative_dt_validation",
      "kind": "method",
      "name": "test_get_decay_rate_negative_dt_validation",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_negative_dt_validation",
      "file": "tests/unit/core/test_config.py",
      "line": 43,
      "doc": "dt negativo deve gerar erro explícito.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_numerical_safety_validation",
      "kind": "method",
      "name": "test_numerical_safety_validation",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_numerical_safety_validation",
      "file": "tests/unit/core/test_config.py",
      "line": 49,
      "doc": "Config deve validar parâmetros numéricos críticos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_dendritic_integration_validation",
      "kind": "method",
      "name": "test_dendritic_integration_validation",
      "qname": "tests.unit.core.test_config.TestMPJRDConfig.test_dendritic_integration_validation",
      "file": "tests/unit/core/test_config.py",
      "line": 67,
      "doc": "Valida limites dos novos parâmetros de integração dendrítica.",
      "params": [
        "self",
        "kwargs"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.parametrize('kwargs', [{'dendrite_integration_mode': 'invalid'}, {'dendrite_gain': 0.0}, {'theta_dend_ratio': 1.5}, {'shunting_eps': 0.0}, {'shunting_strength': -0.1}])"
      ]
    },
    {
      "id": "fn:tests.unit.core.test_config.test_hebbian_ltd_ratio_must_be_non_negative",
      "kind": "function",
      "name": "test_hebbian_ltd_ratio_must_be_non_negative",
      "qname": "tests.unit.core.test_config.test_hebbian_ltd_ratio_must_be_non_negative",
      "file": "tests/unit/core/test_config.py",
      "line": 73,
      "doc": "Config should reject negative explicit LTD ratio.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_config_advanced_order_flags",
      "kind": "module",
      "name": "test_config_advanced_order_flags",
      "qname": "tests.unit.core.test_config_advanced_order_flags",
      "file": "tests/unit/core/test_config_advanced_order_flags.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_config_advanced_order_flags.test_accepts_stdp_source_and_ltd_rule_flags",
      "kind": "function",
      "name": "test_accepts_stdp_source_and_ltd_rule_flags",
      "qname": "tests.unit.core.test_config_advanced_order_flags.test_accepts_stdp_source_and_ltd_rule_flags",
      "file": "tests/unit/core/test_config_advanced_order_flags.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_config_advanced_order_flags.test_rejects_invalid_order_flags",
      "kind": "function",
      "name": "test_rejects_invalid_order_flags",
      "qname": "tests.unit.core.test_config_advanced_order_flags.test_rejects_invalid_order_flags",
      "file": "tests/unit/core/test_config_advanced_order_flags.py",
      "line": 15,
      "doc": null,
      "params": [
        "kwargs"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.parametrize('kwargs', [{'stdp_input_source': 'invalid'}, {'ltd_rule': 'invalid'}])"
      ]
    },
    {
      "id": "mod:tests.unit.core.test_dendrite",
      "kind": "module",
      "name": "test_dendrite",
      "qname": "tests.unit.core.test_dendrite",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "kind": "class",
      "name": "TestMPJRDDendrite",
      "qname": "tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 8,
      "doc": "Test dendrite.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.core.test_dendrite.TestMPJRDDendrite.test_initialization",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 11,
      "doc": "Test initialization.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_forward",
      "kind": "method",
      "name": "test_forward",
      "qname": "tests.unit.core.test_dendrite.TestMPJRDDendrite.test_forward",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 19,
      "doc": "Test forward pass.",
      "params": [
        "self",
        "small_config",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_u_R_optional_state",
      "kind": "method",
      "name": "test_u_R_optional_state",
      "qname": "tests.unit.core.test_dendrite.TestMPJRDDendrite.test_u_R_optional_state",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 29,
      "doc": "u/R devem ser opcionais e nunca lançar exceção no acesso.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_update_uses_local_pre_rate_per_synapse",
      "kind": "method",
      "name": "test_update_uses_local_pre_rate_per_synapse",
      "qname": "tests.unit.core.test_dendrite.TestMPJRDDendrite.test_update_uses_local_pre_rate_per_synapse",
      "file": "tests/unit/core/test_dendrite.py",
      "line": 43,
      "doc": "Each synapse must receive its own pre-synaptic rate sample.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_factory",
      "kind": "module",
      "name": "test_factory",
      "qname": "tests.unit.core.test_factory",
      "file": "tests/unit/core/test_factory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_factory.test_create_neuron_infers_standard_type",
      "kind": "function",
      "name": "test_create_neuron_infers_standard_type",
      "qname": "tests.unit.core.test_factory.test_create_neuron_infers_standard_type",
      "file": "tests/unit/core/test_factory.py",
      "line": 8,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_factory.test_create_neuron_infers_wave_type",
      "kind": "function",
      "name": "test_create_neuron_infers_wave_type",
      "qname": "tests.unit.core.test_factory.test_create_neuron_infers_wave_type",
      "file": "tests/unit/core/test_factory.py",
      "line": 13,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_factory.test_factory_raises_for_unregistered_type",
      "kind": "function",
      "name": "test_factory_raises_for_unregistered_type",
      "qname": "tests.unit.core.test_factory.test_factory_raises_for_unregistered_type",
      "file": "tests/unit/core/test_factory.py",
      "line": 18,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_health_monitor",
      "kind": "module",
      "name": "test_health_monitor",
      "qname": "tests.unit.core.test_health_monitor",
      "file": "tests/unit/core/test_health_monitor.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_health_monitor.test_health_monitor_runs_and_scores",
      "kind": "function",
      "name": "test_health_monitor_runs_and_scores",
      "qname": "tests.unit.core.test_health_monitor.test_health_monitor_runs_and_scores",
      "file": "tests/unit/core/test_health_monitor.py",
      "line": 8,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_homeostasis",
      "kind": "module",
      "name": "test_homeostasis",
      "qname": "tests.unit.core.test_homeostasis",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "kind": "class",
      "name": "TestHomeostasisController",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 8,
      "doc": "Test homeostasis.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController.test_initialization",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 11,
      "doc": "Test initialization.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_update",
      "kind": "method",
      "name": "test_update",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController.test_update",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 19,
      "doc": "Test update.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_is_stable_accepts_tolerance",
      "kind": "method",
      "name": "test_is_stable_accepts_tolerance",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController.test_is_stable_accepts_tolerance",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 30,
      "doc": "is_stable should accept optional tolerance.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_update_limits_theta_step",
      "kind": "method",
      "name": "test_update_limits_theta_step",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController.test_update_limits_theta_step",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 40,
      "doc": "PID-like update deve limitar variação instantânea de theta.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_dead_neuron_rescue_has_minimum_strength",
      "kind": "method",
      "name": "test_dead_neuron_rescue_has_minimum_strength",
      "qname": "tests.unit.core.test_homeostasis.TestHomeostasisController.test_dead_neuron_rescue_has_minimum_strength",
      "file": "tests/unit/core/test_homeostasis.py",
      "line": 51,
      "doc": "Resgate deve reduzir theta pelo menos 0.05 quando rate=0.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_input_validation_contract",
      "kind": "module",
      "name": "test_input_validation_contract",
      "qname": "tests.unit.core.test_input_validation_contract",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_input_validation_contract._cfg",
      "kind": "function",
      "name": "_cfg",
      "qname": "tests.unit.core.test_input_validation_contract._cfg",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 10,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_input_validation_contract.test_neuron_rejects_non_tensor_input",
      "kind": "function",
      "name": "test_neuron_rejects_non_tensor_input",
      "qname": "tests.unit.core.test_input_validation_contract.test_neuron_rejects_non_tensor_input",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 14,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_input_validation_contract.test_neuron_rejects_input_from_different_device",
      "kind": "function",
      "name": "test_neuron_rejects_input_from_different_device",
      "qname": "tests.unit.core.test_input_validation_contract.test_neuron_rejects_input_from_different_device",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 20,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_input_validation_contract.test_layer_prepare_input_accepts_supported_shapes",
      "kind": "function",
      "name": "test_layer_prepare_input_accepts_supported_shapes",
      "qname": "tests.unit.core.test_input_validation_contract.test_layer_prepare_input_accepts_supported_shapes",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 27,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_input_validation_contract.test_layer_prepare_input_rejects_invalid_shape",
      "kind": "function",
      "name": "test_layer_prepare_input_rejects_invalid_shape",
      "qname": "tests.unit.core.test_input_validation_contract.test_layer_prepare_input_rejects_invalid_shape",
      "file": "tests/unit/core/test_input_validation_contract.py",
      "line": 41,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "kind": "module",
      "name": "test_monitoring_and_checkpoint",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron",
      "kind": "class",
      "name": "DummyNeuron",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 10,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.__init__",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 11,
      "doc": null,
      "params": [
        "self",
        "metrics"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.get_metrics",
      "kind": "method",
      "name": "get_metrics",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.get_metrics",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 14,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_health_check_critical_for_dead_neurons",
      "kind": "function",
      "name": "test_health_check_critical_for_dead_neurons",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.test_health_check_critical_for_dead_neurons",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 18,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_health_check_uses_fallback_metrics_from_get_metrics_contract",
      "kind": "function",
      "name": "test_health_check_uses_fallback_metrics_from_get_metrics_contract",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.test_health_check_uses_fallback_metrics_from_get_metrics_contract",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 27,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_save_and_load",
      "kind": "function",
      "name": "test_versioned_checkpoint_save_and_load",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_save_and_load",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 41,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_metadata_created_at_is_utc",
      "kind": "function",
      "name": "test_versioned_checkpoint_metadata_created_at_is_utc",
      "qname": "tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_metadata_created_at_is_utc",
      "file": "tests/unit/core/test_monitoring_and_checkpoint.py",
      "line": 54,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_neuromodulation",
      "kind": "module",
      "name": "test_neuromodulation",
      "qname": "tests.unit.core.test_neuromodulation",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "kind": "class",
      "name": "TestNeuromodulator",
      "qname": "tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 8,
      "doc": "Test neuromodulator.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_external_mode",
      "kind": "method",
      "name": "test_external_mode",
      "qname": "tests.unit.core.test_neuromodulation.TestNeuromodulator.test_external_mode",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 11,
      "doc": "Test external mode.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_surprise_mode",
      "kind": "method",
      "name": "test_surprise_mode",
      "qname": "tests.unit.core.test_neuromodulation.TestNeuromodulator.test_surprise_mode",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 21,
      "doc": "Test surprise mode.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_rejects_non_finite_inputs",
      "kind": "method",
      "name": "test_rejects_non_finite_inputs",
      "qname": "tests.unit.core.test_neuromodulation.TestNeuromodulator.test_rejects_non_finite_inputs",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 35,
      "doc": "Non-finite scalars must fail fast to avoid unstable dynamics.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_infers_output_device_from_tensor_inputs",
      "kind": "method",
      "name": "test_infers_output_device_from_tensor_inputs",
      "qname": "tests.unit.core.test_neuromodulation.TestNeuromodulator.test_infers_output_device_from_tensor_inputs",
      "file": "tests/unit/core/test_neuromodulation.py",
      "line": 48,
      "doc": "Output tensor should stay on same device when device arg is omitted.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_neuron",
      "kind": "module",
      "name": "test_neuron",
      "qname": "tests.unit.core.test_neuron",
      "file": "tests/unit/core/test_neuron.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "kind": "class",
      "name": "TestMPJRDNeuron",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron",
      "file": "tests/unit/core/test_neuron.py",
      "line": 9,
      "doc": "Test basic neuron.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_initialization",
      "file": "tests/unit/core/test_neuron.py",
      "line": 12,
      "doc": "Test initialization.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward",
      "kind": "method",
      "name": "test_forward",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward",
      "file": "tests/unit/core/test_neuron.py",
      "line": 18,
      "doc": "Test forward pass.",
      "params": [
        "self",
        "small_config",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_shunting_exposes_dendritic_contribution",
      "kind": "method",
      "name": "test_nmda_shunting_exposes_dendritic_contribution",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_shunting_exposes_dendritic_contribution",
      "file": "tests/unit/core/test_neuron.py",
      "line": 30,
      "doc": "Modo nmda_shunting deve retornar contribuição por dendrito.",
      "params": [
        "self",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_step_alias",
      "kind": "method",
      "name": "test_step_alias",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_step_alias",
      "file": "tests/unit/core/test_neuron.py",
      "line": 49,
      "doc": "`step` deve delegar para `forward` preservando a API pública.",
      "params": [
        "self",
        "small_config",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward_mode_override_is_reported",
      "kind": "method",
      "name": "test_forward_mode_override_is_reported",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward_mode_override_is_reported",
      "file": "tests/unit/core/test_neuron.py",
      "line": 59,
      "doc": "`forward(..., mode=...)` deve refletir o modo efetivo no retorno.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_online_plasticity_updates_when_not_deferred",
      "kind": "method",
      "name": "test_online_plasticity_updates_when_not_deferred",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_online_plasticity_updates_when_not_deferred",
      "file": "tests/unit/core/test_neuron.py",
      "line": 69,
      "doc": "Modo ONLINE deve atualizar N/I quando defer_updates=False.",
      "params": [
        "self",
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_batch_plasticity_preserves_local_pre_synaptic_rate",
      "kind": "method",
      "name": "test_batch_plasticity_preserves_local_pre_synaptic_rate",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_batch_plasticity_preserves_local_pre_synaptic_rate",
      "file": "tests/unit/core/test_neuron.py",
      "line": 94,
      "doc": "BATCH deve manter média local por sinapse (sem normalização cruzada).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_modes",
      "kind": "method",
      "name": "test_modes",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_modes",
      "file": "tests/unit/core/test_neuron.py",
      "line": 132,
      "doc": "Test learning modes.",
      "params": [
        "self",
        "small_config",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.parametrize('mode', ['online', 'batch', 'inference'])"
      ]
    },
    {
      "id": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_theta_eff_caps_unreachable_threshold",
      "kind": "method",
      "name": "test_nmda_theta_eff_caps_unreachable_threshold",
      "qname": "tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_theta_eff_caps_unreachable_threshold",
      "file": "tests/unit/core/test_neuron.py",
      "line": 141,
      "doc": "NMDA+shunting deve limitar theta efetivo à capacidade somática.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_neuron_v2",
      "kind": "module",
      "name": "test_neuron_v2",
      "qname": "tests.unit.core.test_neuron_v2",
      "file": "tests/unit/core/test_neuron_v2.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_neuron_v2.test_forward_shapes_v2",
      "kind": "function",
      "name": "test_forward_shapes_v2",
      "qname": "tests.unit.core.test_neuron_v2.test_forward_shapes_v2",
      "file": "tests/unit/core/test_neuron_v2.py",
      "line": 9,
      "doc": null,
      "params": [
        "small_config",
        "batch_size"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_neuron_v2.test_cooperative_sum_uses_multiple_dendrites",
      "kind": "function",
      "name": "test_cooperative_sum_uses_multiple_dendrites",
      "qname": "tests.unit.core.test_neuron_v2.test_cooperative_sum_uses_multiple_dendrites",
      "file": "tests/unit/core/test_neuron_v2.py",
      "line": 22,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_neuron_v2.test_step_id_thread_safe_increment_v2",
      "kind": "function",
      "name": "test_step_id_thread_safe_increment_v2",
      "qname": "tests.unit.core.test_neuron_v2.test_step_id_thread_safe_increment_v2",
      "file": "tests/unit/core/test_neuron_v2.py",
      "line": 41,
      "doc": null,
      "params": [
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.core.test_neuron_v2.test_theta_eff_caps_unreachable_threshold",
      "kind": "function",
      "name": "test_theta_eff_caps_unreachable_threshold",
      "qname": "tests.unit.core.test_neuron_v2.test_theta_eff_caps_unreachable_threshold",
      "file": "tests/unit/core/test_neuron_v2.py",
      "line": 54,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.core.test_synapse",
      "kind": "module",
      "name": "test_synapse",
      "qname": "tests.unit.core.test_synapse",
      "file": "tests/unit/core/test_synapse.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "kind": "class",
      "name": "TestMPJRDSynapse",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse",
      "file": "tests/unit/core/test_synapse.py",
      "line": 9,
      "doc": "Test synapse.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_initialization",
      "file": "tests/unit/core/test_synapse.py",
      "line": 12,
      "doc": "Test initialization.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_ltp",
      "kind": "method",
      "name": "test_ltp",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_ltp",
      "file": "tests/unit/core/test_synapse.py",
      "line": 20,
      "doc": "Test LTP.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_respects_plastic_flag",
      "kind": "method",
      "name": "test_update_respects_plastic_flag",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_respects_plastic_flag",
      "file": "tests/unit/core/test_synapse.py",
      "line": 36,
      "doc": "When plasticity is disabled, synaptic state must remain unchanged.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_filters_inactive_pre_synaptic_activity",
      "kind": "method",
      "name": "test_update_filters_inactive_pre_synaptic_activity",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_filters_inactive_pre_synaptic_activity",
      "file": "tests/unit/core/test_synapse.py",
      "line": 51,
      "doc": "Pre-synaptic activity below threshold should not change I/eligibility.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_uses_absolute_dt_and_mode_multiplier",
      "kind": "method",
      "name": "test_update_uses_absolute_dt_and_mode_multiplier",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_uses_absolute_dt_and_mode_multiplier",
      "file": "tests/unit/core/test_synapse.py",
      "line": 67,
      "doc": "Negative dt should be handled as absolute value in plasticity update.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_saturation_recovery_disables_protection_after_timeout",
      "kind": "method",
      "name": "test_saturation_recovery_disables_protection_after_timeout",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_saturation_recovery_disables_protection_after_timeout",
      "file": "tests/unit/core/test_synapse.py",
      "line": 89,
      "doc": "Protection mode should auto-disable after recovery timeout.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_negative_neuromodulation_promotes_ltd",
      "kind": "method",
      "name": "test_negative_neuromodulation_promotes_ltd",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_negative_neuromodulation_promotes_ltd",
      "file": "tests/unit/core/test_synapse.py",
      "line": 109,
      "doc": "Negative neuromodulation should bias update toward LTD.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_consolidate_transfers_eligibility_and_decays_internal_potential",
      "kind": "method",
      "name": "test_consolidate_transfers_eligibility_and_decays_internal_potential",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_consolidate_transfers_eligibility_and_decays_internal_potential",
      "file": "tests/unit/core/test_synapse.py",
      "line": 130,
      "doc": "Consolidation should move eligibility into N and decay I.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_supports_explicit_hebbian_ltd_component",
      "kind": "method",
      "name": "test_update_supports_explicit_hebbian_ltd_component",
      "qname": "tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_supports_explicit_hebbian_ltd_component",
      "file": "tests/unit/core/test_synapse.py",
      "line": 146,
      "doc": "Explicit LTD term should reduce/update internal potential when configured.",
      "params": [
        "self",
        "tiny_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.network.test_network_edge_cases",
      "kind": "module",
      "name": "test_network_edge_cases",
      "qname": "tests.unit.network.test_network_edge_cases",
      "file": "tests/unit/network/test_network_edge_cases.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.network.test_network_edge_cases.test_prepare_input_with_single_dendrite_avoids_division_by_zero",
      "kind": "function",
      "name": "test_prepare_input_with_single_dendrite_avoids_division_by_zero",
      "qname": "tests.unit.network.test_network_edge_cases.test_prepare_input_with_single_dendrite_avoids_division_by_zero",
      "file": "tests/unit/network/test_network_edge_cases.py",
      "line": 8,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_adaptation_sfa",
      "kind": "module",
      "name": "test_adaptation_sfa",
      "qname": "tests.unit.neuron.test_adaptation_sfa",
      "file": "tests/unit/neuron/test_adaptation_sfa.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_adaptation_sfa.test_sfa_applies_before_threshold_and_reduces_spiking_probability",
      "kind": "function",
      "name": "test_sfa_applies_before_threshold_and_reduces_spiking_probability",
      "qname": "tests.unit.neuron.test_adaptation_sfa.test_sfa_applies_before_threshold_and_reduces_spiking_probability",
      "file": "tests/unit/neuron/test_adaptation_sfa.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_backprop_bap",
      "kind": "module",
      "name": "test_backprop_bap",
      "qname": "tests.unit.neuron.test_backprop_bap",
      "file": "tests/unit/neuron/test_backprop_bap.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_backprop_bap.test_bap_amplification_changes_dendritic_computation_and_clamps_gain",
      "kind": "function",
      "name": "test_bap_amplification_changes_dendritic_computation_and_clamps_gain",
      "qname": "tests.unit.neuron.test_backprop_bap.test_bap_amplification_changes_dendritic_computation_and_clamps_gain",
      "file": "tests/unit/neuron/test_backprop_bap.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_contract_conformance",
      "kind": "module",
      "name": "test_contract_conformance",
      "qname": "tests.unit.neuron.test_contract_conformance",
      "file": "tests/unit/neuron/test_contract_conformance.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_contract_conformance.test_torch_contract_invariants_order_and_time_step_end_of_step",
      "kind": "function",
      "name": "test_torch_contract_invariants_order_and_time_step_end_of_step",
      "qname": "tests.unit.neuron.test_contract_conformance.test_torch_contract_invariants_order_and_time_step_end_of_step",
      "file": "tests/unit/neuron/test_contract_conformance.py",
      "line": 13,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_contract_conformance.test_torch_and_tf_contract_conformance_with_same_artificial_input_and_tolerance",
      "kind": "function",
      "name": "test_torch_and_tf_contract_conformance_with_same_artificial_input_and_tolerance",
      "qname": "tests.unit.neuron.test_contract_conformance.test_torch_and_tf_contract_conformance_with_same_artificial_input_and_tolerance",
      "file": "tests/unit/neuron/test_contract_conformance.py",
      "line": 29,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_refractory",
      "kind": "module",
      "name": "test_refractory",
      "qname": "tests.unit.neuron.test_refractory",
      "file": "tests/unit/neuron/test_refractory.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_refractory.test_absolute_refractory_is_inviolable",
      "kind": "function",
      "name": "test_absolute_refractory_is_inviolable",
      "qname": "tests.unit.neuron.test_refractory.test_absolute_refractory_is_inviolable",
      "file": "tests/unit/neuron/test_refractory.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_stp_stdp_contracts",
      "kind": "module",
      "name": "test_stp_stdp_contracts",
      "qname": "tests.unit.neuron.test_stp_stdp_contracts",
      "file": "tests/unit/neuron/test_stp_stdp_contracts.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_stp_stdp_contracts.test_stdp_reads_pre_stp_input_for_pre_spikes_and_ltd_uses_pre_spike_gate",
      "kind": "function",
      "name": "test_stdp_reads_pre_stp_input_for_pre_spikes_and_ltd_uses_pre_spike_gate",
      "qname": "tests.unit.neuron.test_stp_stdp_contracts.test_stdp_reads_pre_stp_input_for_pre_spikes_and_ltd_uses_pre_spike_gate",
      "file": "tests/unit/neuron/test_stp_stdp_contracts.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.neuron.test_time_counter",
      "kind": "module",
      "name": "test_time_counter",
      "qname": "tests.unit.neuron.test_time_counter",
      "file": "tests/unit/neuron/test_time_counter.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.neuron.test_time_counter.test_time_counter_increments_at_end_of_forward_step",
      "kind": "function",
      "name": "test_time_counter_increments_at_end_of_forward_step",
      "qname": "tests.unit.neuron.test_time_counter.test_time_counter_increments_at_end_of_forward_step",
      "file": "tests/unit/neuron/test_time_counter.py",
      "line": 5,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.serialization.test_foldio",
      "kind": "module",
      "name": "test_foldio",
      "qname": "tests.unit.serialization.test_foldio",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio._build_neuron",
      "kind": "function",
      "name": "_build_neuron",
      "qname": "tests.unit.serialization.test_foldio._build_neuron",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 40,
      "doc": null,
      "params": [
        "enable_telemetry"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_roundtrip_and_peek",
      "kind": "function",
      "name": "test_fold_roundtrip_and_peek",
      "qname": "tests.unit.serialization.test_foldio.test_fold_roundtrip_and_peek",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 51,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_roundtrip_preserves_state_dict_after_forward_steps",
      "kind": "function",
      "name": "test_fold_roundtrip_preserves_state_dict_after_forward_steps",
      "qname": "tests.unit.serialization.test_foldio.test_fold_roundtrip_preserves_state_dict_after_forward_steps",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 80,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_training_then_save_with_telemetry_and_history_and_nuclear_arrays",
      "kind": "function",
      "name": "test_training_then_save_with_telemetry_and_history_and_nuclear_arrays",
      "qname": "tests.unit.serialization.test_foldio.test_training_then_save_with_telemetry_and_history_and_nuclear_arrays",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 107,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_detects_corruption",
      "kind": "function",
      "name": "test_detects_corruption",
      "qname": "tests.unit.serialization.test_foldio.test_detects_corruption",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 143,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_hierarchical_hashes_present_in_metadata",
      "kind": "function",
      "name": "test_hierarchical_hashes_present_in_metadata",
      "qname": "tests.unit.serialization.test_foldio.test_hierarchical_hashes_present_in_metadata",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 171,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_ecc_from_protection_mapping",
      "kind": "function",
      "name": "test_ecc_from_protection_mapping",
      "qname": "tests.unit.serialization.test_foldio.test_ecc_from_protection_mapping",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 192,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_ecc_roundtrip_if_available",
      "kind": "function",
      "name": "test_ecc_roundtrip_if_available",
      "qname": "tests.unit.serialization.test_foldio.test_ecc_roundtrip_if_available",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 207,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_crc32c_matches_known_vector",
      "kind": "function",
      "name": "test_crc32c_matches_known_vector",
      "qname": "tests.unit.serialization.test_foldio.test_crc32c_matches_known_vector",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 234,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_with_mmap",
      "kind": "function",
      "name": "test_fold_reader_bounds_validation_with_mmap",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_with_mmap",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 238,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_negative_values",
      "kind": "function",
      "name": "test_fold_reader_bounds_validation_negative_values",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_negative_values",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 252,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_index_size_validation",
      "kind": "function",
      "name": "test_fold_reader_index_size_validation",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_index_size_validation",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 267,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_index_offset_validation",
      "kind": "function",
      "name": "test_fold_reader_index_offset_validation",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_index_offset_validation",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 277,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_header_len_validation",
      "kind": "function",
      "name": "test_fold_reader_header_len_validation",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_header_len_validation",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 288,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_io_failure_with_phase_context",
      "kind": "function",
      "name": "test_fold_writer_finalize_wraps_io_failure_with_phase_context",
      "qname": "tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_io_failure_with_phase_context",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 299,
      "doc": null,
      "params": [
        "tmp_path",
        "monkeypatch"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_reports_magic_values",
      "kind": "function",
      "name": "test_fold_reader_reports_magic_values",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_reports_magic_values",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 316,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_reader_exit_closes_file_even_if_mmap_close_fails",
      "kind": "function",
      "name": "test_fold_reader_exit_closes_file_even_if_mmap_close_fails",
      "qname": "tests.unit.serialization.test_foldio.test_fold_reader_exit_closes_file_even_if_mmap_close_fails",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 327,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio._build_writer_with_chunk",
      "kind": "function",
      "name": "_build_writer_with_chunk",
      "qname": "tests.unit.serialization.test_foldio._build_writer_with_chunk",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 346,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_failures_with_phase",
      "kind": "function",
      "name": "test_fold_writer_finalize_wraps_failures_with_phase",
      "qname": "tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_failures_with_phase",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 393,
      "doc": null,
      "params": [
        "tmp_path",
        "monkeypatch",
        "phase",
        "patcher",
        "error_message"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.parametrize(('phase', 'patcher', 'error_message'), [('write_index', lambda writer, monkeypatch: monkeypatch.setattr(writer._f, 'flush', mock.Mock(side_effect=OSError('flush failed'))), 'flush failed'), ('fsync_index', lambda writer, monkeypatch: monkeypatch.setattr('pyfolds.serialization.foldio.os.fsync', mock.Mock(side_effect=OSError('fsync index failed'))), 'fsync index failed'), ('write_header', lambda writer, monkeypatch: monkeypatch.setattr(writer._f, 'seek', mock.Mock(side_effect=OSError('seek failed'))), 'seek failed'), ('write_header', lambda writer, monkeypatch: monkeypatch.setattr(writer._f, 'write', _failing_write_after_first_call(writer._f.write)), 'write failed')])"
      ]
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio._failing_write_after_first_call",
      "kind": "function",
      "name": "_failing_write_after_first_call",
      "qname": "tests.unit.serialization.test_foldio._failing_write_after_first_call",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 413,
      "doc": null,
      "params": [
        "original_write"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_manifest_includes_governance_sections",
      "kind": "function",
      "name": "test_fold_manifest_includes_governance_sections",
      "qname": "tests.unit.serialization.test_foldio.test_fold_manifest_includes_governance_sections",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 425,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.serialization.test_foldio.test_fold_signature_roundtrip_if_cryptography_available",
      "kind": "function",
      "name": "test_fold_signature_roundtrip_if_cryptography_available",
      "qname": "tests.unit.serialization.test_foldio.test_fold_signature_roundtrip_if_cryptography_available",
      "file": "tests/unit/serialization/test_foldio.py",
      "line": 450,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry",
      "kind": "module",
      "name": "telemetry",
      "qname": "tests.unit.telemetry",
      "file": "tests/unit/telemetry/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_controller",
      "kind": "module",
      "name": "test_controller",
      "qname": "tests.unit.telemetry.test_controller",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "kind": "class",
      "name": "TestTelemetryController",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 7,
      "doc": "Test telemetry controller.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_initialization",
      "kind": "method",
      "name": "test_initialization",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_initialization",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 10,
      "doc": "Test basic initialization.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_off",
      "kind": "method",
      "name": "test_profile_off",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_off",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 17,
      "doc": "Test profile=off disables everything.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_light",
      "kind": "method",
      "name": "test_profile_light",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_light",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 27,
      "doc": "Test profile=light with sampling.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_heavy",
      "kind": "method",
      "name": "test_profile_heavy",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_heavy",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 38,
      "doc": "Test profile=heavy always emits.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_should_emit_sample",
      "kind": "method",
      "name": "test_should_emit_sample",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_should_emit_sample",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 48,
      "doc": "Test probabilistic sampling.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_step_count_increments",
      "kind": "method",
      "name": "test_step_count_increments",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_step_count_increments",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 64,
      "doc": "Test that step counter increments on emit.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_snapshot_and_clear",
      "kind": "method",
      "name": "test_snapshot_and_clear",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_snapshot_and_clear",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 78,
      "doc": "Test snapshot and clear methods.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_get_stats",
      "kind": "method",
      "name": "test_get_stats",
      "qname": "tests.unit.telemetry.test_controller.TestTelemetryController.test_get_stats",
      "file": "tests/unit/telemetry/test_controller.py",
      "line": 95,
      "doc": "Test get_stats returns correct structure.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_decorator",
      "kind": "module",
      "name": "test_decorator",
      "qname": "tests.unit.telemetry.test_decorator",
      "file": "tests/unit/telemetry/test_decorator.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "kind": "class",
      "name": "TestTelemetryDecorator",
      "qname": "tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "file": "tests/unit/telemetry/test_decorator.py",
      "line": 7,
      "doc": "Test decorator.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_basic",
      "kind": "method",
      "name": "test_decorator_basic",
      "qname": "tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_basic",
      "file": "tests/unit/telemetry/test_decorator.py",
      "line": 10,
      "doc": "Test basic decorator functionality.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_with_sample_rate",
      "kind": "method",
      "name": "test_decorator_with_sample_rate",
      "qname": "tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_with_sample_rate",
      "file": "tests/unit/telemetry/test_decorator.py",
      "line": 31,
      "doc": "Test decorator with sampling.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_lazy_evaluation",
      "kind": "method",
      "name": "test_decorator_lazy_evaluation",
      "qname": "tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_lazy_evaluation",
      "file": "tests/unit/telemetry/test_decorator.py",
      "line": 60,
      "doc": "Test that decorator works with lazy events.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_events",
      "kind": "module",
      "name": "test_events",
      "qname": "tests.unit.telemetry.test_events",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_events.TelemetryEvent",
      "kind": "class",
      "name": "TelemetryEvent",
      "qname": "tests.unit.telemetry.test_events.TelemetryEvent",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 14,
      "doc": "Base telemetry event with lazy evaluation support.\n\nAttributes:\n    step_id: Current step ID\n    phase: Event phase (forward, commit, sleep)\n    mode: Learning mode\n    _payload: Dict or function returning payload\n    timestamp: High-precision timestamp (perf_counter)\n    wall_time: Wall time for temporal analysis\n    neuron_id: Optional neuron ID",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ]
    },
    {
      "id": "mtd:tests.unit.telemetry.test_events.TelemetryEvent.payload",
      "kind": "method",
      "name": "payload",
      "qname": "tests.unit.telemetry.test_events.TelemetryEvent.payload",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 36,
      "doc": "Evaluate lazy payload if needed.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": [
        "property"
      ]
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.forward_event",
      "kind": "function",
      "name": "forward_event",
      "qname": "tests.unit.telemetry.test_events.forward_event",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 43,
      "doc": "Create eager forward event.\n\nArgs:\n    step_id: Step ID\n    mode: Learning mode\n    neuron_id: Optional neuron ID\n    **payload: Metrics to collect",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.forward_event_lazy",
      "kind": "function",
      "name": "forward_event_lazy",
      "qname": "tests.unit.telemetry.test_events.forward_event_lazy",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 64,
      "doc": "Create lazy forward event (CPU-efficient).\n\nArgs:\n    step_id: Step ID\n    mode: Learning mode\n    payload_fn: Function returning payload (only called if event is emitted)\n    neuron_id: Optional neuron ID\n\nExample:\n    >>> telem.emit(forward_event_lazy(\n    ...     step_id=step,\n    ...     mode=\"online\",\n    ...     payload_fn=lambda: {\n    ...         'spike_rate': neuron.get_spike_rate(),  # Only calculated if needed\n    ...         'theta': neuron.theta.item()\n    ...     }\n    ... ))",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.commit_event",
      "kind": "function",
      "name": "commit_event",
      "qname": "tests.unit.telemetry.test_events.commit_event",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 95,
      "doc": "Create eager commit event.",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.commit_event_lazy",
      "kind": "function",
      "name": "commit_event_lazy",
      "qname": "tests.unit.telemetry.test_events.commit_event_lazy",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 108,
      "doc": "Create lazy commit event.",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.sleep_event",
      "kind": "function",
      "name": "sleep_event",
      "qname": "tests.unit.telemetry.test_events.sleep_event",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 121,
      "doc": "Create eager sleep event.",
      "params": [
        "step_id",
        "mode",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.telemetry.test_events.sleep_event_lazy",
      "kind": "function",
      "name": "sleep_event_lazy",
      "qname": "tests.unit.telemetry.test_events.sleep_event_lazy",
      "file": "tests/unit/telemetry/test_events.py",
      "line": 134,
      "doc": "Create lazy sleep event.",
      "params": [
        "step_id",
        "mode",
        "payload_fn",
        "neuron_id"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_ringbuffer",
      "kind": "module",
      "name": "test_ringbuffer",
      "qname": "tests.unit.telemetry.test_ringbuffer",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "kind": "class",
      "name": "TestRingBuffer",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 8,
      "doc": "Test ring buffer.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_append",
      "kind": "method",
      "name": "test_append",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_append",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 11,
      "doc": "Test FIFO order and overwrite behavior.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_snapshot_with_none",
      "kind": "method",
      "name": "test_snapshot_with_none",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_snapshot_with_none",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 26,
      "doc": "Test that snapshot includes None values (doesn't filter them out).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_empty_snapshot",
      "kind": "method",
      "name": "test_empty_snapshot",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_empty_snapshot",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 36,
      "doc": "Test snapshot on empty buffer.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_len",
      "kind": "method",
      "name": "test_len",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_len",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 41,
      "doc": "Test __len__ method.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_clear",
      "kind": "method",
      "name": "test_clear",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_clear",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 56,
      "doc": "Test clear method.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_capacity_property",
      "kind": "method",
      "name": "test_capacity_property",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_capacity_property",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 67,
      "doc": "Test capacity property.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_is_full",
      "kind": "method",
      "name": "test_is_full",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_is_full",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 72,
      "doc": "Test is_full property.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_extend",
      "kind": "method",
      "name": "test_extend",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_extend",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 86,
      "doc": "Test extend method.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_thread_safety",
      "kind": "method",
      "name": "test_thread_safety",
      "qname": "tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_thread_safety",
      "file": "tests/unit/telemetry/test_ringbuffer.py",
      "line": 94,
      "doc": "Test thread safety with concurrent appends.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_sinks",
      "kind": "module",
      "name": "test_sinks",
      "qname": "tests.unit.telemetry.test_sinks",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_sinks.TestMemorySink",
      "kind": "class",
      "name": "TestMemorySink",
      "qname": "tests.unit.telemetry.test_sinks.TestMemorySink",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 8,
      "doc": "Test memory sink.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_emit",
      "kind": "method",
      "name": "test_emit",
      "qname": "tests.unit.telemetry.test_sinks.TestMemorySink.test_emit",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 11,
      "doc": "Test emit stores events.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_capacity_limit",
      "kind": "method",
      "name": "test_capacity_limit",
      "qname": "tests.unit.telemetry.test_sinks.TestMemorySink.test_capacity_limit",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 20,
      "doc": "Test that sink respects capacity limit.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_clear",
      "kind": "method",
      "name": "test_clear",
      "qname": "tests.unit.telemetry.test_sinks.TestMemorySink.test_clear",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 34,
      "doc": "Test clear method.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_sinks.TestConsoleSink",
      "kind": "class",
      "name": "TestConsoleSink",
      "qname": "tests.unit.telemetry.test_sinks.TestConsoleSink",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 47,
      "doc": "Test console sink.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestConsoleSink.test_verbose",
      "kind": "method",
      "name": "test_verbose",
      "qname": "tests.unit.telemetry.test_sinks.TestConsoleSink.test_verbose",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 50,
      "doc": "Test verbose mode prints payload.",
      "params": [
        "self",
        "capsys"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestConsoleSink.test_non_verbose",
      "kind": "method",
      "name": "test_non_verbose",
      "qname": "tests.unit.telemetry.test_sinks.TestConsoleSink.test_non_verbose",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 67,
      "doc": "Test non-verbose mode only prints step and phase.",
      "params": [
        "self",
        "capsys"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "kind": "class",
      "name": "TestJSONLinesSink",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 85,
      "doc": "Test JSON lines sink.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_emit_basic",
      "kind": "method",
      "name": "test_emit_basic",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_emit_basic",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 88,
      "doc": "Test basic emit to file.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_truncate_mode",
      "kind": "method",
      "name": "test_truncate_mode",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_truncate_mode",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 104,
      "doc": "Test truncate=True overwrites file.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_append_mode",
      "kind": "method",
      "name": "test_append_mode",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_append_mode",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 120,
      "doc": "Test truncate=False appends to file.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_tensor_serialization",
      "kind": "method",
      "name": "test_tensor_serialization",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_tensor_serialization",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 137,
      "doc": "Test serialization of PyTorch tensors.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_depth_limit_serialization",
      "kind": "method",
      "name": "test_depth_limit_serialization",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_depth_limit_serialization",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 167,
      "doc": "Nested payloads beyond max depth should fallback to string.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_non_serializable_fallback",
      "kind": "method",
      "name": "test_non_serializable_fallback",
      "qname": "tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_non_serializable_fallback",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 183,
      "doc": "Test fallback for non-serializable objects.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_sinks.TestDistributorSink",
      "kind": "class",
      "name": "TestDistributorSink",
      "qname": "tests.unit.telemetry.test_sinks.TestDistributorSink",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 204,
      "doc": "Test distributor sink.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestDistributorSink.test_distributes_to_all_sinks",
      "kind": "method",
      "name": "test_distributes_to_all_sinks",
      "qname": "tests.unit.telemetry.test_sinks.TestDistributorSink.test_distributes_to_all_sinks",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 207,
      "doc": "Test that events go to all sinks.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_sinks.TestDistributorSink.test_sink_failure_doesnt_affect_others",
      "kind": "method",
      "name": "test_sink_failure_doesnt_affect_others",
      "qname": "tests.unit.telemetry.test_sinks.TestDistributorSink.test_sink_failure_doesnt_affect_others",
      "file": "tests/unit/telemetry/test_sinks.py",
      "line": 227,
      "doc": "Test that one sink failing doesn't stop others.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.telemetry.test_types",
      "kind": "module",
      "name": "test_types",
      "qname": "tests.unit.telemetry.test_types",
      "file": "tests/unit/telemetry/test_types.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.telemetry.test_types.TestPayloadTypes",
      "kind": "class",
      "name": "TestPayloadTypes",
      "qname": "tests.unit.telemetry.test_types.TestPayloadTypes",
      "file": "tests/unit/telemetry/test_types.py",
      "line": 6,
      "doc": "Test payload types.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_forward_payload",
      "kind": "method",
      "name": "test_forward_payload",
      "qname": "tests.unit.telemetry.test_types.TestPayloadTypes.test_forward_payload",
      "file": "tests/unit/telemetry/test_types.py",
      "line": 9,
      "doc": "Test forward payload type.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_commit_payload",
      "kind": "method",
      "name": "test_commit_payload",
      "qname": "tests.unit.telemetry.test_types.TestPayloadTypes.test_commit_payload",
      "file": "tests/unit/telemetry/test_types.py",
      "line": 28,
      "doc": "Test commit payload type.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_sleep_payload",
      "kind": "method",
      "name": "test_sleep_payload",
      "qname": "tests.unit.telemetry.test_types.TestPayloadTypes.test_sleep_payload",
      "file": "tests/unit/telemetry/test_types.py",
      "line": 43,
      "doc": "Test sleep payload type.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_backend_contracts",
      "kind": "module",
      "name": "test_backend_contracts",
      "qname": "tests.unit.test_backend_contracts",
      "file": "tests/unit/test_backend_contracts.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_backend_contracts.test_import_and_object_construction_v1_v2",
      "kind": "function",
      "name": "test_import_and_object_construction_v1_v2",
      "qname": "tests.unit.test_backend_contracts.test_import_and_object_construction_v1_v2",
      "file": "tests/unit/test_backend_contracts.py",
      "line": 12,
      "doc": "Garante compatibilidade de import/construção para v1 e v2.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_backend_contracts.test_torch_backend_shape_and_state_contracts",
      "kind": "function",
      "name": "test_torch_backend_shape_and_state_contracts",
      "qname": "tests.unit.test_backend_contracts.test_torch_backend_shape_and_state_contracts",
      "file": "tests/unit/test_backend_contracts.py",
      "line": 23,
      "doc": "Contrato mínimo de shape/estado no backend torch.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_backend_contracts._tf_forward_sequence_equivalent",
      "kind": "function",
      "name": "_tf_forward_sequence_equivalent",
      "qname": "tests.unit.test_backend_contracts._tf_forward_sequence_equivalent",
      "file": "tests/unit/test_backend_contracts.py",
      "line": 52,
      "doc": "Equivalente simples de forward_sequence para validar shape/estabilidade em tf.\n\nx_seq: [T, B, D, S]\nretorna: [T, B]",
      "params": [
        "x_seq"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_backend_contracts.test_tf_backend_conditional_shape_state_contracts",
      "kind": "function",
      "name": "test_tf_backend_conditional_shape_state_contracts",
      "qname": "tests.unit.test_backend_contracts.test_tf_backend_conditional_shape_state_contracts",
      "file": "tests/unit/test_backend_contracts.py",
      "line": 70,
      "doc": "Teste condicional de backend tf (shape, faixa e estabilidade numérica).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": [
        "pytest.mark.tf",
        "pytest.mark.skipif(importlib.util.find_spec('tensorflow') is None, reason='TensorFlow não instalado neste ambiente.')"
      ]
    },
    {
      "id": "mod:tests.unit.test_design_improvements",
      "kind": "module",
      "name": "test_design_improvements",
      "qname": "tests.unit.test_design_improvements",
      "file": "tests/unit/test_design_improvements.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "kind": "class",
      "name": "DummyNeuron",
      "qname": "tests.unit.test_design_improvements.DummyNeuron",
      "file": "tests/unit/test_design_improvements.py",
      "line": 12,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [
        "BaseNeuron"
      ],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.test_design_improvements.DummyNeuron.__init__",
      "kind": "method",
      "name": "__init__",
      "qname": "tests.unit.test_design_improvements.DummyNeuron.__init__",
      "file": "tests/unit/test_design_improvements.py",
      "line": 13,
      "doc": null,
      "params": [
        "self",
        "cfg"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.test_design_improvements.DummyNeuron.forward",
      "kind": "method",
      "name": "forward",
      "qname": "tests.unit.test_design_improvements.DummyNeuron.forward",
      "file": "tests/unit/test_design_improvements.py",
      "line": 18,
      "doc": null,
      "params": [
        "self",
        "x"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.test_design_improvements.DummyNeuron.set_mode",
      "kind": "method",
      "name": "set_mode",
      "qname": "tests.unit.test_design_improvements.DummyNeuron.set_mode",
      "file": "tests/unit/test_design_improvements.py",
      "line": 21,
      "doc": null,
      "params": [
        "self",
        "mode"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.test_design_improvements.DummyNeuron.apply_plasticity",
      "kind": "method",
      "name": "apply_plasticity",
      "qname": "tests.unit.test_design_improvements.DummyNeuron.apply_plasticity",
      "file": "tests/unit/test_design_improvements.py",
      "line": 24,
      "doc": null,
      "params": [
        "self",
        "dt"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.test_design_improvements.DummyNeuron.get_metrics",
      "kind": "method",
      "name": "get_metrics",
      "qname": "tests.unit.test_design_improvements.DummyNeuron.get_metrics",
      "file": "tests/unit/test_design_improvements.py",
      "line": 27,
      "doc": null,
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_design_improvements.test_factory_creates_builtin_types",
      "kind": "function",
      "name": "test_factory_creates_builtin_types",
      "qname": "tests.unit.test_design_improvements.test_factory_creates_builtin_types",
      "file": "tests/unit/test_design_improvements.py",
      "line": 31,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_design_improvements.test_factory_custom_registry_and_unknown_type",
      "kind": "function",
      "name": "test_factory_custom_registry_and_unknown_type",
      "qname": "tests.unit.test_design_improvements.test_factory_custom_registry_and_unknown_type",
      "file": "tests/unit/test_design_improvements.py",
      "line": 41,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_design_improvements.test_learning_mode_context_restores_even_on_error",
      "kind": "function",
      "name": "test_learning_mode_context_restores_even_on_error",
      "qname": "tests.unit.test_design_improvements.test_learning_mode_context_restores_even_on_error",
      "file": "tests/unit/test_design_improvements.py",
      "line": 52,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_design_improvements.test_network_builder_connects_layers_and_builds",
      "kind": "function",
      "name": "test_network_builder_connects_layers_and_builds",
      "qname": "tests.unit.test_design_improvements.test_network_builder_connects_layers_and_builds",
      "file": "tests/unit/test_design_improvements.py",
      "line": 66,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_layer_neuron_class",
      "kind": "module",
      "name": "test_layer_neuron_class",
      "qname": "tests.unit.test_layer_neuron_class",
      "file": "tests/unit/test_layer_neuron_class.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_layer_neuron_class.test_layer_accepts_neuron_v2",
      "kind": "function",
      "name": "test_layer_accepts_neuron_v2",
      "qname": "tests.unit.test_layer_neuron_class.test_layer_accepts_neuron_v2",
      "file": "tests/unit/test_layer_neuron_class.py",
      "line": 11,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_layer_neuron_class.test_layer_rejects_invalid_neuron_cls",
      "kind": "function",
      "name": "test_layer_rejects_invalid_neuron_cls",
      "qname": "tests.unit.test_layer_neuron_class.test_layer_rejects_invalid_neuron_cls",
      "file": "tests/unit/test_layer_neuron_class.py",
      "line": 22,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_layer_neuron_class.test_layer_has_no_legacy_neuron_class_attr",
      "kind": "function",
      "name": "test_layer_has_no_legacy_neuron_class_attr",
      "qname": "tests.unit.test_layer_neuron_class.test_layer_has_no_legacy_neuron_class_attr",
      "file": "tests/unit/test_layer_neuron_class.py",
      "line": 29,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_layer_neuron_class.test_layer_forwards_dt_to_neurons",
      "kind": "function",
      "name": "test_layer_forwards_dt_to_neurons",
      "qname": "tests.unit.test_layer_neuron_class.test_layer_forwards_dt_to_neurons",
      "file": "tests/unit/test_layer_neuron_class.py",
      "line": 35,
      "doc": null,
      "params": [
        "monkeypatch"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_learning_mode_consistency",
      "kind": "module",
      "name": "test_learning_mode_consistency",
      "qname": "tests.unit.test_learning_mode_consistency",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency._make_layer",
      "kind": "function",
      "name": "_make_layer",
      "qname": "tests.unit.test_learning_mode_consistency._make_layer",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 11,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_learning_mode_single_source",
      "kind": "function",
      "name": "test_learning_mode_single_source",
      "qname": "tests.unit.test_learning_mode_consistency.test_learning_mode_single_source",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 16,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_learning_mode_from_string",
      "kind": "function",
      "name": "test_learning_mode_from_string",
      "qname": "tests.unit.test_learning_mode_consistency.test_learning_mode_from_string",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 20,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_string",
      "kind": "function",
      "name": "test_layer_accepts_mode_string",
      "qname": "tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_string",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 24,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_enum",
      "kind": "function",
      "name": "test_layer_accepts_mode_enum",
      "qname": "tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_enum",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 31,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_layer_rejects_invalid_mode",
      "kind": "function",
      "name": "test_layer_rejects_invalid_mode",
      "qname": "tests.unit.test_learning_mode_consistency.test_layer_rejects_invalid_mode",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 38,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_network_accepts_mode_string",
      "kind": "function",
      "name": "test_network_accepts_mode_string",
      "qname": "tests.unit.test_learning_mode_consistency.test_network_accepts_mode_string",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 45,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_learning_mode_consistency.test_network_rejects_invalid_mode",
      "kind": "function",
      "name": "test_network_rejects_invalid_mode",
      "qname": "tests.unit.test_learning_mode_consistency.test_network_rejects_invalid_mode",
      "file": "tests/unit/test_learning_mode_consistency.py",
      "line": 54,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_public_import_surface",
      "kind": "module",
      "name": "test_public_import_surface",
      "qname": "tests.unit.test_public_import_surface",
      "file": "tests/unit/test_public_import_surface.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_public_import_surface.test_public_all_exports_are_importable",
      "kind": "function",
      "name": "test_public_all_exports_are_importable",
      "qname": "tests.unit.test_public_import_surface.test_public_all_exports_are_importable",
      "file": "tests/unit/test_public_import_surface.py",
      "line": 14,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_public_import_surface.test_v2_surface_is_canonical_and_instantiable",
      "kind": "function",
      "name": "test_v2_surface_is_canonical_and_instantiable",
      "qname": "tests.unit.test_public_import_surface.test_v2_surface_is_canonical_and_instantiable",
      "file": "tests/unit/test_public_import_surface.py",
      "line": 19,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_public_import_surface.test_v1_aliases_emit_deprecation_warning_and_match_v2_targets_until_2_0",
      "kind": "function",
      "name": "test_v1_aliases_emit_deprecation_warning_and_match_v2_targets_until_2_0",
      "qname": "tests.unit.test_public_import_surface.test_v1_aliases_emit_deprecation_warning_and_match_v2_targets_until_2_0",
      "file": "tests/unit/test_public_import_surface.py",
      "line": 31,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_public_import_surface.test_telemetry_controller_basic_flow",
      "kind": "function",
      "name": "test_telemetry_controller_basic_flow",
      "qname": "tests.unit.test_public_import_surface.test_telemetry_controller_basic_flow",
      "file": "tests/unit/test_public_import_surface.py",
      "line": 55,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_run_pyfolds_runner",
      "kind": "module",
      "name": "test_run_pyfolds_runner",
      "qname": "tests.unit.test_run_pyfolds_runner",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner._run",
      "kind": "function",
      "name": "_run",
      "qname": "tests.unit.test_run_pyfolds_runner._run",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 10,
      "doc": null,
      "params": [
        "script_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner.test_runner_logs_syntax_error",
      "kind": "function",
      "name": "test_runner_logs_syntax_error",
      "qname": "tests.unit.test_run_pyfolds_runner.test_runner_logs_syntax_error",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 19,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner.test_runner_logs_runtime_error_and_propagates_exit_code",
      "kind": "function",
      "name": "test_runner_logs_runtime_error_and_propagates_exit_code",
      "qname": "tests.unit.test_run_pyfolds_runner.test_runner_logs_runtime_error_and_propagates_exit_code",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 34,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner.test_runner_tee_prints_progress",
      "kind": "function",
      "name": "test_runner_tee_prints_progress",
      "qname": "tests.unit.test_run_pyfolds_runner.test_runner_tee_prints_progress",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 48,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner.test_runner_timeout_watchdog",
      "kind": "function",
      "name": "test_runner_timeout_watchdog",
      "qname": "tests.unit.test_run_pyfolds_runner.test_runner_timeout_watchdog",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 63,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_run_pyfolds_runner.test_runner_retry_and_metrics_csv",
      "kind": "function",
      "name": "test_runner_retry_and_metrics_csv",
      "qname": "tests.unit.test_run_pyfolds_runner.test_runner_retry_and_metrics_csv",
      "file": "tests/unit/test_run_pyfolds_runner.py",
      "line": 82,
      "doc": null,
      "params": [
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.test_tf_backend",
      "kind": "module",
      "name": "test_tf_backend",
      "qname": "tests.unit.test_tf_backend",
      "file": "tests/unit/test_tf_backend.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_tf_backend.test_importing_pyfolds_still_works_without_tensorflow",
      "kind": "function",
      "name": "test_importing_pyfolds_still_works_without_tensorflow",
      "qname": "tests.unit.test_tf_backend.test_importing_pyfolds_still_works_without_tensorflow",
      "file": "tests/unit/test_tf_backend.py",
      "line": 6,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_tf_backend.test_tf_backend_guard_when_tensorflow_is_missing",
      "kind": "function",
      "name": "test_tf_backend_guard_when_tensorflow_is_missing",
      "qname": "tests.unit.test_tf_backend.test_tf_backend_guard_when_tensorflow_is_missing",
      "file": "tests/unit/test_tf_backend.py",
      "line": 12,
      "doc": null,
      "params": [
        "monkeypatch"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_tf_backend.test_tf_cell_state_and_step_contract",
      "kind": "function",
      "name": "test_tf_cell_state_and_step_contract",
      "qname": "tests.unit.test_tf_backend.test_tf_cell_state_and_step_contract",
      "file": "tests/unit/test_tf_backend.py",
      "line": 24,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.test_tf_backend.test_tf_layer_integrates_with_keras_rnn",
      "kind": "function",
      "name": "test_tf_layer_integrates_with_keras_rnn",
      "qname": "tests.unit.test_tf_backend.test_tf_layer_integrates_with_keras_rnn",
      "file": "tests/unit/test_tf_backend.py",
      "line": 39,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils",
      "kind": "module",
      "name": "utils",
      "qname": "tests.unit.utils",
      "file": "tests/unit/utils/__init__.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils.test_device",
      "kind": "module",
      "name": "test_device",
      "qname": "tests.unit.utils.test_device",
      "file": "tests/unit/utils/test_device.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_device.TestDevice",
      "kind": "class",
      "name": "TestDevice",
      "qname": "tests.unit.utils.test_device.TestDevice",
      "file": "tests/unit/utils/test_device.py",
      "line": 8,
      "doc": "Test device functions.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_device.TestDevice.test_infer_device",
      "kind": "method",
      "name": "test_infer_device",
      "qname": "tests.unit.utils.test_device.TestDevice.test_infer_device",
      "file": "tests/unit/utils/test_device.py",
      "line": 11,
      "doc": "Test device inference.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_device.TestDevice.test_get_device",
      "kind": "method",
      "name": "test_get_device",
      "qname": "tests.unit.utils.test_device.TestDevice.test_get_device",
      "file": "tests/unit/utils/test_device.py",
      "line": 17,
      "doc": "Test get device.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils.test_math",
      "kind": "module",
      "name": "test_math",
      "qname": "tests.unit.utils.test_math",
      "file": "tests/unit/utils/test_math.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_math.TestMath",
      "kind": "class",
      "name": "TestMath",
      "qname": "tests.unit.utils.test_math.TestMath",
      "file": "tests/unit/utils/test_math.py",
      "line": 9,
      "doc": "Test math functions.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_math.TestMath.test_safe_div",
      "kind": "method",
      "name": "test_safe_div",
      "qname": "tests.unit.utils.test_math.TestMath.test_safe_div",
      "file": "tests/unit/utils/test_math.py",
      "line": 12,
      "doc": "Test safe division.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_math.TestMath.test_clamp_rate",
      "kind": "method",
      "name": "test_clamp_rate",
      "qname": "tests.unit.utils.test_math.TestMath.test_clamp_rate",
      "file": "tests/unit/utils/test_math.py",
      "line": 20,
      "doc": "Test rate clamping.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_math.TestMath.test_clamp_R",
      "kind": "method",
      "name": "test_clamp_R",
      "qname": "tests.unit.utils.test_math.TestMath.test_clamp_R",
      "file": "tests/unit/utils/test_math.py",
      "line": 28,
      "doc": "Test neuromodulator clamping.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_math.TestMath.test_safe_weight_law_is_bounded_and_finite",
      "kind": "method",
      "name": "test_safe_weight_law_is_bounded_and_finite",
      "qname": "tests.unit.utils.test_math.TestMath.test_safe_weight_law_is_bounded_and_finite",
      "file": "tests/unit/utils/test_math.py",
      "line": 36,
      "doc": "Safe weight law should cap very large N and avoid NaN/Inf.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils.test_types",
      "kind": "module",
      "name": "test_types",
      "qname": "tests.unit.utils.test_types",
      "file": "tests/unit/utils/test_types.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_types.TestTypes",
      "kind": "class",
      "name": "TestTypes",
      "qname": "tests.unit.utils.test_types.TestTypes",
      "file": "tests/unit/utils/test_types.py",
      "line": 7,
      "doc": "Test types and enums.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_types.TestTypes.test_learning_mode",
      "kind": "method",
      "name": "test_learning_mode",
      "qname": "tests.unit.utils.test_types.TestTypes.test_learning_mode",
      "file": "tests/unit/utils/test_types.py",
      "line": 10,
      "doc": "Test learning mode enum.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_types.TestTypes.test_connection_type",
      "kind": "method",
      "name": "test_connection_type",
      "qname": "tests.unit.utils.test_types.TestTypes.test_connection_type",
      "file": "tests/unit/utils/test_types.py",
      "line": 16,
      "doc": "Test connection type enum.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils.test_utils",
      "kind": "module",
      "name": "test_utils",
      "qname": "tests.unit.utils.test_utils",
      "file": "tests/unit/utils/test_utils.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_utils.TestMath",
      "kind": "class",
      "name": "TestMath",
      "qname": "tests.unit.utils.test_utils.TestMath",
      "file": "tests/unit/utils/test_utils.py",
      "line": 56,
      "doc": "Testes para funções matemáticas (math.py).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_safe_div_basic",
      "kind": "method",
      "name": "test_safe_div_basic",
      "qname": "tests.unit.utils.test_utils.TestMath.test_safe_div_basic",
      "file": "tests/unit/utils/test_utils.py",
      "line": 59,
      "doc": "Testa divisão normal.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_safe_div_by_zero",
      "kind": "method",
      "name": "test_safe_div_by_zero",
      "qname": "tests.unit.utils.test_utils.TestMath.test_safe_div_by_zero",
      "file": "tests/unit/utils/test_utils.py",
      "line": 67,
      "doc": "Testa divisão por zero com epsilon.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_rate_tensor",
      "kind": "method",
      "name": "test_clamp_rate_tensor",
      "qname": "tests.unit.utils.test_utils.TestMath.test_clamp_rate_tensor",
      "file": "tests/unit/utils/test_utils.py",
      "line": 75,
      "doc": "Testa clamp_rate com tensor.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_rate_float",
      "kind": "method",
      "name": "test_clamp_rate_float",
      "qname": "tests.unit.utils.test_utils.TestMath.test_clamp_rate_float",
      "file": "tests/unit/utils/test_utils.py",
      "line": 82,
      "doc": "Testa clamp_rate com float.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_R_tensor",
      "kind": "method",
      "name": "test_clamp_R_tensor",
      "qname": "tests.unit.utils.test_utils.TestMath.test_clamp_R_tensor",
      "file": "tests/unit/utils/test_utils.py",
      "line": 89,
      "doc": "Testa clamp_R com tensor.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_R_float",
      "kind": "method",
      "name": "test_clamp_R_float",
      "qname": "tests.unit.utils.test_utils.TestMath.test_clamp_R_float",
      "file": "tests/unit/utils/test_utils.py",
      "line": 96,
      "doc": "Testa clamp_R com float.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_xavier_init_shape",
      "kind": "method",
      "name": "test_xavier_init_shape",
      "qname": "tests.unit.utils.test_utils.TestMath.test_xavier_init_shape",
      "file": "tests/unit/utils/test_utils.py",
      "line": 104,
      "doc": "Testa se xavier_init retorna shape correto.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_xavier_init_gain",
      "kind": "method",
      "name": "test_xavier_init_gain",
      "qname": "tests.unit.utils.test_utils.TestMath.test_xavier_init_gain",
      "file": "tests/unit/utils/test_utils.py",
      "line": 110,
      "doc": "Testa se gain altera escala.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestMath.test_calculate_vc_dimension",
      "kind": "method",
      "name": "test_calculate_vc_dimension",
      "qname": "tests.unit.utils.test_utils.TestMath.test_calculate_vc_dimension",
      "file": "tests/unit/utils/test_utils.py",
      "line": 116,
      "doc": "Testa cálculo de VC-dimension.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_utils.TestDevice",
      "kind": "class",
      "name": "TestDevice",
      "qname": "tests.unit.utils.test_utils.TestDevice",
      "file": "tests/unit/utils/test_utils.py",
      "line": 137,
      "doc": "Testes para gerenciamento de device (device.py).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_none",
      "kind": "method",
      "name": "test_infer_device_none",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_infer_device_none",
      "file": "tests/unit/utils/test_utils.py",
      "line": 140,
      "doc": "Testa infer_device com None.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cpu",
      "kind": "method",
      "name": "test_infer_device_tensor_cpu",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cpu",
      "file": "tests/unit/utils/test_utils.py",
      "line": 145,
      "doc": "Testa infer_device com tensor CPU.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cuda",
      "kind": "method",
      "name": "test_infer_device_tensor_cuda",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cuda",
      "file": "tests/unit/utils/test_utils.py",
      "line": 151,
      "doc": "Testa infer_device com tensor CUDA (se disponível).",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_dict",
      "kind": "method",
      "name": "test_infer_device_dict",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_infer_device_dict",
      "file": "tests/unit/utils/test_utils.py",
      "line": 158,
      "doc": "Testa infer_device com dicionário.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_empty_dict",
      "kind": "method",
      "name": "test_infer_device_empty_dict",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_infer_device_empty_dict",
      "file": "tests/unit/utils/test_utils.py",
      "line": 167,
      "doc": "Testa infer_device com dicionário vazio.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_ensure_device_no_change",
      "kind": "method",
      "name": "test_ensure_device_no_change",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_ensure_device_no_change",
      "file": "tests/unit/utils/test_utils.py",
      "line": 172,
      "doc": "Testa ensure_device sem device especificado.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_ensure_device_move",
      "kind": "method",
      "name": "test_ensure_device_move",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_ensure_device_move",
      "file": "tests/unit/utils/test_utils.py",
      "line": 180,
      "doc": "Testa ensure_device movendo tensor.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_get_device_default",
      "kind": "method",
      "name": "test_get_device_default",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_get_device_default",
      "file": "tests/unit/utils/test_utils.py",
      "line": 190,
      "doc": "Testa get_device sem argumentos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestDevice.test_get_device_specific",
      "kind": "method",
      "name": "test_get_device_specific",
      "qname": "tests.unit.utils.test_utils.TestDevice.test_get_device_specific",
      "file": "tests/unit/utils/test_utils.py",
      "line": 198,
      "doc": "Testa get_device com device específico.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_utils.TestTypes",
      "kind": "class",
      "name": "TestTypes",
      "qname": "tests.unit.utils.test_utils.TestTypes",
      "file": "tests/unit/utils/test_utils.py",
      "line": 212,
      "doc": "Testes para tipos e enums (types.py).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_mode_values",
      "kind": "method",
      "name": "test_learning_mode_values",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_learning_mode_values",
      "file": "tests/unit/utils/test_utils.py",
      "line": 215,
      "doc": "Testa valores do enum LearningMode.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_mode_description",
      "kind": "method",
      "name": "test_learning_mode_description",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_learning_mode_description",
      "file": "tests/unit/utils/test_utils.py",
      "line": 222,
      "doc": "Testa descriptions do LearningMode.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_rate_multiplier",
      "kind": "method",
      "name": "test_learning_rate_multiplier",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_learning_rate_multiplier",
      "file": "tests/unit/utils/test_utils.py",
      "line": 229,
      "doc": "Testa multiplicadores de learning rate.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_is_learning",
      "kind": "method",
      "name": "test_is_learning",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_is_learning",
      "file": "tests/unit/utils/test_utils.py",
      "line": 236,
      "doc": "Testa is_learning().",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_is_consolidating",
      "kind": "method",
      "name": "test_is_consolidating",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_is_consolidating",
      "file": "tests/unit/utils/test_utils.py",
      "line": 243,
      "doc": "Testa is_consolidating().",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_connection_type",
      "kind": "method",
      "name": "test_connection_type",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_connection_type",
      "file": "tests/unit/utils/test_utils.py",
      "line": 250,
      "doc": "Testa ConnectionType enum.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_defaults",
      "kind": "method",
      "name": "test_mode_config_defaults",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_mode_config_defaults",
      "file": "tests/unit/utils/test_utils.py",
      "line": 256,
      "doc": "Testa valores padrão do ModeConfig.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_get_learning_rate",
      "kind": "method",
      "name": "test_mode_config_get_learning_rate",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_mode_config_get_learning_rate",
      "file": "tests/unit/utils/test_utils.py",
      "line": 263,
      "doc": "Testa get_learning_rate().",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_get_consolidation_factor",
      "kind": "method",
      "name": "test_mode_config_get_consolidation_factor",
      "qname": "tests.unit.utils.test_utils.TestTypes.test_mode_config_get_consolidation_factor",
      "file": "tests/unit/utils/test_utils.py",
      "line": 280,
      "doc": "Testa get_consolidation_factor().",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_utils.TestLogging",
      "kind": "class",
      "name": "TestLogging",
      "qname": "tests.unit.utils.test_utils.TestLogging",
      "file": "tests/unit/utils/test_utils.py",
      "line": 294,
      "doc": "Testes para logging profissional (logging.py).",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_trace_level_defined",
      "kind": "method",
      "name": "test_trace_level_defined",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_trace_level_defined",
      "file": "tests/unit/utils/test_utils.py",
      "line": 297,
      "doc": "Testa se TRACE_LEVEL está definido.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_trace_method_exists",
      "kind": "method",
      "name": "test_trace_method_exists",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_trace_method_exists",
      "file": "tests/unit/utils/test_utils.py",
      "line": 302,
      "doc": "Testa se método trace foi adicionado ao Logger.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_get_logger",
      "kind": "method",
      "name": "test_get_logger",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_get_logger",
      "file": "tests/unit/utils/test_utils.py",
      "line": 308,
      "doc": "Testa get_logger().",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_pyfolds_logger_singleton",
      "kind": "method",
      "name": "test_pyfolds_logger_singleton",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_pyfolds_logger_singleton",
      "file": "tests/unit/utils/test_utils.py",
      "line": 314,
      "doc": "Testa se PyFoldsLogger é singleton.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_setup_basic",
      "kind": "method",
      "name": "test_logger_setup_basic",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_setup_basic",
      "file": "tests/unit/utils/test_utils.py",
      "line": 320,
      "doc": "Testa configuração básica do logger com console silencioso por padrão.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_trace_output",
      "kind": "method",
      "name": "test_logger_trace_output",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_trace_output",
      "file": "tests/unit/utils/test_utils.py",
      "line": 333,
      "doc": "Testa se nível TRACE pode ser usado sem erro.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_trace_silent_when_lower_level",
      "kind": "method",
      "name": "test_logger_trace_silent_when_lower_level",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_trace_silent_when_lower_level",
      "file": "tests/unit/utils/test_utils.py",
      "line": 343,
      "doc": "Testa se trace não loga quando nível mais baixo.",
      "params": [
        "self",
        "capsys"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_import_pyfolds_does_not_add_stream_handler",
      "kind": "method",
      "name": "test_import_pyfolds_does_not_add_stream_handler",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_import_pyfolds_does_not_add_stream_handler",
      "file": "tests/unit/utils/test_utils.py",
      "line": 355,
      "doc": "Import não deve configurar handlers automaticamente.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_setup_run_logging_returns_logger_and_path",
      "kind": "method",
      "name": "test_setup_run_logging_returns_logger_and_path",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_setup_run_logging_returns_logger_and_path",
      "file": "tests/unit/utils/test_utils.py",
      "line": 374,
      "doc": "Helper de setup deve criar arquivo incremental e logger configurado.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_file_handler",
      "kind": "method",
      "name": "test_logger_file_handler",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_file_handler",
      "file": "tests/unit/utils/test_utils.py",
      "line": 389,
      "doc": "Testa se logger escreve em arquivo.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_console_false_keeps_terminal_clean",
      "kind": "method",
      "name": "test_logger_console_false_keeps_terminal_clean",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_console_false_keeps_terminal_clean",
      "file": "tests/unit/utils/test_utils.py",
      "line": 408,
      "doc": "Com console=False, logs não devem ir para stdout/stderr.",
      "params": [
        "self",
        "tmp_path",
        "capsys"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_fixed_layout",
      "kind": "method",
      "name": "test_logger_fixed_layout",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_fixed_layout",
      "file": "tests/unit/utils/test_utils.py",
      "line": 423,
      "doc": "Valida layout fixo de colunas para auditoria.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_build_log_path_increments_counter",
      "kind": "method",
      "name": "test_build_log_path_increments_counter",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_build_log_path_increments_counter",
      "file": "tests/unit/utils/test_utils.py",
      "line": 438,
      "doc": "Valida nome incremental NNN_app_version_timestamp.log.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_next_log_path_alias",
      "kind": "method",
      "name": "test_next_log_path_alias",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_next_log_path_alias",
      "file": "tests/unit/utils/test_utils.py",
      "line": 448,
      "doc": "`next_log_path` deve manter contrato de nome incremental.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_circular_buffer_file_handler",
      "kind": "method",
      "name": "test_logger_circular_buffer_file_handler",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_logger_circular_buffer_file_handler",
      "file": "tests/unit/utils/test_utils.py",
      "line": 457,
      "doc": "Testa escrita em TXT com comportamento circular por número de linhas.",
      "params": [
        "self",
        "tmp_path"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_multiple_loggers_same_name",
      "kind": "method",
      "name": "test_multiple_loggers_same_name",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_multiple_loggers_same_name",
      "file": "tests/unit/utils/test_utils.py",
      "line": 474,
      "doc": "Testa se get_logger com mesmo nome retorna mesmo logger.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestLogging.test_module_levels",
      "kind": "method",
      "name": "test_module_levels",
      "qname": "tests.unit.utils.test_utils.TestLogging.test_module_levels",
      "file": "tests/unit/utils/test_utils.py",
      "line": 480,
      "doc": "Testa configuração de níveis por módulo.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "cls:tests.unit.utils.test_utils.TestIntegration",
      "kind": "class",
      "name": "TestIntegration",
      "qname": "tests.unit.utils.test_utils.TestIntegration",
      "file": "tests/unit/utils/test_utils.py",
      "line": 502,
      "doc": "Testes que integram múltiplos módulos.",
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestIntegration.test_logging_with_device",
      "kind": "method",
      "name": "test_logging_with_device",
      "qname": "tests.unit.utils.test_utils.TestIntegration.test_logging_with_device",
      "file": "tests/unit/utils/test_utils.py",
      "line": 505,
      "doc": "Testa logging + device juntos.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestIntegration.test_learning_mode_with_math",
      "kind": "method",
      "name": "test_learning_mode_with_math",
      "qname": "tests.unit.utils.test_utils.TestIntegration.test_learning_mode_with_math",
      "file": "tests/unit/utils/test_utils.py",
      "line": 513,
      "doc": "Testa LearningMode + funções matemáticas.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mtd:tests.unit.utils.test_utils.TestIntegration.test_device_with_tensor_ops",
      "kind": "method",
      "name": "test_device_with_tensor_ops",
      "qname": "tests.unit.utils.test_utils.TestIntegration.test_device_with_tensor_ops",
      "file": "tests/unit/utils/test_utils.py",
      "line": 523,
      "doc": "Testa device com operações de tensor.",
      "params": [
        "self"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.utils.test_validation",
      "kind": "module",
      "name": "test_validation",
      "qname": "tests.unit.utils.test_validation",
      "file": "tests/unit/utils/test_validation.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.utils.test_validation.test_neuron_forward_validation_ndim",
      "kind": "function",
      "name": "test_neuron_forward_validation_ndim",
      "qname": "tests.unit.utils.test_validation.test_neuron_forward_validation_ndim",
      "file": "tests/unit/utils/test_validation.py",
      "line": 7,
      "doc": null,
      "params": [
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.utils.test_validation.test_neuron_forward_validation_dtype",
      "kind": "function",
      "name": "test_neuron_forward_validation_dtype",
      "qname": "tests.unit.utils.test_validation.test_neuron_forward_validation_dtype",
      "file": "tests/unit/utils/test_validation.py",
      "line": 15,
      "doc": null,
      "params": [
        "small_config"
      ],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.wave.test_wave_config",
      "kind": "module",
      "name": "test_wave_config",
      "qname": "tests.unit.wave.test_wave_config",
      "file": "tests/unit/wave/test_wave_config.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_config.test_wave_config_defaults_valid",
      "kind": "function",
      "name": "test_wave_config_defaults_valid",
      "qname": "tests.unit.wave.test_wave_config.test_wave_config_defaults_valid",
      "file": "tests/unit/wave/test_wave_config.py",
      "line": 6,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_config.test_wave_config_rejects_invalid_buffer",
      "kind": "function",
      "name": "test_wave_config_rejects_invalid_buffer",
      "qname": "tests.unit.wave.test_wave_config.test_wave_config_rejects_invalid_buffer",
      "file": "tests/unit/wave/test_wave_config.py",
      "line": 12,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.wave.test_wave_layer_network",
      "kind": "module",
      "name": "test_wave_layer_network",
      "qname": "tests.unit.wave.test_wave_layer_network",
      "file": "tests/unit/wave/test_wave_layer_network.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_layer_network.test_wave_layer_exposes_wave_outputs",
      "kind": "function",
      "name": "test_wave_layer_exposes_wave_outputs",
      "qname": "tests.unit.wave.test_wave_layer_network.test_wave_layer_exposes_wave_outputs",
      "file": "tests/unit/wave/test_wave_layer_network.py",
      "line": 6,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_layer_network.test_wave_network_forwards_layer_kwargs",
      "kind": "function",
      "name": "test_wave_network_forwards_layer_kwargs",
      "qname": "tests.unit.wave.test_wave_layer_network.test_wave_network_forwards_layer_kwargs",
      "file": "tests/unit/wave/test_wave_layer_network.py",
      "line": 19,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "mod:tests.unit.wave.test_wave_neuron",
      "kind": "module",
      "name": "test_wave_neuron",
      "qname": "tests.unit.wave.test_wave_neuron",
      "file": "tests/unit/wave/test_wave_neuron.py",
      "line": 1,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_neuron.test_wave_outputs_quadrature_and_phase_range",
      "kind": "function",
      "name": "test_wave_outputs_quadrature_and_phase_range",
      "qname": "tests.unit.wave.test_wave_neuron.test_wave_outputs_quadrature_and_phase_range",
      "file": "tests/unit/wave/test_wave_neuron.py",
      "line": 6,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_neuron.test_cooperative_integration_uses_multiple_dendrites",
      "kind": "function",
      "name": "test_cooperative_integration_uses_multiple_dendrites",
      "qname": "tests.unit.wave.test_wave_neuron.test_cooperative_integration_uses_multiple_dendrites",
      "file": "tests/unit/wave/test_wave_neuron.py",
      "line": 18,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    },
    {
      "id": "fn:tests.unit.wave.test_wave_neuron.test_wave_step_id_thread_safe_increment",
      "kind": "function",
      "name": "test_wave_step_id_thread_safe_increment",
      "qname": "tests.unit.wave.test_wave_neuron.test_wave_step_id_thread_safe_increment",
      "file": "tests/unit/wave/test_wave_neuron.py",
      "line": 32,
      "doc": null,
      "params": [],
      "returns": null,
      "bases": [],
      "decorators": []
    }
  ],
  "edges": [
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.core.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.layers",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.network",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.core.neuron_v2",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.utils.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.utils.context",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.wave",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.core.factory",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.serialization",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.monitoring",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.telemetry",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds",
      "dst": "mod:src.advanced",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds",
      "dst": "fn:src.pyfolds.__getattr__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.refractory",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.stdp",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.adaptation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.short_term",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.backprop",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.pyfolds.inhibition",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.wave",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.layers.layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced",
      "dst": "mod:src.utils.logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced",
      "dst": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.BackpropMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.ShortTermDynamicsMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.STDPMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.AdaptationMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.RefractoryMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "cls:*.MPJRDNeuronBase",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced._init_advanced_mixins",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.get_all_advanced_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDNeuronAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDNeuronAdvanced.reset_all_mechanisms",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced",
      "dst": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.BackpropMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.ShortTermDynamicsMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.STDPMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.AdaptationMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.RefractoryMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "cls:*.MPJRDWaveNeuronBase",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDWaveNeuronAdvanced.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced",
      "dst": "cls:src.pyfolds.advanced.MPJRDLayerAdvanced",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDLayerAdvanced",
      "dst": "cls:*.MPJRDLayer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDLayerAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDLayerAdvanced.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced",
      "dst": "cls:src.pyfolds.advanced.MPJRDWaveLayerAdvanced",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveLayerAdvanced",
      "dst": "cls:*.MPJRDLayer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.MPJRDWaveLayerAdvanced",
      "dst": "mtd:src.pyfolds.advanced.MPJRDWaveLayerAdvanced.__init__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.adaptation",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.adaptation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.adaptation",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.adaptation",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.adaptation",
      "dst": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._init_adaptation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._ensure_adaptation_current",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._apply_sfa_before_threshold",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._update_adaptation_after_spike",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin._apply_adaptation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.adaptation.AdaptationMixin",
      "dst": "mtd:src.pyfolds.advanced.adaptation.AdaptationMixin.forward",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "mod:collections",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "mod:src.pyfolds.advanced.time_mixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.backprop",
      "dst": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "cls:*.TimedMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._init_backprop",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._ensure_backprop_trace",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._schedule_backprop",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin._process_backprop_queue",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.reset_backprop",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.backprop.BackpropMixin",
      "dst": "mtd:src.pyfolds.advanced.backprop.BackpropMixin.get_backprop_metrics",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._init_E2I_weights",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._init_I2E_weights",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer._create_lateral_kernel",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.apply_inhibition",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.get_inhibition_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionLayer",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionLayer.extra_repr",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.inhibition",
      "dst": "cls:src.pyfolds.advanced.inhibition.InhibitionMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionMixin",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin._init_inhibition",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionMixin",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.inhibition.InhibitionMixin",
      "dst": "mtd:src.pyfolds.advanced.inhibition.InhibitionMixin.get_inhibition_metrics",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.refractory",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.refractory",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.refractory",
      "dst": "mod:src.pyfolds.advanced.time_mixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.refractory",
      "dst": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "cls:*.TimedMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._init_refractory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._ensure_last_spike_time",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._check_refractory_batch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin._update_refractory_batch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.reset_refractory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.refractory.RefractoryMixin",
      "dst": "mtd:src.pyfolds.advanced.refractory.RefractoryMixin.get_refractory_metrics",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.short_term",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.short_term",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.short_term",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.short_term",
      "dst": "cls:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "dst": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._init_short_term",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "dst": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin._update_short_term_dynamics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin",
      "dst": "mtd:src.pyfolds.advanced.short_term.ShortTermDynamicsMixin.forward",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.stdp",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.stdp",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.stdp",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.stdp",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.stdp",
      "dst": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin._init_stdp",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin._ensure_traces",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin._stdp_pre_spike_source",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin._update_stdp_traces",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin._should_apply_stdp",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.stdp.STDPMixin",
      "dst": "mtd:src.pyfolds.advanced.stdp.STDPMixin.forward",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.advanced.time_mixin",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.advanced.time_mixin",
      "dst": "cls:src.pyfolds.advanced.time_mixin.TimedMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.time_mixin.TimedMixin",
      "dst": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._ensure_time_counter",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.time_mixin.TimedMixin",
      "dst": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._increment_time",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.advanced.time_mixin.TimedMixin",
      "dst": "mtd:src.pyfolds.advanced.time_mixin.TimedMixin._get_time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts",
      "dst": "mod:src.pyfolds.neuron_contract",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts",
      "dst": "mod:src.pyfolds.backends",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:numpy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "mod:src.pyfolds.contracts.neuron_contract",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "cls:src.pyfolds.contracts.backends._State",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "cls:src.pyfolds.contracts.backends._BaseContractBackend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.contracts.backends._BaseContractBackend",
      "dst": "mtd:src.pyfolds.contracts.backends._BaseContractBackend.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.contracts.backends._BaseContractBackend",
      "dst": "mtd:src.pyfolds.contracts.backends._BaseContractBackend._trace",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "cls:src.pyfolds.contracts.backends.TorchNeuronContractBackend",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.contracts.backends.TorchNeuronContractBackend",
      "dst": "cls:*._BaseContractBackend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.contracts.backends.TorchNeuronContractBackend",
      "dst": "mtd:src.pyfolds.contracts.backends.TorchNeuronContractBackend.run_step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.backends",
      "dst": "cls:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend",
      "dst": "cls:*._BaseContractBackend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend",
      "dst": "mtd:src.pyfolds.contracts.backends.TensorFlowNeuronContractBackend.run_step",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "cls:src.pyfolds.contracts.neuron_contract.MechanismStep",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.contracts.neuron_contract.MechanismStep",
      "dst": "cls:*.str",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.contracts.neuron_contract.MechanismStep",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "cls:src.pyfolds.contracts.neuron_contract.NeuronStepInput",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "cls:src.pyfolds.contracts.neuron_contract.StepExecutionTrace",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "cls:src.pyfolds.contracts.neuron_contract.NeuronStepOutput",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "cls:src.pyfolds.contracts.neuron_contract.ContractViolation",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.contracts.neuron_contract.ContractViolation",
      "dst": "cls:*.ValueError",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.contracts.neuron_contract",
      "dst": "fn:src.pyfolds.contracts.neuron_contract.validate_step_output",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.neuron_v2",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.dendrite",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.synapse",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.homeostasis",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.neuromodulation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.accumulator",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.dendrite_integration",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core",
      "dst": "mod:src.pyfolds.factory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core",
      "dst": "fn:src.pyfolds.core.create_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core",
      "dst": "fn:src.pyfolds.core.create_neuron_v2",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core",
      "dst": "fn:src.pyfolds.core.create_accumulator",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core",
      "dst": "fn:src.pyfolds.core.demo",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "mod:collections",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "cls:src.pyfolds.core.accumulator.AccumulatedStats",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.AccumulatedStats",
      "dst": "mtd:src.pyfolds.core.accumulator.AccumulatedStats.is_valid",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.AccumulatedStats",
      "dst": "mtd:src.pyfolds.core.accumulator.AccumulatedStats.__repr__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.history",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.enable_history",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.reset",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.accumulate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator._update_history",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.get_averages",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.plot_history",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.has_data",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.batch_count",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.accumulator.StatisticsAccumulator",
      "dst": "mtd:src.pyfolds.core.accumulator.StatisticsAccumulator.extra_repr",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.accumulator",
      "dst": "fn:src.pyfolds.core.accumulator.create_accumulator_from_config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.base",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.base",
      "dst": "mod:abc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.base",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.base",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.base",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.base",
      "dst": "cls:src.pyfolds.core.base.BasePlasticityRule",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.base.BasePlasticityRule",
      "dst": "cls:*.ABC",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.base.BasePlasticityRule",
      "dst": "mtd:src.pyfolds.core.base.BasePlasticityRule.update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.base",
      "dst": "cls:src.pyfolds.core.base.BaseNeuron",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.base.BaseNeuron",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.base.BaseNeuron",
      "dst": "cls:*.ABC",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.base.BaseNeuron",
      "dst": "mtd:src.pyfolds.core.base.BaseNeuron.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.base.BaseNeuron",
      "dst": "mtd:src.pyfolds.core.base.BaseNeuron.apply_plasticity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.base.BaseNeuron",
      "dst": "mtd:src.pyfolds.core.base.BaseNeuron.get_metrics",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.config",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.config",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.config",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.config",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.config",
      "dst": "cls:src.pyfolds.core.config.MPJRDConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.__post_init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.validate_numerical_safety",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.get_ts",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.get_decay_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.to_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.from_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.get_preset",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.config.MPJRDConfig",
      "dst": "mtd:src.pyfolds.core.config.MPJRDConfig.__repr__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "mod:src.pyfolds.core.synapse",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.dendrite",
      "dst": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._ensure_cache_valid",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._invalidate_cache",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.N",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.I",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.u",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.R",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.W",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite._validate_finite",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.update_synapses_rate_based",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.consolidate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.get_states",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.load_states",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite.MPJRDDendrite",
      "dst": "mtd:src.pyfolds.core.dendrite.MPJRDDendrite.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "cls:src.pyfolds.core.dendrite_integration.DendriticOutput",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticOutput",
      "dst": "cls:*.NamedTuple",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.dendrite_integration",
      "dst": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "dst": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "dst": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration._theta_dend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "dst": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.dendrite_integration.DendriticIntegration",
      "dst": "mtd:src.pyfolds.core.dendrite_integration.DendriticIntegration.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "cls:src.pyfolds.core.factory.NeuronType",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.factory.NeuronType",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "cls:src.pyfolds.core.factory.NeuronFactory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.factory.NeuronFactory",
      "dst": "mtd:src.pyfolds.core.factory.NeuronFactory.register",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.factory.NeuronFactory",
      "dst": "mtd:src.pyfolds.core.factory.NeuronFactory.create",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.factory.NeuronFactory",
      "dst": "mtd:src.pyfolds.core.factory.NeuronFactory.is_registered",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "fn:src.pyfolds.core.factory.register_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "fn:src.pyfolds.core.factory.register_default_neurons",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "fn:src.pyfolds.core.factory.infer_neuron_type",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.factory",
      "dst": "fn:src.pyfolds.core.factory.get_available_types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.homeostasis",
      "dst": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController._check_stability_change",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.on_stable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.on_unstable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.reset",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.homeostasis_error",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.is_stable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.stability_ratio",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.homeostasis.HomeostasisController",
      "dst": "mtd:src.pyfolds.core.homeostasis.HomeostasisController.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.neuromodulation",
      "dst": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "dst": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "dst": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuromodulation.Neuromodulator",
      "dst": "mtd:src.pyfolds.core.neuromodulation.Neuromodulator.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.dendrite",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.homeostasis",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.neuromodulation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.accumulator",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.core.dendrite_integration",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.utils.validation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "mod:src.pyfolds.utils.logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.neuron",
      "dst": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "cls:*.BaseNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._validate_internal_devices",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_stable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._on_homeostasis_unstable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.N",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.I",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.W",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.protection",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.theta",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.r_hat",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.set_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._compute_R_endogenous",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._validate_input_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron._apply_online_plasticity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.apply_plasticity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.sleep",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.to",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.get_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron.MPJRDNeuron",
      "dst": "mtd:src.pyfolds.core.neuron.MPJRDNeuron.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron_v2",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron_v2",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron_v2",
      "dst": "mod:src.pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.neuron_v2",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.neuron_v2",
      "dst": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "dst": "cls:*.MPJRDNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "dst": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "dst": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2._telemetry_forward_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.neuron_v2.MPJRDNeuronV2",
      "dst": "mtd:src.pyfolds.core.neuron_v2.MPJRDNeuronV2.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "mod:src.pyfolds.utils.math",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.core.synapse",
      "dst": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.W",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse._update_with_soft_saturation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.consolidate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.get_state",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.load_state",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.core.synapse.MPJRDSynapse",
      "dst": "mtd:src.pyfolds.core.synapse.MPJRDSynapse.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:src.pyfolds.core.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:src.pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.factory",
      "dst": "mod:src.pyfolds.wave.neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.factory",
      "dst": "cls:src.pyfolds.factory.NeuronType",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.factory.NeuronType",
      "dst": "cls:*.str",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.factory.NeuronType",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.factory",
      "dst": "cls:src.pyfolds.factory.NeuronFactory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.factory.NeuronFactory",
      "dst": "mtd:src.pyfolds.factory.NeuronFactory.register",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.factory.NeuronFactory",
      "dst": "mtd:src.pyfolds.factory.NeuronFactory.create",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers",
      "dst": "mod:src.pyfolds.layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers",
      "dst": "mod:src.pyfolds.wave_layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:src.pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.layers.layer",
      "dst": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.n_dendrites",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.n_synapses",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.theta_mean",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.r_hat_mean",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer._prepare_input",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.set_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.apply_batch_update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.sleep",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.get_all_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.get_layer_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.layer.MPJRDLayer",
      "dst": "mtd:src.pyfolds.layers.layer.MPJRDLayer.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.wave_layer",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.wave_layer",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.wave_layer",
      "dst": "mod:src.pyfolds.layers.layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.layers.wave_layer",
      "dst": "mod:src.pyfolds.wave",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.layers.wave_layer",
      "dst": "cls:src.pyfolds.layers.wave_layer.MPJRDWaveLayer",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.layers.wave_layer.MPJRDWaveLayer",
      "dst": "cls:*.MPJRDLayer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.layers.wave_layer.MPJRDWaveLayer",
      "dst": "mtd:src.pyfolds.layers.wave_layer.MPJRDWaveLayer.__init__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.monitoring",
      "dst": "mod:src.pyfolds.health",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "cls:src.pyfolds.monitoring.health.HealthStatus",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.monitoring.health.HealthStatus",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "cls:src.pyfolds.monitoring.health.NeuronHealthCheck",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.monitoring.health.NeuronHealthCheck",
      "dst": "mtd:src.pyfolds.monitoring.health.NeuronHealthCheck.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.monitoring.health.NeuronHealthCheck",
      "dst": "mtd:src.pyfolds.monitoring.health.NeuronHealthCheck.check",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.monitoring.health",
      "dst": "cls:src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "dst": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "dst": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.check_health",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.monitoring.health.NeuronHealthMonitor",
      "dst": "mtd:src.pyfolds.monitoring.health.NeuronHealthMonitor.get_health_score",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network",
      "dst": "mod:src.pyfolds.network",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network",
      "dst": "mod:src.pyfolds.wave_network",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network",
      "dst": "mod:src.pyfolds.builder",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "mod:src.pyfolds.layers.layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "mod:src.pyfolds.network.network",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.network.builder",
      "dst": "cls:src.pyfolds.network.builder.NetworkBuilder",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.builder.NetworkBuilder",
      "dst": "mtd:src.pyfolds.network.builder.NetworkBuilder.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.builder.NetworkBuilder",
      "dst": "mtd:src.pyfolds.network.builder.NetworkBuilder.add_layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.builder.NetworkBuilder",
      "dst": "mtd:src.pyfolds.network.builder.NetworkBuilder.build",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:collections",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:src.pyfolds.layers",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.network",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.network.network",
      "dst": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.add_layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.connect",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork._has_cycle",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork._topological_sort",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork._prepare_input_for_layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.build",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.set_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.apply_batch_update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.sleep",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.get_all_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.get_network_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.network.MPJRDNetwork",
      "dst": "mtd:src.pyfolds.network.network.MPJRDNetwork.extra_repr",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.wave_network",
      "dst": "mod:src.pyfolds.layers",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.wave_network",
      "dst": "mod:src.pyfolds.wave",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.network.wave_network",
      "dst": "mod:src.pyfolds.network.network",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.network.wave_network",
      "dst": "cls:src.pyfolds.network.wave_network.MPJRDWaveNetwork",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.network.wave_network.MPJRDWaveNetwork",
      "dst": "cls:*.MPJRDNetwork",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.network.wave_network.MPJRDWaveNetwork",
      "dst": "mtd:src.pyfolds.network.wave_network.MPJRDWaveNetwork.add_wave_layer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization",
      "dst": "mod:src.pyfolds.foldio",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization",
      "dst": "mod:src.pyfolds.versioned_checkpoint",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization",
      "dst": "mod:src.pyfolds.ecc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization",
      "dst": "mod:src.pyfolds.foldio",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "cls:src.pyfolds.serialization.ecc.ECCResult",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "cls:src.pyfolds.serialization.ecc.ECCCodec",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.serialization.ecc.ECCCodec",
      "dst": "cls:*.Protocol",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.ECCCodec",
      "dst": "mtd:src.pyfolds.serialization.ecc.ECCCodec.encode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.ECCCodec",
      "dst": "mtd:src.pyfolds.serialization.ecc.ECCCodec.decode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "cls:src.pyfolds.serialization.ecc.NoECC",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.NoECC",
      "dst": "mtd:src.pyfolds.serialization.ecc.NoECC.encode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.NoECC",
      "dst": "mtd:src.pyfolds.serialization.ecc.NoECC.decode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "cls:src.pyfolds.serialization.ecc.ReedSolomonECC",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.ReedSolomonECC",
      "dst": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.ReedSolomonECC",
      "dst": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.encode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.ecc.ReedSolomonECC",
      "dst": "mtd:src.pyfolds.serialization.ecc.ReedSolomonECC.decode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.ecc",
      "dst": "fn:src.pyfolds.serialization.ecc.ecc_from_protection",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:hashlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:hmac",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:importlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:io",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:json",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:mmap",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:os",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:platform",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:struct",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:subprocess",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:sys",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:numpy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "mod:src.pyfolds.serialization.ecc",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._optional_import",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._init_crc32c_table",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._crc32c_fallback",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "cls:src.pyfolds.serialization.foldio.FoldSecurityError",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldSecurityError",
      "dst": "cls:*.RuntimeError",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.crc32c_u32",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.sha256_hex",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._json_bytes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._canonical_json",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._cfg_to_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._safe_git_hash",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._telemetry_snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._history_snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._build_nuclear_npz",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.read_nuclear_arrays",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__enter__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter.__exit__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter._compress",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter.add_chunk",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldWriter",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldWriter.finalize",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.__enter__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.__exit__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader._read_at",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader._read_header_and_index",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.list_chunks",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader._decompress",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader._ecc_codec",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_chunk_bytes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_json",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio.FoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio.FoldReader.read_torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "cls:src.pyfolds.serialization.foldio._TrustedFoldReader",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.serialization.foldio._TrustedFoldReader",
      "dst": "cls:*.FoldReader",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.foldio._TrustedFoldReader",
      "dst": "mtd:src.pyfolds.serialization.foldio._TrustedFoldReader.read_torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._expression_summary",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._reproducibility_metadata",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._collect_hyperparameters",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._sign_payload_ed25519",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio._verify_payload_signature_ed25519",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.save_fold_or_mind",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.peek_fold_or_mind",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.peek_mind",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.load_fold_or_mind",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.is_mind",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.foldio",
      "dst": "fn:src.pyfolds.serialization.foldio.is_mind_chunks",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:hashlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:subprocess",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:datetime",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.serialization.versioned_checkpoint",
      "dst": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._cfg_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._git_hash",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._metadata",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint._compute_hash",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.save",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.load",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint",
      "dst": "mtd:src.pyfolds.serialization.versioned_checkpoint.VersionedCheckpoint.__repr__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.events",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.ringbuffer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.sinks",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.controller",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.decorator",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry",
      "dst": "mod:src.pyfolds.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:random",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:src.pyfolds.telemetry.events",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:src.pyfolds.telemetry.sinks",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "mod:src.pyfolds.telemetry.ringbuffer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "cls:src.pyfolds.telemetry.controller.TelemetryProfile",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryProfile",
      "dst": "cls:*.str",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryProfile",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "cls:src.pyfolds.telemetry.controller.TelemetryStats",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryStats",
      "dst": "cls:*.TypedDict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "cls:src.pyfolds.telemetry.controller.TelemetryConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryConfig",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryConfig.__post_init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.controller",
      "dst": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.step_count",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController._increment_step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.enabled",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.should_emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.should_emit_sample",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.get_stats",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.controller.TelemetryController",
      "dst": "mtd:src.pyfolds.telemetry.controller.TelemetryController.get_telemetry_metrics",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "mod:functools",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "mod:src.pyfolds.telemetry.controller",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "mod:src.pyfolds.telemetry.events",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.decorator",
      "dst": "fn:src.pyfolds.telemetry.decorator.telemetry",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "cls:src.pyfolds.telemetry.events.TelemetryEvent",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.events.TelemetryEvent",
      "dst": "mtd:src.pyfolds.telemetry.events.TelemetryEvent.payload",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.forward_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.forward_event_lazy",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.commit_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.commit_event_lazy",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.sleep_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.events",
      "dst": "fn:src.pyfolds.telemetry.events.sleep_event_lazy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.ringbuffer",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.ringbuffer",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.ringbuffer",
      "dst": "mod:collections.abc",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.ringbuffer",
      "dst": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.append",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.extend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.capacity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.is_full",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__len__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.ringbuffer.RingBuffer",
      "dst": "mtd:src.pyfolds.telemetry.ringbuffer.RingBuffer.__repr__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:json",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:abc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:src.pyfolds.telemetry.events",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "mod:src.pyfolds.telemetry.ringbuffer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.Sink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "cls:*.ABC",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.Sink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.Sink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.Sink.close",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.Sink.__enter__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.Sink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.Sink.__exit__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "dst": "cls:*.Sink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.NoOpSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.NoOpSink.close",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "cls:*.Sink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.MemorySink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.MemorySink.close",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "dst": "cls:*.Sink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.ConsoleSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.ConsoleSink.close",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "cls:*.Sink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__enter__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.__exit__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink._ensure_open",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink._make_serializable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.JSONLinesSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.JSONLinesSink.close",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.sinks",
      "dst": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "dst": "cls:*.Sink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.flush",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.telemetry.sinks.DistributorSink",
      "dst": "mtd:src.pyfolds.telemetry.sinks.DistributorSink.close",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.telemetry.types",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.types",
      "dst": "cls:src.pyfolds.telemetry.types.ForwardPayload",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.types.ForwardPayload",
      "dst": "cls:*.TypedDict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.types",
      "dst": "cls:src.pyfolds.telemetry.types.CommitPayload",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.types.CommitPayload",
      "dst": "cls:*.TypedDict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.telemetry.types",
      "dst": "cls:src.pyfolds.telemetry.types.SleepPayload",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.telemetry.types.SleepPayload",
      "dst": "cls:*.TypedDict",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf",
      "dst": "mod:importlib.util",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.tf",
      "dst": "fn:src.pyfolds.tf.__getattr__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf.layers",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf.layers",
      "dst": "mod:src.pyfolds.tf.neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.tf.layers",
      "dst": "cls:src.pyfolds.tf.layers.MPJRDTFLayer",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.tf.layers.MPJRDTFLayer",
      "dst": "cls:tf.keras.layers.Layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.layers.MPJRDTFLayer",
      "dst": "mtd:src.pyfolds.tf.layers.MPJRDTFLayer.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.layers.MPJRDTFLayer",
      "dst": "mtd:src.pyfolds.tf.layers.MPJRDTFLayer.call",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf.neuron",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.tf.neuron",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.tf.neuron",
      "dst": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "cls:tf.keras.layers.Layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.state_size",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.output_size",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_initial_state",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.call",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.tf.neuron.MPJRDTFNeuronCell",
      "dst": "mtd:src.pyfolds.tf.neuron.MPJRDTFNeuronCell.get_config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils",
      "dst": "mod:src.pyfolds.math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils",
      "dst": "mod:src.pyfolds.device",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils",
      "dst": "mod:src.pyfolds.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils",
      "dst": "mod:src.pyfolds.logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils",
      "dst": "mod:src.pyfolds.validation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "mod:contextlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "mod:src.pyfolds.core.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.context",
      "dst": "fn:src.pyfolds.utils.context.learning_mode",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "fn:src.pyfolds.utils.device.infer_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "fn:src.pyfolds.utils.device.get_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "fn:src.pyfolds.utils.device.ensure_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.device",
      "dst": "cls:src.pyfolds.utils.device.DeviceManager",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.device.DeviceManager",
      "dst": "mtd:src.pyfolds.utils.device.DeviceManager.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.device.DeviceManager",
      "dst": "mtd:src.pyfolds.utils.device.DeviceManager._validate_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.device.DeviceManager",
      "dst": "mtd:src.pyfolds.utils.device.DeviceManager.to",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.device.DeviceManager",
      "dst": "mtd:src.pyfolds.utils.device.DeviceManager.check_consistency",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:json",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:logging.handlers",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:sys",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:collections",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:datetime",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.trace",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "cls:src.pyfolds.utils.logging.StructuredFormatter",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.logging.StructuredFormatter",
      "dst": "cls:logging.Formatter",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.StructuredFormatter",
      "dst": "mtd:src.pyfolds.utils.logging.StructuredFormatter.format",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "cls:src.pyfolds.utils.logging.FixedLayoutFormatter",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.logging.FixedLayoutFormatter",
      "dst": "cls:logging.Formatter",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.FixedLayoutFormatter",
      "dst": "mtd:src.pyfolds.utils.logging.FixedLayoutFormatter.format",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "dst": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.__new__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "dst": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "dst": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.setup",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "dst": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.get_logger",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.PyFoldsLogger",
      "dst": "mtd:src.pyfolds.utils.logging.PyFoldsLogger.add_file_handler",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.get_logger",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.setup_run_logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.setup_logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "cls:src.pyfolds.utils.logging.CircularBufferFileHandler",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.logging.CircularBufferFileHandler",
      "dst": "cls:logging.Handler",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.CircularBufferFileHandler",
      "dst": "mtd:src.pyfolds.utils.logging.CircularBufferFileHandler.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.logging.CircularBufferFileHandler",
      "dst": "mtd:src.pyfolds.utils.logging.CircularBufferFileHandler.emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.next_log_path",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.logging",
      "dst": "fn:src.pyfolds.utils.logging.build_log_path",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.safe_weight_law",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.safe_div",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.clamp_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.clamp_R",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.xavier_init",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.math",
      "dst": "fn:src.pyfolds.utils.math.calculate_vc_dimension",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "mod:enum",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "cls:src.pyfolds.utils.types.LearningMode",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.types.LearningMode",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.LearningMode",
      "dst": "mtd:src.pyfolds.utils.types.LearningMode.learning_rate_multiplier",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.LearningMode",
      "dst": "mtd:src.pyfolds.utils.types.LearningMode.description",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.LearningMode",
      "dst": "mtd:src.pyfolds.utils.types.LearningMode.is_learning",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.LearningMode",
      "dst": "mtd:src.pyfolds.utils.types.LearningMode.is_consolidating",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "fn:src.pyfolds.utils.types.normalize_learning_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "cls:src.pyfolds.utils.types.ConnectionType",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.types.ConnectionType",
      "dst": "cls:*.Enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "cls:src.pyfolds.utils.types.ModeConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.ModeConfig",
      "dst": "mtd:src.pyfolds.utils.types.ModeConfig.__post_init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.ModeConfig",
      "dst": "mtd:src.pyfolds.utils.types.ModeConfig.get_learning_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.ModeConfig",
      "dst": "mtd:src.pyfolds.utils.types.ModeConfig.get_consolidation_factor",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.ModeConfig",
      "dst": "mtd:src.pyfolds.utils.types.ModeConfig.from_learning_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "cls:src.pyfolds.utils.types.AdaptationOutput",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.utils.types.AdaptationOutput",
      "dst": "cls:*.NamedTuple",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.types",
      "dst": "cls:src.pyfolds.utils.types.AdaptationConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.utils.types.AdaptationConfig",
      "dst": "mtd:src.pyfolds.utils.types.AdaptationConfig.validate",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "mod:functools",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "fn:src.pyfolds.utils.validation.validate_device_consistency",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.utils.validation",
      "dst": "fn:src.pyfolds.utils.validation.validate_input",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave",
      "dst": "mod:src.pyfolds.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave",
      "dst": "mod:src.pyfolds.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.config",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.config",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.config",
      "dst": "mod:src.pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.wave.config",
      "dst": "cls:src.pyfolds.wave.config.MPJRDWaveConfig",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.wave.config.MPJRDWaveConfig",
      "dst": "cls:*.MPJRDConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.config.MPJRDWaveConfig",
      "dst": "mtd:src.pyfolds.wave.config.MPJRDWaveConfig.__post_init__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:src.pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:src.pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:src.pyfolds.utils.validation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "mod:src.pyfolds.wave.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:src.pyfolds.wave.neuron",
      "dst": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "cls:*.MPJRDNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._frequency_for_class",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_phase",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._compute_latency",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron._generate_wave_output",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:src.pyfolds.wave.neuron.MPJRDWaveNeuron",
      "dst": "mtd:src.pyfolds.wave.neuron.MPJRDWaveNeuron.apply_plasticity",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:json",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.checkpoint",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.checkpoint",
      "dst": "cls:tests.checkpoint.CheckpointMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.checkpoint.CheckpointMixin",
      "dst": "mtd:tests.checkpoint.CheckpointMixin.save",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.checkpoint.CheckpointMixin",
      "dst": "mtd:tests.checkpoint.CheckpointMixin.load",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.checkpoint.CheckpointMixin",
      "dst": "mtd:tests.checkpoint.CheckpointMixin.save_weights_only",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.checkpoint.CheckpointMixin",
      "dst": "mtd:tests.checkpoint.CheckpointMixin.load_weights_only",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:functools",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:importlib.util",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:sys",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.conftest",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest._module_requires_torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.pytest_configure",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.pytest_report_header",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.pytest_collection_modifyitems",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.torch_module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest._core_symbols",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.small_config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.full_config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.tiny_config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.small_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.conftest",
      "dst": "fn:tests.conftest.batch_size",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_advanced_integration",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_advanced_integration",
      "dst": "mod:pyfolds.advanced",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_advanced_integration",
      "dst": "mod:pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_advanced_integration",
      "dst": "fn:tests.integration.test_advanced_integration.test_all_mixins_together_smoke",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_mnist_file_logging",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_mnist_file_logging",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_mnist_file_logging",
      "dst": "mod:examples.mnist_file_logging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_mnist_file_logging",
      "dst": "fn:tests.integration.test_mnist_file_logging.test_pyfolds_imports_are_stable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_mnist_file_logging",
      "dst": "fn:tests.integration.test_mnist_file_logging.test_training_script_runs_end_to_end",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_neuron_advanced",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_neuron_advanced",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_neuron_advanced",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_neuron_advanced",
      "dst": "cls:tests.integration.test_neuron_advanced.TestAdvancedNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.integration.test_neuron_advanced.TestAdvancedNeuron",
      "dst": "mtd:tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_full_pipeline",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.integration.test_neuron_advanced.TestAdvancedNeuron",
      "dst": "mtd:tests.integration.test_neuron_advanced.TestAdvancedNeuron.test_backprop_disabled_does_not_apply_dendritic_gain",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "mod:importlib.util",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "fn:tests.integration.test_temporal_sequence_stability.forward_sequence",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "fn:tests.integration.test_temporal_sequence_stability.test_forward_sequence_torch_stability_minimal_criteria",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_temporal_sequence_stability",
      "dst": "fn:tests.integration.test_temporal_sequence_stability.test_tf_sequence_equivalent_stability_minimal_criteria",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_training_loop",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_training_loop",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.integration.test_training_loop",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.integration.test_training_loop",
      "dst": "cls:tests.integration.test_training_loop.TestTrainingLoop",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.integration.test_training_loop.TestTrainingLoop",
      "dst": "mtd:tests.integration.test_training_loop.TestTrainingLoop.test_batch_training",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_batch_speed",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_batch_speed",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_batch_speed",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_batch_speed",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.performance.test_batch_speed",
      "dst": "cls:tests.performance.test_batch_speed.TestBatchSpeed",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.performance.test_batch_speed.TestBatchSpeed",
      "dst": "mtd:tests.performance.test_batch_speed.TestBatchSpeed.test_forward_speed",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_memory_usage",
      "dst": "mod:tracemalloc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_memory_usage",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.performance.test_memory_usage",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.performance.test_memory_usage",
      "dst": "cls:tests.performance.test_memory_usage.TestMemoryUsage",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.performance.test_memory_usage.TestMemoryUsage",
      "dst": "mtd:tests.performance.test_memory_usage.TestMemoryUsage.test_memory_leak",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:hashlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:concurrent.futures",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "fn:tests.test_concurrent_reads._build_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "fn:tests.test_concurrent_reads._read_signature",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_concurrent_reads",
      "dst": "fn:tests.test_concurrent_reads.test_parallel_reads_are_consistent",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:struct",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_corruption_detection",
      "dst": "mod:pyfolds.serialization.foldio",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection._build_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection._write_base_fold",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection.test_bit_flip_is_detected",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection.test_truncation_is_detected",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection.test_invalid_magic_is_rejected",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection.test_huge_index_len_dos_guard",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_corruption_detection",
      "dst": "fn:tests.test_corruption_detection.test_partial_read_raises_eoferror",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_corruption",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_corruption",
      "dst": "mod:pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_corruption",
      "dst": "mod:pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_corruption",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_fold_corruption",
      "dst": "fn:tests.test_fold_corruption.test_fold_corruption_is_detected",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_fuzz",
      "dst": "mod:os",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_fuzz",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_fold_fuzz",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_fold_fuzz",
      "dst": "fn:tests.test_fold_fuzz.test_fold_reader_rejects_random_payload",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_stress_long",
      "dst": "mod:math",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_stress_long",
      "dst": "mod:tracemalloc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_stress_long",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.test_stress_long",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.test_stress_long",
      "dst": "fn:tests.test_stress_long.test_100k_steps_stability_and_memory_signals",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_batch_create_issues",
      "dst": "mod:tools.batch_create_issues",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.tools.test_batch_create_issues",
      "dst": "fn:tests.tools.test_batch_create_issues.test_validate_batch_structure_duplicate_ids",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_create_issue_report",
      "dst": "mod:tools.create_issue_report",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.tools.test_create_issue_report",
      "dst": "fn:tests.tools.test_create_issue_report.test_generate_yaml_frontmatter_contains_id",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_link_validation",
      "dst": "mod:tools.validate_issue_format",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.tools.test_link_validation",
      "dst": "fn:tests.tools.test_link_validation.test_validate_links_missing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_sync_hub_auto",
      "dst": "mod:tools.sync_hub_auto",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.tools.test_sync_hub_auto",
      "dst": "fn:tests.tools.test_sync_hub_auto.test_status_to_emoji_done",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_validate_issue_format",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.tools.test_validate_issue_format",
      "dst": "mod:tools.validate_issue_format",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.tools.test_validate_issue_format",
      "dst": "fn:tests.tools.test_validate_issue_format.test_validate_structure_filename",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:__future__",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:torch.nn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:torch.optim",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:torch.utils.data",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:torchvision",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "cls:tests.training.mnist_cifar_training_reference.TrainingConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "cls:tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "dst": "cls:nn.Module",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "dst": "mtd:tests.training.mnist_cifar_training_reference.PyFoldsMLP.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.training.mnist_cifar_training_reference.PyFoldsMLP",
      "dst": "mtd:tests.training.mnist_cifar_training_reference.PyFoldsMLP.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "fn:tests.training.mnist_cifar_training_reference.build_dataset",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "fn:tests.training.mnist_cifar_training_reference.train_reference",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.training.mnist_cifar_training_reference",
      "dst": "fn:tests.training.mnist_cifar_training_reference.evaluate",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_adaptation",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_adaptation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_adaptation",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_adaptation",
      "dst": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "dst": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "dst": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_decay",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "dst": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_increment",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "dst": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_adaptation_respects_string_inference_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_adaptation.TestAdaptationMixin",
      "dst": "mtd:tests.unit.advanced.test_adaptation.TestAdaptationMixin.test_forward_updates_u_for_downstream_mixins",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_backprop",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_backprop",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_backprop",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_backprop",
      "dst": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "dst": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "dst": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_backprop_queue",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "dst": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_dendrite_amplification_decay",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "dst": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_bap_proportional_uses_dendritic_contribution",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_backprop.TestBackpropMixin",
      "dst": "mtd:tests.unit.advanced.test_backprop.TestBackpropMixin.test_time_counter_advances_only_after_forward",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_inhibition",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_inhibition",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_inhibition",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_inhibition",
      "dst": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_lateral_kernel",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_forward_feedforward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_apply_inhibition_accepts_u_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionLayer",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionLayer.test_e2i_initialization_is_deterministic",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_inhibition",
      "dst": "cls:tests.unit.advanced.test_inhibition.TestInhibitionMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_inhibition.TestInhibitionMixin",
      "dst": "mtd:tests.unit.advanced.test_inhibition.TestInhibitionMixin.test_forward_requires_initialized_inhibition",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_refractory",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_refractory",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_refractory",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_refractory",
      "dst": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "dst": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "dst": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_check_refractory_periods",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "dst": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_update_refractory",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "dst": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_refractory_blocks_spikes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_refractory.TestRefractoryMixin",
      "dst": "mtd:tests.unit.advanced.test_refractory.TestRefractoryMixin.test_forward_increments_time_once",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_short_term",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_short_term",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_short_term",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_short_term",
      "dst": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "dst": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "dst": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_no_spikes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "dst": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_with_spikes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "dst": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_tsodyks_markram_recovery",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin",
      "dst": "mtd:tests.unit.advanced.test_short_term.TestShortTermDynamicsMixin.test_update_aligns_stp_buffers_to_input_device",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_stdp",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_stdp",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_stdp",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.advanced.test_stdp",
      "dst": "mod:pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.advanced.test_stdp",
      "dst": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_trace_decay",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_pre_spike_updates_trace",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_should_apply_stdp",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_updates_underlying_synapses_online",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_input_source_raw_vs_stp",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_ltd_rule_classic_vs_current",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.advanced.test_stdp.TestSTDPMixin",
      "dst": "mtd:tests.unit.advanced.test_stdp.TestSTDPMixin.test_stdp_update_is_batch_size_invariant_for_identical_samples",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_accumulator",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_accumulator",
      "dst": "mod:collections",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_accumulator",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_accumulator",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_accumulator",
      "dst": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_history_respects_max_len",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_accumulate_rejects_invalid_shape",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_track_extra_accumulates_scalars_and_vectors",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_accumulator.TestStatisticsAccumulator",
      "dst": "mtd:tests.unit.core.test_accumulator.TestStatisticsAccumulator.test_reset_clears_state_and_history",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_config",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_config",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_config",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_config",
      "dst": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_default_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_custom_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_get_decay_rate_negative_dt_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_numerical_safety_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_config.TestMPJRDConfig",
      "dst": "mtd:tests.unit.core.test_config.TestMPJRDConfig.test_dendritic_integration_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_config",
      "dst": "fn:tests.unit.core.test_config.test_hebbian_ltd_ratio_must_be_non_negative",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_config_advanced_order_flags",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_config_advanced_order_flags",
      "dst": "mod:pyfolds.core",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_config_advanced_order_flags",
      "dst": "fn:tests.unit.core.test_config_advanced_order_flags.test_accepts_stdp_source_and_ltd_rule_flags",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_config_advanced_order_flags",
      "dst": "fn:tests.unit.core.test_config_advanced_order_flags.test_rejects_invalid_order_flags",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_dendrite",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_dendrite",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_dendrite",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_dendrite",
      "dst": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "dst": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "dst": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "dst": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_u_R_optional_state",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_dendrite.TestMPJRDDendrite",
      "dst": "mtd:tests.unit.core.test_dendrite.TestMPJRDDendrite.test_update_uses_local_pre_rate_per_synapse",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "mod:pyfolds.core",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "mod:pyfolds.core.factory",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "mod:pyfolds.wave",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "fn:tests.unit.core.test_factory.test_create_neuron_infers_standard_type",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "fn:tests.unit.core.test_factory.test_create_neuron_infers_wave_type",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_factory",
      "dst": "fn:tests.unit.core.test_factory.test_factory_raises_for_unregistered_type",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_health_monitor",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_health_monitor",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_health_monitor",
      "dst": "mod:pyfolds.monitoring",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_health_monitor",
      "dst": "fn:tests.unit.core.test_health_monitor.test_health_monitor_runs_and_scores",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_homeostasis",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_homeostasis",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_homeostasis",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_homeostasis",
      "dst": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "dst": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "dst": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_update",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "dst": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_is_stable_accepts_tolerance",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "dst": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_update_limits_theta_step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_homeostasis.TestHomeostasisController",
      "dst": "mtd:tests.unit.core.test_homeostasis.TestHomeostasisController.test_dead_neuron_rescue_has_minimum_strength",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "mod:pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "fn:tests.unit.core.test_input_validation_contract._cfg",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "fn:tests.unit.core.test_input_validation_contract.test_neuron_rejects_non_tensor_input",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "fn:tests.unit.core.test_input_validation_contract.test_neuron_rejects_input_from_different_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "fn:tests.unit.core.test_input_validation_contract.test_layer_prepare_input_accepts_supported_shapes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_input_validation_contract",
      "dst": "fn:tests.unit.core.test_input_validation_contract.test_layer_prepare_input_rejects_invalid_shape",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "mod:datetime",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "mod:pyfolds.monitoring",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "cls:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron",
      "dst": "mtd:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron",
      "dst": "mtd:tests.unit.core.test_monitoring_and_checkpoint.DummyNeuron.get_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_health_check_critical_for_dead_neurons",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_health_check_uses_fallback_metrics_from_get_metrics_contract",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_save_and_load",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_monitoring_and_checkpoint",
      "dst": "fn:tests.unit.core.test_monitoring_and_checkpoint.test_versioned_checkpoint_metadata_created_at_is_utc",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuromodulation",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuromodulation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuromodulation",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuromodulation",
      "dst": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "dst": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_external_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "dst": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_surprise_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "dst": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_rejects_non_finite_inputs",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuromodulation.TestNeuromodulator",
      "dst": "mtd:tests.unit.core.test_neuromodulation.TestNeuromodulator.test_infers_output_device_from_tensor_inputs",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron",
      "dst": "mod:pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuron",
      "dst": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_shunting_exposes_dendritic_contribution",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_step_alias",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_forward_mode_override_is_reported",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_online_plasticity_updates_when_not_deferred",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_batch_plasticity_preserves_local_pre_synaptic_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_modes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_neuron.TestMPJRDNeuron",
      "dst": "mtd:tests.unit.core.test_neuron.TestMPJRDNeuron.test_nmda_theta_eff_caps_unreachable_threshold",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "mod:concurrent.futures",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "fn:tests.unit.core.test_neuron_v2.test_forward_shapes_v2",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "fn:tests.unit.core.test_neuron_v2.test_cooperative_sum_uses_multiple_dendrites",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "fn:tests.unit.core.test_neuron_v2.test_step_id_thread_safe_increment_v2",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_neuron_v2",
      "dst": "fn:tests.unit.core.test_neuron_v2.test_theta_eff_caps_unreachable_threshold",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_synapse",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_synapse",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_synapse",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.core.test_synapse",
      "dst": "mod:pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.core.test_synapse",
      "dst": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_ltp",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_respects_plastic_flag",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_filters_inactive_pre_synaptic_activity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_uses_absolute_dt_and_mode_multiplier",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_saturation_recovery_disables_protection_after_timeout",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_negative_neuromodulation_promotes_ltd",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_consolidate_transfers_eligibility_and_decays_internal_potential",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.core.test_synapse.TestMPJRDSynapse",
      "dst": "mtd:tests.unit.core.test_synapse.TestMPJRDSynapse.test_update_supports_explicit_hebbian_ltd_component",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.network.test_network_edge_cases",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.network.test_network_edge_cases",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.network.test_network_edge_cases",
      "dst": "fn:tests.unit.network.test_network_edge_cases.test_prepare_input_with_single_dendrite_avoids_division_by_zero",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_adaptation_sfa",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_adaptation_sfa",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_adaptation_sfa",
      "dst": "fn:tests.unit.neuron.test_adaptation_sfa.test_sfa_applies_before_threshold_and_reduces_spiking_probability",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_backprop_bap",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_backprop_bap",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_backprop_bap",
      "dst": "fn:tests.unit.neuron.test_backprop_bap.test_bap_amplification_changes_dendritic_computation_and_clamps_gain",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "mod:numpy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "mod:pyfolds.contracts",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "fn:tests.unit.neuron.test_contract_conformance.test_torch_contract_invariants_order_and_time_step_end_of_step",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_contract_conformance",
      "dst": "fn:tests.unit.neuron.test_contract_conformance.test_torch_and_tf_contract_conformance_with_same_artificial_input_and_tolerance",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_refractory",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_refractory",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_refractory",
      "dst": "fn:tests.unit.neuron.test_refractory.test_absolute_refractory_is_inviolable",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_stp_stdp_contracts",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_stp_stdp_contracts",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_stp_stdp_contracts",
      "dst": "fn:tests.unit.neuron.test_stp_stdp_contracts.test_stdp_reads_pre_stp_input_for_pre_spikes_and_ltd_uses_pre_spike_gate",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_time_counter",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.neuron.test_time_counter",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.neuron.test_time_counter",
      "dst": "fn:tests.unit.neuron.test_time_counter.test_time_counter_increments_at_end_of_forward_step",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:mmap",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:struct",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:unittest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:numpy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:pyfolds.core.config",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:pyfolds.core.neuron",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:pyfolds.serialization",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "mod:pyfolds.serialization.foldio",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio._build_neuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_roundtrip_and_peek",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_roundtrip_preserves_state_dict_after_forward_steps",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_training_then_save_with_telemetry_and_history_and_nuclear_arrays",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_detects_corruption",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_hierarchical_hashes_present_in_metadata",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_ecc_from_protection_mapping",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_ecc_roundtrip_if_available",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_crc32c_matches_known_vector",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_with_mmap",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_bounds_validation_negative_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_index_size_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_index_offset_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_header_len_validation",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_io_failure_with_phase_context",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_reports_magic_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_reader_exit_closes_file_even_if_mmap_close_fails",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio._build_writer_with_chunk",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_writer_finalize_wraps_failures_with_phase",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio._failing_write_after_first_call",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_manifest_includes_governance_sections",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.serialization.test_foldio",
      "dst": "fn:tests.unit.serialization.test_foldio.test_fold_signature_roundtrip_if_cryptography_available",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_controller",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_controller",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_controller",
      "dst": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_initialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_off",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_light",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_profile_heavy",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_should_emit_sample",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_step_count_increments",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_snapshot_and_clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_controller.TestTelemetryController",
      "dst": "mtd:tests.unit.telemetry.test_controller.TestTelemetryController.test_get_stats",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_decorator",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_decorator",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_decorator",
      "dst": "cls:tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "dst": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_basic",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "dst": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_with_sample_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_decorator.TestTelemetryDecorator",
      "dst": "mtd:tests.unit.telemetry.test_decorator.TestTelemetryDecorator.test_decorator_lazy_evaluation",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "mod:time",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "mod:dataclasses",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "mod:typing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "cls:tests.unit.telemetry.test_events.TelemetryEvent",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_events.TelemetryEvent",
      "dst": "mtd:tests.unit.telemetry.test_events.TelemetryEvent.payload",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.forward_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.forward_event_lazy",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.commit_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.commit_event_lazy",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.sleep_event",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_events",
      "dst": "fn:tests.unit.telemetry.test_events.sleep_event_lazy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_ringbuffer",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_ringbuffer",
      "dst": "mod:threading",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_ringbuffer",
      "dst": "mod:pyfolds.telemetry",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_ringbuffer",
      "dst": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_append",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_snapshot_with_none",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_empty_snapshot",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_len",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_capacity_property",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_is_full",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_extend",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_ringbuffer.TestRingBuffer",
      "dst": "mtd:tests.unit.telemetry.test_ringbuffer.TestRingBuffer.test_thread_safety",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "mod:json",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "cls:tests.unit.telemetry.test_sinks.TestMemorySink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestMemorySink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_emit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestMemorySink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_capacity_limit",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestMemorySink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestMemorySink.test_clear",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "cls:tests.unit.telemetry.test_sinks.TestConsoleSink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestConsoleSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestConsoleSink.test_verbose",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestConsoleSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestConsoleSink.test_non_verbose",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_emit_basic",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_truncate_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_append_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_tensor_serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_depth_limit_serialization",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestJSONLinesSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestJSONLinesSink.test_non_serializable_fallback",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_sinks",
      "dst": "cls:tests.unit.telemetry.test_sinks.TestDistributorSink",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestDistributorSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestDistributorSink.test_distributes_to_all_sinks",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_sinks.TestDistributorSink",
      "dst": "mtd:tests.unit.telemetry.test_sinks.TestDistributorSink.test_sink_failure_doesnt_affect_others",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.telemetry.test_types",
      "dst": "mod:pyfolds.telemetry",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.telemetry.test_types",
      "dst": "cls:tests.unit.telemetry.test_types.TestPayloadTypes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_types.TestPayloadTypes",
      "dst": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_forward_payload",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_types.TestPayloadTypes",
      "dst": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_commit_payload",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.telemetry.test_types.TestPayloadTypes",
      "dst": "mtd:tests.unit.telemetry.test_types.TestPayloadTypes.test_sleep_payload",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "mod:importlib.util",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "mod:numpy",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "fn:tests.unit.test_backend_contracts.test_import_and_object_construction_v1_v2",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "fn:tests.unit.test_backend_contracts.test_torch_backend_shape_and_state_contracts",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "fn:tests.unit.test_backend_contracts._tf_forward_sequence_equivalent",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_backend_contracts",
      "dst": "fn:tests.unit.test_backend_contracts.test_tf_backend_conditional_shape_state_contracts",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.advanced",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.core",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.core.base",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.factory",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.network",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.utils",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "mod:pyfolds.utils.context",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "meta": {}
    },
    {
      "type": "INHERITS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "cls:*.BaseNeuron",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "mtd:tests.unit.test_design_improvements.DummyNeuron.__init__",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "mtd:tests.unit.test_design_improvements.DummyNeuron.forward",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "mtd:tests.unit.test_design_improvements.DummyNeuron.set_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "mtd:tests.unit.test_design_improvements.DummyNeuron.apply_plasticity",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.test_design_improvements.DummyNeuron",
      "dst": "mtd:tests.unit.test_design_improvements.DummyNeuron.get_metrics",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "fn:tests.unit.test_design_improvements.test_factory_creates_builtin_types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "fn:tests.unit.test_design_improvements.test_factory_custom_registry_and_unknown_type",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "fn:tests.unit.test_design_improvements.test_learning_mode_context_restores_even_on_error",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_design_improvements",
      "dst": "fn:tests.unit.test_design_improvements.test_network_builder_connects_layers_and_builds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "mod:pyfolds.core",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "mod:pyfolds.layers",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "fn:tests.unit.test_layer_neuron_class.test_layer_accepts_neuron_v2",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "fn:tests.unit.test_layer_neuron_class.test_layer_rejects_invalid_neuron_cls",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "fn:tests.unit.test_layer_neuron_class.test_layer_has_no_legacy_neuron_class_attr",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_layer_neuron_class",
      "dst": "fn:tests.unit.test_layer_neuron_class.test_layer_forwards_dt_to_neurons",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pyfolds.core",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pyfolds.layers",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pyfolds.network",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "mod:pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency._make_layer",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_learning_mode_single_source",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_learning_mode_from_string",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_string",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_layer_accepts_mode_enum",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_layer_rejects_invalid_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_network_accepts_mode_string",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_learning_mode_consistency",
      "dst": "fn:tests.unit.test_learning_mode_consistency.test_network_rejects_invalid_mode",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "mod:warnings",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "mod:packaging.version",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "fn:tests.unit.test_public_import_surface.test_public_all_exports_are_importable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "fn:tests.unit.test_public_import_surface.test_v2_surface_is_canonical_and_instantiable",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "fn:tests.unit.test_public_import_surface.test_v1_aliases_emit_deprecation_warning_and_match_v2_targets_until_2_0",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_public_import_surface",
      "dst": "fn:tests.unit.test_public_import_surface.test_telemetry_controller_basic_flow",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "mod:subprocess",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "mod:sys",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner._run",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner.test_runner_logs_syntax_error",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner.test_runner_logs_runtime_error_and_propagates_exit_code",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner.test_runner_tee_prints_progress",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner.test_runner_timeout_watchdog",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_run_pyfolds_runner",
      "dst": "fn:tests.unit.test_run_pyfolds_runner.test_runner_retry_and_metrics_csv",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "mod:importlib.util",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "fn:tests.unit.test_tf_backend.test_importing_pyfolds_still_works_without_tensorflow",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "fn:tests.unit.test_tf_backend.test_tf_backend_guard_when_tensorflow_is_missing",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "fn:tests.unit.test_tf_backend.test_tf_cell_state_and_step_contract",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.test_tf_backend",
      "dst": "fn:tests.unit.test_tf_backend.test_tf_layer_integrates_with_keras_rnn",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_device",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_device",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_device",
      "dst": "mod:pyfolds.utils",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_device",
      "dst": "cls:tests.unit.utils.test_device.TestDevice",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_device.TestDevice",
      "dst": "mtd:tests.unit.utils.test_device.TestDevice.test_infer_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_device.TestDevice",
      "dst": "mtd:tests.unit.utils.test_device.TestDevice.test_get_device",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_math",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_math",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_math",
      "dst": "mod:pyfolds.utils",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_math",
      "dst": "mod:pyfolds.utils.math",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_math",
      "dst": "cls:tests.unit.utils.test_math.TestMath",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_math.TestMath",
      "dst": "mtd:tests.unit.utils.test_math.TestMath.test_safe_div",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_math.TestMath",
      "dst": "mtd:tests.unit.utils.test_math.TestMath.test_clamp_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_math.TestMath",
      "dst": "mtd:tests.unit.utils.test_math.TestMath.test_clamp_R",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_math.TestMath",
      "dst": "mtd:tests.unit.utils.test_math.TestMath.test_safe_weight_law_is_bounded_and_finite",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_types",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_types",
      "dst": "mod:pyfolds.utils.types",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_types",
      "dst": "cls:tests.unit.utils.test_types.TestTypes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_types.TestTypes",
      "dst": "mtd:tests.unit.utils.test_types.TestTypes.test_learning_mode",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_types.TestTypes",
      "dst": "mtd:tests.unit.utils.test_types.TestTypes.test_connection_type",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:re",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:tempfile",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:subprocess",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:os",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:pathlib",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:pyfolds.utils.logging",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "mod:pyfolds.utils",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "cls:tests.unit.utils.test_utils.TestMath",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_safe_div_basic",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_safe_div_by_zero",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_rate_tensor",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_rate_float",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_R_tensor",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_clamp_R_float",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_xavier_init_shape",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_xavier_init_gain",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestMath",
      "dst": "mtd:tests.unit.utils.test_utils.TestMath.test_calculate_vc_dimension",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "cls:tests.unit.utils.test_utils.TestDevice",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_none",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cpu",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_tensor_cuda",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_infer_device_empty_dict",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_ensure_device_no_change",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_ensure_device_move",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_get_device_default",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestDevice",
      "dst": "mtd:tests.unit.utils.test_utils.TestDevice.test_get_device_specific",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "cls:tests.unit.utils.test_utils.TestTypes",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_mode_values",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_mode_description",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_learning_rate_multiplier",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_is_learning",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_is_consolidating",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_connection_type",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_defaults",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_get_learning_rate",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestTypes",
      "dst": "mtd:tests.unit.utils.test_utils.TestTypes.test_mode_config_get_consolidation_factor",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "cls:tests.unit.utils.test_utils.TestLogging",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_trace_level_defined",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_trace_method_exists",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_get_logger",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_pyfolds_logger_singleton",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_setup_basic",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_trace_output",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_trace_silent_when_lower_level",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_import_pyfolds_does_not_add_stream_handler",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_setup_run_logging_returns_logger_and_path",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_file_handler",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_console_false_keeps_terminal_clean",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_fixed_layout",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_build_log_path_increments_counter",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_next_log_path_alias",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_logger_circular_buffer_file_handler",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_multiple_loggers_same_name",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestLogging",
      "dst": "mtd:tests.unit.utils.test_utils.TestLogging.test_module_levels",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_utils",
      "dst": "cls:tests.unit.utils.test_utils.TestIntegration",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestIntegration",
      "dst": "mtd:tests.unit.utils.test_utils.TestIntegration.test_logging_with_device",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestIntegration",
      "dst": "mtd:tests.unit.utils.test_utils.TestIntegration.test_learning_mode_with_math",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "cls:tests.unit.utils.test_utils.TestIntegration",
      "dst": "mtd:tests.unit.utils.test_utils.TestIntegration.test_device_with_tensor_ops",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_validation",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_validation",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.utils.test_validation",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_validation",
      "dst": "fn:tests.unit.utils.test_validation.test_neuron_forward_validation_ndim",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.utils.test_validation",
      "dst": "fn:tests.unit.utils.test_validation.test_neuron_forward_validation_dtype",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_config",
      "dst": "mod:pytest",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_config",
      "dst": "mod:pyfolds.wave",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_config",
      "dst": "fn:tests.unit.wave.test_wave_config.test_wave_config_defaults_valid",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_config",
      "dst": "fn:tests.unit.wave.test_wave_config.test_wave_config_rejects_invalid_buffer",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_layer_network",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_layer_network",
      "dst": "mod:pyfolds",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_layer_network",
      "dst": "fn:tests.unit.wave.test_wave_layer_network.test_wave_layer_exposes_wave_outputs",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_layer_network",
      "dst": "fn:tests.unit.wave.test_wave_layer_network.test_wave_network_forwards_layer_kwargs",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_neuron",
      "dst": "mod:torch",
      "meta": {}
    },
    {
      "type": "IMPORT",
      "src": "mod:tests.unit.wave.test_wave_neuron",
      "dst": "mod:pyfolds.wave",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_neuron",
      "dst": "fn:tests.unit.wave.test_wave_neuron.test_wave_outputs_quadrature_and_phase_range",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_neuron",
      "dst": "fn:tests.unit.wave.test_wave_neuron.test_cooperative_integration_uses_multiple_dendrites",
      "meta": {}
    },
    {
      "type": "CONTAINS",
      "src": "mod:tests.unit.wave.test_wave_neuron",
      "dst": "fn:tests.unit.wave.test_wave_neuron.test_wave_step_id_thread_safe_increment",
      "meta": {}
    }
  ],
  "findings": [],
  "metrics": {
    "python_files": 134,
    "symbols": 956,
    "edges": 1435,
    "findings": 0,
    "internal_import_edges": 101
  }
}